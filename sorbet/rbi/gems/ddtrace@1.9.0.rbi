# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ddtrace` gem.
# Please instead update this file by running `bin/tapioca gem ddtrace`.


# source://ddtrace//lib/ddtrace/version.rb#3
module DDTrace; end

# source://ddtrace//lib/ddtrace/version.rb#4
module DDTrace::VERSION; end

# source://ddtrace//lib/ddtrace/version.rb#5
DDTrace::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# A maximum version was initially added in https://github.com/DataDog/dd-trace-rb/pull/1495 because we expected
# the `ruby2_keywords` method to be removed (see the PR for the discussion).
# That is because Ruby 3.x support as implemented using `*args` needs `ruby2_keywords` to continue working,
# but if `ruby2_keywords` gets removed we would need to change the code to use `*args, **kwargs`.
#
# Now Ruby 3.2.0-preview1 is out and `ruby2_keywords` are still there, and there's even a recent change for it
# in https://github.com/ruby/ruby/pull/5684 that is documented as "ruby2_keywords needed in 3.2+".
#
# So for now let's bump the maximum version to < 3.3 to allow the Ruby 3.2 series to be supported and we can keep
# an eye on the Ruby 3.2 test releases to see if anything changes. (Otherwise, once Ruby 3.2.0 stable is out, we
# should probably bump this to 3.4, and so on...)
#
# source://ddtrace//lib/ddtrace/version.rb#25
DDTrace::VERSION::MAXIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/version.rb#12
DDTrace::VERSION::MINIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/version.rb#6
DDTrace::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/ddtrace/version.rb#7
DDTrace::VERSION::PATCH = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/ddtrace/version.rb#8
DDTrace::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://ddtrace//lib/ddtrace/version.rb#10
DDTrace::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#3
module Datadog
  extend ::Datadog::Core::Extensions
  extend ::Datadog::Core::Configuration
  extend ::Datadog::Tracing::Contrib::Extensions::Helpers
  extend ::Datadog::Tracing::Contrib::Extensions::Configuration
end

# Namespace for Datadog CI instrumentation:
# e.g. rspec, cucumber, etc...
#
# source://ddtrace//lib/datadog/ci.rb#10
module Datadog::CI; end

# source://ddtrace//lib/datadog/ci/configuration/settings.rb#7
module Datadog::CI::Configuration; end

# Adds CI behavior to Datadog trace components
#
# source://ddtrace//lib/datadog/ci/configuration/components.rb#9
module Datadog::CI::Configuration::Components
  # source://ddtrace//lib/datadog/ci/configuration/components.rb#10
  def initialize(settings); end

  # source://ddtrace//lib/datadog/ci/configuration/components.rb#18
  def activate_ci!(settings); end
end

# Adds CI behavior to Datadog trace settings
#
# source://ddtrace//lib/datadog/ci/configuration/settings.rb#9
module Datadog::CI::Configuration::Settings
  class << self
    # source://ddtrace//lib/datadog/ci/configuration/settings.rb#15
    def add_settings!(base); end

    # @private
    #
    # source://ddtrace//lib/datadog/ci/configuration/settings.rb#10
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#5
module Datadog::CI::Contrib; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#6
module Datadog::CI::Contrib::Cucumber; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/configuration/settings.rb#10
module Datadog::CI::Contrib::Cucumber::Configuration; end

# Custom settings for the Cucumber integration
# TODO: mark as `@public_api` when GA
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/configuration/settings.rb#13
class Datadog::CI::Contrib::Cucumber::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def operation_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def operation_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Cucumber integration constants
# TODO: mark as `@public_api` when GA, to protect from resource and tag name changes.
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#9
module Datadog::CI::Contrib::Cucumber::Ext; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#10
Datadog::CI::Contrib::Cucumber::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#11
Datadog::CI::Contrib::Cucumber::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#12
Datadog::CI::Contrib::Cucumber::Ext::ENV_OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#13
Datadog::CI::Contrib::Cucumber::Ext::FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#14
Datadog::CI::Contrib::Cucumber::Ext::OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#15
Datadog::CI::Contrib::Cucumber::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#16
Datadog::CI::Contrib::Cucumber::Ext::STEP_SPAN_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#17
Datadog::CI::Contrib::Cucumber::Ext::TEST_TYPE = T.let(T.unsafe(nil), String)

# Defines collection of instrumented Cucumber events
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#14
class Datadog::CI::Contrib::Cucumber::Formatter
  # @return [Formatter] a new instance of Formatter
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#19
  def initialize(config); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#25
  def bind_events(config); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#49
  def on_test_case_finished(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#32
  def on_test_case_started(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#71
  def on_test_step_finished(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#63
  def on_test_step_started(event); end

  private

  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def config; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#87
  def configuration; end

  # Returns the value of attribute current_feature_span.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def current_feature_span; end

  # Returns the value of attribute current_step_span.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def current_step_span; end
end

# Instrumentation for Cucumber
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#10
module Datadog::CI::Contrib::Cucumber::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#16
module Datadog::CI::Contrib::Cucumber::Instrumentation::InstanceMethods
  # Returns the value of attribute datadog_formatter.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#17
  def datadog_formatter; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#19
  def formatters; end
end

# Description of Cucumber integration
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#13
class Datadog::CI::Contrib::Cucumber::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # test environments should not auto instrument test libraries
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#34
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#38
  def new_configuration; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#42
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#16
Datadog::CI::Contrib::Cucumber::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'cucumber' module.
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#11
module Datadog::CI::Contrib::Cucumber::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#6
module Datadog::CI::Contrib::RSpec; end

# source://ddtrace//lib/datadog/ci/contrib/rspec/configuration/settings.rb#10
module Datadog::CI::Contrib::RSpec::Configuration; end

# Custom settings for the RSpec integration
# TODO: mark as `@public_api` when GA
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/configuration/settings.rb#13
class Datadog::CI::Contrib::RSpec::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def operation_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def operation_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Instrument RSpec::Core::Example
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#15
module Datadog::CI::Contrib::RSpec::Example
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#16
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#21
module Datadog::CI::Contrib::RSpec::Example::InstanceMethods
  # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#22
  def run(example_group_instance, reporter); end

  private

  # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#62
  def configuration; end
end

# RSpec integration constants
# TODO: mark as `@public_api` when GA, to protect from resource and tag name changes.
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#9
module Datadog::CI::Contrib::RSpec::Ext; end

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#10
Datadog::CI::Contrib::RSpec::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#11
Datadog::CI::Contrib::RSpec::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#12
Datadog::CI::Contrib::RSpec::Ext::ENV_OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#13
Datadog::CI::Contrib::RSpec::Ext::FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#14
Datadog::CI::Contrib::RSpec::Ext::OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#15
Datadog::CI::Contrib::RSpec::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#16
Datadog::CI::Contrib::RSpec::Ext::TEST_TYPE = T.let(T.unsafe(nil), String)

# Description of RSpec integration
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#13
class Datadog::CI::Contrib::RSpec::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # test environments should not auto instrument test libraries
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#16
Datadog::CI::Contrib::RSpec::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rspec' module.
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#11
module Datadog::CI::Contrib::RSpec::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#5
module Datadog::CI::Ext; end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#6
module Datadog::CI::Ext::AppTypes; end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#7
Datadog::CI::Ext::AppTypes::TYPE_TEST = T.let(T.unsafe(nil), String)

# Defines constants for CI tags
#
# source://ddtrace//lib/datadog/ci/ext/environment.rb#14
module Datadog::CI::Ext::Environment
  include ::Kernel

  private

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#537
  def branch_or_tag(branch_or_tag); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#501
  def exec_git_command(cmd); end

  # CI providers
  #
  # source://ddtrace//lib/datadog/ci/ext/environment.rb#91
  def extract_appveyor(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#125
  def extract_azure_pipelines(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#166
  def extract_bitbucket(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#375
  def extract_bitrise(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#187
  def extract_buddy(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#205
  def extract_buildkite(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#228
  def extract_circle_ci(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#251
  def extract_github_actions(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#284
  def extract_gitlab(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#314
  def extract_jenkins(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#513
  def extract_local_git; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#548
  def extract_name_email(name_and_email); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#341
  def extract_teamcity(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#358
  def extract_travis(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#405
  def extract_user_defined_git(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#85
  def filter_sensitive_info(url); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#492
  def git_base_directory; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#465
  def git_branch; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#456
  def git_commit_message; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#474
  def git_commit_sha; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#421
  def git_commit_users; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#447
  def git_repository_url; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#483
  def git_tag; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#78
  def normalize_ref(name); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#45
  def tags(env); end

  class << self
    # source://ddtrace//lib/datadog/ci/ext/environment.rb#537
    def branch_or_tag(branch_or_tag); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#501
    def exec_git_command(cmd); end

    # CI providers
    #
    # source://ddtrace//lib/datadog/ci/ext/environment.rb#91
    def extract_appveyor(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#125
    def extract_azure_pipelines(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#166
    def extract_bitbucket(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#375
    def extract_bitrise(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#187
    def extract_buddy(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#205
    def extract_buildkite(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#228
    def extract_circle_ci(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#251
    def extract_github_actions(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#284
    def extract_gitlab(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#314
    def extract_jenkins(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#513
    def extract_local_git; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#548
    def extract_name_email(name_and_email); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#341
    def extract_teamcity(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#358
    def extract_travis(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#405
    def extract_user_defined_git(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#85
    def filter_sensitive_info(url); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#492
    def git_base_directory; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#465
    def git_branch; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#456
    def git_commit_message; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#474
    def git_commit_sha; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#421
    def git_commit_users; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#447
    def git_repository_url; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#483
    def git_tag; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#78
    def normalize_ref(name); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#45
    def tags(env); end
  end
end

# source://ddtrace//lib/datadog/ci/ext/environment.rb#28
Datadog::CI::Ext::Environment::PROVIDERS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#26
Datadog::CI::Ext::Environment::TAG_CI_ENV_VARS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#17
Datadog::CI::Ext::Environment::TAG_JOB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#18
Datadog::CI::Ext::Environment::TAG_JOB_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#19
Datadog::CI::Ext::Environment::TAG_PIPELINE_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#20
Datadog::CI::Ext::Environment::TAG_PIPELINE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#21
Datadog::CI::Ext::Environment::TAG_PIPELINE_NUMBER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#22
Datadog::CI::Ext::Environment::TAG_PIPELINE_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#23
Datadog::CI::Ext::Environment::TAG_PROVIDER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#24
Datadog::CI::Ext::Environment::TAG_STAGE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#25
Datadog::CI::Ext::Environment::TAG_WORKSPACE_PATH = T.let(T.unsafe(nil), String)

# Defines constants for test tags
#
# source://ddtrace//lib/datadog/ci/ext/settings.rb#7
module Datadog::CI::Ext::Settings; end

# source://ddtrace//lib/datadog/ci/ext/settings.rb#8
Datadog::CI::Ext::Settings::ENV_MODE_ENABLED = T.let(T.unsafe(nil), String)

# Defines constants for test tags
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#7
module Datadog::CI::Ext::Test; end

# source://ddtrace//lib/datadog/ci/ext/test.rb#8
Datadog::CI::Ext::Test::CONTEXT_ORIGIN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#29
module Datadog::CI::Ext::Test::Status; end

# source://ddtrace//lib/datadog/ci/ext/test.rb#31
Datadog::CI::Ext::Test::Status::FAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#30
Datadog::CI::Ext::Test::Status::PASS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#32
Datadog::CI::Ext::Test::Status::SKIP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#10
Datadog::CI::Ext::Test::TAG_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#11
Datadog::CI::Ext::Test::TAG_FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#12
Datadog::CI::Ext::Test::TAG_FRAMEWORK_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#13
Datadog::CI::Ext::Test::TAG_NAME = T.let(T.unsafe(nil), String)

# Environment runtime tags
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#21
Datadog::CI::Ext::Test::TAG_OS_ARCHITECTURE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#22
Datadog::CI::Ext::Test::TAG_OS_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#23
Datadog::CI::Ext::Test::TAG_RUNTIME_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#24
Datadog::CI::Ext::Test::TAG_RUNTIME_VERSION = T.let(T.unsafe(nil), String)

# DEV: Not populated yet
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#14
Datadog::CI::Ext::Test::TAG_SKIP_REASON = T.let(T.unsafe(nil), String)

# TODO: is there a better place for SPAN_KIND?
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#27
Datadog::CI::Ext::Test::TAG_SPAN_KIND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#15
Datadog::CI::Ext::Test::TAG_STATUS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#16
Datadog::CI::Ext::Test::TAG_SUITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#17
Datadog::CI::Ext::Test::TAG_TRAITS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#18
Datadog::CI::Ext::Test::TAG_TYPE = T.let(T.unsafe(nil), String)

# Extends Datadog tracing with CI features
#
# source://ddtrace//lib/datadog/ci/extensions.rb#12
module Datadog::CI::Extensions
  class << self
    # source://ddtrace//lib/datadog/ci/extensions.rb#13
    def activate!; end
  end
end

# source://ddtrace//lib/datadog/ci/flush.rb#8
module Datadog::CI::Flush; end

# Consumes only completed traces (where all spans have finished)
#
# source://ddtrace//lib/datadog/ci/flush.rb#28
class Datadog::CI::Flush::Finished < ::Datadog::Tracing::Flush::Finished
  include ::Datadog::CI::Flush::Tagging
end

# Performs partial trace flushing to avoid large traces residing in memory for too long
#
# source://ddtrace//lib/datadog/ci/flush.rb#33
class Datadog::CI::Flush::Partial < ::Datadog::Tracing::Flush::Partial
  include ::Datadog::CI::Flush::Tagging
end

# Common behavior for CI flushing
#
# source://ddtrace//lib/datadog/ci/flush.rb#10
module Datadog::CI::Flush::Tagging
  # Decorate a trace with CI tags
  #
  # source://ddtrace//lib/datadog/ci/flush.rb#12
  def get_trace(trace_op); end
end

# Common behavior for CI tests
#
# source://ddtrace//lib/datadog/ci/test.rb#15
module Datadog::CI::Test
  class << self
    # source://ddtrace//lib/datadog/ci/test.rb#64
    def failed!(span, exception = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/ci/test.rb#60
    def passed!(span); end

    # Adds tags to a CI test span.
    #
    # source://ddtrace//lib/datadog/ci/test.rb#36
    def set_tags!(trace, span, tags = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/ci/test.rb#70
    def skipped!(span, exception = T.unsafe(nil)); end

    # Creates a new span for a CI test
    #
    # source://ddtrace//lib/datadog/ci/test.rb#17
    def trace(span_name, options = T.unsafe(nil)); end

    private

    # source://ddtrace//lib/datadog/ci/test.rb#75
    def set_environment_runtime_tags!(span); end
  end
end

# Common, lower level, internal code used (or usable) by two or more
# products. It is a dependency of each product. Contrast with Datadog::Kit
# for higher-level features.
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#4
module Datadog::Core
  class << self
    # Records the occurrence of a deprecated operation in this library.
    #
    # Currently, these operations are logged to `Datadog.logger` at `warn` level.
    #
    # `disallowed_next_major` adds a message informing that the deprecated operation
    # won't be allowed in the next major release.
    #
    # @param disallowed_next_major [Boolean] whether this deprecation will be enforced in the next major release.
    # @yieldreturn [String] a String with the lazily evaluated deprecation message.
    #
    # source://ddtrace//lib/datadog/core.rb#23
    def log_deprecation(disallowed_next_major: T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/core/buffer/random.rb#5
module Datadog::Core::Buffer; end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# Because singular +Array+ operations are thread-safe in CRuby,
# we can implement the buffer without an explicit lock,
# while making the compromise of allowing the buffer to go
# over its maximum limit under extreme circumstances.
#
# On the following scenario:
# * 4.5 million spans/second.
# * Pushed into a single CRubyTraceBuffer from 1000 threads.
#
# This implementation allocates less memory and is faster
# than {Datadog::Core::Buffer::ThreadSafe}.
#
# @see spec/ddtrace/benchmark/buffer_benchmark_spec.rb Buffer benchmarks
# @see https://github.com/ruby-concurrency/concurrent-ruby/blob/c1114a0c6891d9634f019f1f9fe58dcae8658964/lib/concurrent-ruby/concurrent/array.rb#L23-L27
#
# source://ddtrace//lib/datadog/core/buffer/cruby.rb#25
class Datadog::Core::Buffer::CRuby < ::Datadog::Core::Buffer::Random
  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://ddtrace//lib/datadog/core/buffer/cruby.rb#32
  def replace!(item); end
end

# A very large number to allow us to effectively
# drop all items when invoking `slice!(i, FIXNUM_MAX)`.
#
# source://ddtrace//lib/datadog/core/buffer/cruby.rb#28
Datadog::Core::Buffer::CRuby::FIXNUM_MAX = T.let(T.unsafe(nil), Integer)

# Buffer that stores objects. The buffer has a maximum size and when
# the buffer is full, a random object is discarded.
#
# source://ddtrace//lib/datadog/core/buffer/random.rb#11
class Datadog::Core::Buffer::Random
  # @return [Random] a new instance of Random
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#12
  def initialize(max_size); end

  # Closes this buffer, preventing further pushing.
  # Draining is still allowed.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#63
  def close; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#67
  def closed?; end

  # A bulk push alternative to +#push+. Use this method if
  # pushing more than one item for efficiency.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#33
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#57
  def empty?; end

  # Return the current number of stored items.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#52
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#47
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full.
  #
  # When the buffer is full, we try to ensure that we are fairly choosing newly
  # pushed items by randomly inserting them into the buffer slots. This discards
  # old items randomly while trying to ensure that recent items are still captured.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#24
  def push(item); end

  protected

  # source://ddtrace//lib/datadog/core/buffer/random.rb#110
  def add!(item); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#106
  def add_all!(items); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#126
  def drain!; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#102
  def full?; end

  # Segment items into two segments: underflow and overflow.
  # Underflow are items that will fit into buffer.
  # Overflow are items that will exceed capacity, after underflow is added.
  # Returns each array, and nil if there is no underflow/overflow.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#77
  def overflow_segments(items); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#114
  def replace!(item); end
end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently on any environment.
#
# This implementation uses a {Mutex} around public methods, incurring
# overhead in order to ensure thread-safety.
#
# This is implementation is recommended for non-CRuby environments.
# If using CRuby, {Datadog::Core::Buffer::CRuby} is a faster implementation with minimal compromise.
#
# source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#16
class Datadog::Core::Buffer::ThreadSafe < ::Datadog::Core::Buffer::Random
  # @return [ThreadSafe] a new instance of ThreadSafe
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#17
  def initialize(max_size); end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#48
  def close; end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#29
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#39
  def empty?; end

  # Return the current number of stored items.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#34
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#44
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#25
  def push(item); end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#52
  def synchronize(&block); end
end

# Chunks list of elements into batches
#
# source://ddtrace//lib/datadog/core/chunker.rb#6
module Datadog::Core::Chunker
  private

  # Chunks a list into batches of at most +max_chunk_size+ elements each.
  #
  # An exception can occur if a single element is too large. That single
  # element will be returned in its own chunk. You have to verify by yourself
  # when such elements are returned.
  #
  # @param list [Enumerable] list of elements
  # @param max_chunk_size [Numeric] maximum acceptable chunk size
  # @return [Enumerable] lazy list of chunks
  #
  # source://ddtrace//lib/datadog/core/chunker.rb#18
  def chunk_by_size(list, max_chunk_size); end

  class << self
    # Chunks a list into batches of at most +max_chunk_size+ elements each.
    #
    # An exception can occur if a single element is too large. That single
    # element will be returned in its own chunk. You have to verify by yourself
    # when such elements are returned.
    #
    # @param list [Enumerable] list of elements
    # @param max_chunk_size [Numeric] maximum acceptable chunk size
    # @return [Enumerable] lazy list of chunks
    #
    # source://ddtrace//lib/datadog/core/chunker.rb#18
    def chunk_by_size(list, max_chunk_size); end
  end
end

# Configuration provides a unique access point for configurations
#
# source://ddtrace//lib/datadog/core/configuration/option_set.rb#5
module Datadog::Core::Configuration
  include ::Kernel

  # Current Datadog configuration.
  #
  # Access to non-global configuration will raise an error.
  #
  # To modify the configuration, use {.configure}.
  #
  # @return [Datadog::Core::Configuration::Settings]
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#53
  def configuration; end

  # Sets the attribute configuration
  #
  # @param value the value to set the attribute configuration to.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#42
  def configuration=(_arg0); end

  # Get configuration changes applied only to a specific Ruby object, via {.configure_onto}.
  # An example of an object with specific configuration:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # config = Datadog.configuration_for(client)
  # config[:service_name] # => 'api-requests'
  # config[:split_by_domain] # => true
  # ```
  #
  # @param target [Object] the object to receive configuration options
  # @param option [Object] an option to retrieve from the object configuration
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#151
  def configuration_for(target, option = T.unsafe(nil)); end

  # Apply global configuration changes to `Datadog`. An example of a {.configure} call:
  #
  # ```
  # Datadog.configure do |c|
  #   c.service = 'my-service'
  #   c.env = 'staging'
  #   # c.diagnostics.debug = true # Enables debug output
  # end
  # ```
  #
  # See {Datadog::Core::Configuration::Settings} for all available options, defaults, and
  # available environment variables for configuration.
  #
  # Only permits access to global configuration settings; others will raise an error.
  # If you wish to configure a setting for a specific Datadog component (e.g. Tracing),
  # use the corresponding `Datadog::COMPONENT.configure` method instead.
  #
  # Because many configuration changes require restarting internal components,
  # invoking {.configure} is the only safe way to change `Datadog` configuration.
  #
  # Successive calls to {.configure} maintain the previous configuration values:
  # configuration is additive between {.configure} calls.
  #
  # The yielded configuration `c` comes pre-populated from environment variables, if
  # any are applicable.
  #
  # @yieldparam c [Datadog::Core::Configuration::Settings] the mutable configuration object
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#84
  def configure; end

  # Apply configuration changes only to a specific Ruby object.
  #
  # Certain integrations or Datadog features may use these
  # settings to customize behavior for this object.
  #
  # An example of a {.configure_onto} call:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # ```
  #
  # In this example, it will configure the `client` object with custom options
  # `service_name: 'api-requests', split_by_domain: true`. The `Net::HTTP` integration
  # will then use these customized options when the `client` is used, whereas other
  # clients will use the `service_name: 'http-requests'` configuration provided to the
  # `Datadog.configure` call block.
  #
  # {.configure_onto} is used to separate cases where spans generated by certain objects
  # require exceptional options.
  #
  # The configuration keyword arguments provided should match well known options defined
  # in the integration or feature that would use them.
  #
  # For example, for `Datadog.configure_onto(redis_client, **opts)`, `opts` can be
  # any of the options in the Redis {Datadog::Tracing::Contrib::Redis::Configuration::Settings} class.
  #
  # @param target [Object] the object to receive configuration options
  # @param opts [Hash] keyword arguments respective to the integration this object belongs to
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#133
  def configure_onto(target, **opts); end

  # Internal {Datadog::Statsd} metrics collection.
  #
  # The list of metrics collected can be found in {Datadog::Core::Diagnostics::Ext::Health::Metrics}.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#162
  def health_metrics; end

  # source://ddtrace//lib/datadog/core/configuration.rb#166
  def logger; end

  # Gracefully shuts down all components.
  #
  # Components will still respond to method calls as usual,
  # but might not internally perform their work after shutdown.
  #
  # This avoids errors being raised across the host application
  # during shutdown, while allowing for graceful decommission of resources.
  #
  # Components won't be automatically reinitialized after a shutdown.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#187
  def shutdown!; end

  protected

  # source://ddtrace//lib/datadog/core/configuration.rb#195
  def components(allow_initialization: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/configuration.rb#247
  def build_components(settings); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#242
  def components?; end

  # Called from our at_exit hook whenever there was a pending Interrupt exception (e.g. typically due to ctrl+c)
  # to print a nice message whenever we're taking a bit longer than usual to finish the process.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#273
  def handle_interrupt_shutdown!; end

  # source://ddtrace//lib/datadog/core/configuration.rb#261
  def logger_without_components; end

  # source://ddtrace//lib/datadog/core/configuration.rb#253
  def replace_components!(settings, old); end

  # Gracefully shuts down Datadog components and disposes of component references,
  # allowing execution to start anew.
  #
  # In contrast with +#shutdown!+, components will be automatically
  # reinitialized after a reset.
  #
  # Used internally to ensure a clean environment between test runs.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#213
  def reset!; end

  # source://ddtrace//lib/datadog/core/configuration.rb#221
  def safely_synchronize; end
end

# This class unifies all the different ways that users can configure how we talk to the agent.
#
# It has quite a lot of complexity, but this complexity just reflects the actual complexity we have around our
# configuration today. E.g., this is just all of the complexity regarding agent settings gathered together in a
# single place. As we deprecate more and more of the different ways that these things can be configured,
# this class will reflect that simplification as well.
#
# Whenever there is a conflict (different configurations are provided in different orders), it MUST warn the users
# about it and pick a value based on the following priority: code > environment variable > defaults.
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#21
class Datadog::Core::Configuration::AgentSettingsResolver
  # @return [AgentSettingsResolver] a new instance of AgentSettingsResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#79
  def initialize(settings, logger: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#114
  def adapter; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#84
  def call; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#124
  def configured_hostname; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#147
  def configured_port; end

  # In transport_options, we try to invoke the transport_options proc and get its configuration. In case that
  # doesn't work, we include the proc directly in the agent settings result.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#209
  def deprecated_for_removal_transport_configuration_proc; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#188
  def hostname; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#282
  def log_warning(message); end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#75
  def logger; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#234
  def parsed_url; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#259
  def pick_from(*configurations_in_priority_order); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#192
  def port; end

  # Returns the value of attribute settings.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#75
  def settings; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#230
  def should_use_uds_fallback?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#183
  def ssl?; end

  # Defaults to +nil+, letting the adapter choose what default
  # works best in their case.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#203
  def timeout_seconds; end

  # The settings.tracing.transport_options allows users to have full control over the settings used to
  # communicate with the agent. In the general case, we can't extract the configuration from this proc, but
  # in the specific case of the http and unix socket adapters we can, and we use this method together with the
  # `TransportOptionsResolver` to call the proc and extract its information.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#290
  def transport_options; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#170
  def try_parsing_as_integer(value:, friendly_name:); end

  # We only use the default unix socket if it is already present.
  # This is by design, as we still want to use the default host:port if no unix socket is present.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#217
  def uds_fallback; end

  # Unix socket path in the file system
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#197
  def uds_path; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#271
  def warn_if_configuration_mismatch(detected_configurations_in_priority_order); end

  class << self
    # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#69
    def call(settings, logger: T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#23
class Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings < ::Struct
  # @return [AgentSettings] a new instance of AgentSettings
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#32
  def initialize(adapter:, ssl:, hostname:, port:, uds_path:, timeout_seconds:, deprecated_for_removal_transport_configuration_proc:); end

  # Returns the value of attribute adapter
  #
  # @return [Object] the current value of adapter
  def adapter; end

  # Sets the attribute adapter
  #
  # @param value [Object] the value to set the attribute adapter to.
  # @return [Object] the newly set value
  def adapter=(_); end

  # Returns the value of attribute deprecated_for_removal_transport_configuration_proc
  #
  # @return [Object] the current value of deprecated_for_removal_transport_configuration_proc
  def deprecated_for_removal_transport_configuration_proc; end

  # Sets the attribute deprecated_for_removal_transport_configuration_proc
  #
  # @param value [Object] the value to set the attribute deprecated_for_removal_transport_configuration_proc to.
  # @return [Object] the newly set value
  def deprecated_for_removal_transport_configuration_proc=(_); end

  # Returns the value of attribute hostname
  #
  # @return [Object] the current value of hostname
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value [Object] the value to set the attribute hostname to.
  # @return [Object] the newly set value
  def hostname=(_); end

  # Returns a frozen copy of this struct
  # with the provided +member_values+ modified.
  #
  # TODO: This is only used when configuring profiling, and can be removed once
  # https://github.com/DataDog/dd-trace-rb/pull/1924 is merged
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#58
  def merge(**member_values); end

  # Returns the value of attribute port
  #
  # @return [Object] the current value of port
  def port; end

  # Sets the attribute port
  #
  # @param value [Object] the value to set the attribute port to.
  # @return [Object] the newly set value
  def port=(_); end

  # Returns the value of attribute ssl
  #
  # @return [Object] the current value of ssl
  def ssl; end

  # Sets the attribute ssl
  #
  # @param value [Object] the value to set the attribute ssl to.
  # @return [Object] the newly set value
  def ssl=(_); end

  # Returns the value of attribute timeout_seconds
  #
  # @return [Object] the current value of timeout_seconds
  def timeout_seconds; end

  # Sets the attribute timeout_seconds
  #
  # @param value [Object] the value to set the attribute timeout_seconds to.
  # @return [Object] the newly set value
  def timeout_seconds=(_); end

  # Returns the value of attribute uds_path
  #
  # @return [Object] the current value of uds_path
  def uds_path; end

  # Sets the attribute uds_path
  #
  # @param value [Object] the value to set the attribute uds_path to.
  # @return [Object] the newly set value
  def uds_path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Represents a given configuration value and where we got it from
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#318
class Datadog::Core::Configuration::AgentSettingsResolver::DetectedConfiguration
  # @return [DetectedConfiguration] a new instance of DetectedConfiguration
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#321
  def initialize(friendly_name:, value:); end

  # Returns the value of attribute friendly_name.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#319
  def friendly_name; end

  # Returns the value of attribute value.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#319
  def value; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#327
  def value?; end
end

# Used to contain information extracted from the transport_options proc (see #transport_options above)
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#334
class Datadog::Core::Configuration::AgentSettingsResolver::TransportOptions < ::Struct
  # Returns the value of attribute adapter
  #
  # @return [Object] the current value of adapter
  def adapter; end

  # Sets the attribute adapter
  #
  # @param value [Object] the value to set the attribute adapter to.
  # @return [Object] the newly set value
  def adapter=(_); end

  # Returns the value of attribute hostname
  #
  # @return [Object] the current value of hostname
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value [Object] the value to set the attribute hostname to.
  # @return [Object] the newly set value
  def hostname=(_); end

  # Returns the value of attribute port
  #
  # @return [Object] the current value of port
  def port; end

  # Sets the attribute port
  #
  # @param value [Object] the value to set the attribute port to.
  # @return [Object] the newly set value
  def port=(_); end

  # Returns the value of attribute ssl
  #
  # @return [Object] the current value of ssl
  def ssl; end

  # Sets the attribute ssl
  #
  # @param value [Object] the value to set the attribute ssl to.
  # @return [Object] the newly set value
  def ssl=(_); end

  # Returns the value of attribute timeout_seconds
  #
  # @return [Object] the current value of timeout_seconds
  def timeout_seconds; end

  # Sets the attribute timeout_seconds
  #
  # @param value [Object] the value to set the attribute timeout_seconds to.
  # @return [Object] the newly set value
  def timeout_seconds=(_); end

  # Returns the value of attribute uds_path
  #
  # @return [Object] the current value of uds_path
  def uds_path; end

  # Sets the attribute uds_path
  #
  # @param value [Object] the value to set the attribute uds_path to.
  # @return [Object] the newly set value
  def uds_path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Used to extract information from the transport_options proc (see #transport_options above)
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#338
class Datadog::Core::Configuration::AgentSettingsResolver::TransportOptionsResolver
  # @return [TransportOptionsResolver] a new instance of TransportOptionsResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#339
  def initialize(transport_options); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#343
  def adapter(kind_or_custom_adapter, *args, **kwargs); end
end

# Basic configuration behavior
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#11
module Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Base::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Environment::VariableHelpers
  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods
  mixes_in_class_methods ::Datadog::Core::Configuration::Base::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/configuration/base.rb#12
    def included(base); end
  end
end

# Class methods for configuration
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#23
module Datadog::Core::Configuration::Base::ClassMethods
  protected

  # Allows subgroupings of settings to be defined.
  # e.g. `settings :foo { option :bar }` --> `config.foo.bar`
  #
  # @param name [Symbol] option name. Methods will be created based on this name.
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#29
  def settings(name, &block); end

  private

  # source://ddtrace//lib/datadog/core/configuration/base.rb#47
  def new_settings_class(&block); end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#56
module Datadog::Core::Configuration::Base::InstanceMethods
  # source://ddtrace//lib/datadog/core/configuration/base.rb#57
  def initialize(options = T.unsafe(nil)); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::Base::InstanceMethods] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#61
  def configure(opts = T.unsafe(nil)); end

  # Retrieves a nested option from a list of symbols
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#86
  def dig(*options); end

  # source://ddtrace//lib/datadog/core/configuration/base.rb#94
  def reset!; end

  # source://ddtrace//lib/datadog/core/configuration/base.rb#81
  def to_h; end
end

# We use a separate lock when reading the @components, so that they continue to be accessible during reconfiguration.
# This was needed because we ran into several issues where we still needed to read the old
# components while the COMPONENTS_WRITE_LOCK was being held (see https://github.com/DataDog/dd-trace-rb/pull/1387
# and https://github.com/DataDog/dd-trace-rb/pull/1373#issuecomment-799593022 ).
#
# Technically on MRI we could get away without this lock, but on non-MRI Rubies, we may run into issues because
# we fall into the "UnsafeDCLFactory" case of https://shipilev.net/blog/2014/safe-public-construction/ .
# Specifically, on JRuby reads from the @components do NOT have volatile semantics, and on TruffleRuby they do
# BUT just as an implementation detail, see https://github.com/jruby/jruby/wiki/Concurrency-in-jruby#volatility and
# https://github.com/DataDog/dd-trace-rb/pull/1329#issuecomment-776750377 .
# Concurrency is hard.
#
# source://ddtrace//lib/datadog/core/configuration.rb#39
Datadog::Core::Configuration::COMPONENTS_READ_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Used to ensure that @components initialization/reconfiguration is performed one-at-a-time, by a single thread.
#
# This is important because components can end up being accessed from multiple application threads (for instance on
# a threaded webserver), and we don't want their initialization to clash (for instance, starting two profilers...).
#
# Note that a Mutex **IS NOT** reentrant: the same thread cannot grab the same Mutex more than once.
# This means below we are careful not to nest calls to methods that would trigger initialization and grab the lock.
#
# Every method that directly or indirectly mutates @components should be holding the lock (through
# #safely_synchronize) while doing so.
#
# source://ddtrace//lib/datadog/core/configuration.rb#25
Datadog::Core::Configuration::COMPONENTS_WRITE_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Global components for the trace library.
#
# source://ddtrace//lib/datadog/core/configuration/components.rb#21
class Datadog::Core::Configuration::Components
  include ::Datadog::CI::Configuration::Components

  # @return [Components] a new instance of Components
  #
  # source://ddtrace//lib/datadog/ci/configuration/components.rb#10
  def initialize(settings); end

  # Returns the value of attribute health_metrics.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def health_metrics; end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def logger; end

  # Returns the value of attribute profiler.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def profiler; end

  # Returns the value of attribute runtime_metrics.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def runtime_metrics; end

  # Shuts down all the components in use.
  # If it has another instance to compare to, it will compare
  # and avoid tearing down parts still in use.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#420
  def shutdown!(replacement = T.unsafe(nil)); end

  # Starts up components
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#402
  def startup!(settings); end

  # Returns the value of attribute telemetry.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def telemetry; end

  # Returns the value of attribute tracer.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#371
  def tracer; end

  class << self
    # source://ddtrace//lib/datadog/core/configuration/components.rb#23
    def build_health_metrics(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#31
    def build_logger(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#193
    def build_profiler(settings, agent_settings, tracer); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#38
    def build_runtime_metrics(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#46
    def build_runtime_metrics_worker(settings); end

    # TODO: Sampler should be a top-level component.
    # It is currently part of the Tracer initialization
    # process, but can take a variety of options (including
    # a fully custom instance) that makes the Tracer
    # initialization process complex.
    #
    # source://ddtrace//lib/datadog/core/configuration/components.rb#105
    def build_sampler(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#188
    def build_span_sampler(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#56
    def build_telemetry(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#90
    def build_trace_flush(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#60
    def build_tracer(settings, agent_settings); end

    # TODO: Writer should be a top-level component.
    # It is currently part of the Tracer initialization
    # process, but can take a variety of options (including
    # a fully custom instance) that makes the Tracer
    # initialization process complex.
    #
    # source://ddtrace//lib/datadog/core/configuration/components.rb#147
    def build_writer(settings, agent_settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#128
    def ensure_priority_sampling(sampler, settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#155
    def subscribe_to_writer_events!(writer, sampler, test_mode); end

    # Create new lambda for writer callback,
    # capture the current sampler in the callback closure.
    #
    # source://ddtrace//lib/datadog/core/configuration/components.rb#178
    def writer_update_priority_sampler_rates_callback(sampler); end

    private

    # source://ddtrace//lib/datadog/core/configuration/components.rb#310
    def build_profiler_exporter(settings, recorder); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#306
    def build_profiler_old_recorder(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#317
    def build_profiler_oldstack_collector(settings, old_recorder, trace_identifiers_helper); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#325
    def build_profiler_transport(settings, agent_settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#291
    def build_test_mode_sampler; end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#286
    def build_test_mode_trace_flush(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#300
    def build_test_mode_writer(settings, agent_settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#279
    def build_tracer_tags(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#351
    def print_new_profiler_warnings; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/configuration/components.rb#335
    def should_enable_gc_profiling?(settings); end
  end
end

# Resolver performs a topological sort over the dependency graph
#
# source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#9
class Datadog::Core::Configuration::DependencyResolver
  include ::TSort

  # @return [DependencyResolver] a new instance of DependencyResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#12
  def initialize(dependency_graph = T.unsafe(nil)); end

  # source://tsort/0.1.1/tsort.rb#149
  def call; end

  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#20
  def tsort_each_child(node, &blk); end

  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#16
  def tsort_each_node(&blk); end
end

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://ddtrace//lib/datadog/core/configuration/ext.rb#8
module Datadog::Core::Configuration::Ext; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#10
module Datadog::Core::Configuration::Ext::Diagnostics; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#11
Datadog::Core::Configuration::Ext::Diagnostics::ENV_DEBUG_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#12
Datadog::Core::Configuration::Ext::Diagnostics::ENV_HEALTH_METRICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#13
Datadog::Core::Configuration::Ext::Diagnostics::ENV_STARTUP_LOGS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#16
module Datadog::Core::Configuration::Ext::Metrics; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#17
Datadog::Core::Configuration::Ext::Metrics::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#20
module Datadog::Core::Configuration::Ext::Transport; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#21
Datadog::Core::Configuration::Ext::Transport::ENV_DEFAULT_HOST = T.let(T.unsafe(nil), String)

# Represents an instance of an integration configuration option
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#8
class Datadog::Core::Configuration::Option
  # @return [Option] a new instance of Option
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#12
  def initialize(definition, context); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#49
  def default_value; end

  # Returns the value of attribute definition.
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#9
  def definition; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#27
  def get; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#37
  def reset; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#19
  def set(value); end

  private

  # source://ddtrace//lib/datadog/core/configuration/option.rb#63
  def context_eval(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#59
  def context_exec(*args, &block); end
end

# Represents a definition for an integration configuration option
#
# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#9
class Datadog::Core::Configuration::OptionDefinition
  # @return [OptionDefinition] a new instance of OptionDefinition
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#23
  def initialize(name, meta = T.unsafe(nil), &block); end

  # Creates a new Option, bound to the context provided.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#36
  def build(context); end

  # Returns the value of attribute default.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def default; end

  # Returns the value of attribute delegate_to.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def delegate_to; end

  # Returns the value of attribute depends_on.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def depends_on; end

  # Returns the value of attribute lazy.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def lazy; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def name; end

  # Returns the value of attribute on_set.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def on_set; end

  # Returns the value of attribute resetter.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def resetter; end

  # Returns the value of attribute setter.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def setter; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def type; end
end

# Acts as DSL for building OptionDefinitions
#
# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#42
class Datadog::Core::Configuration::OptionDefinition::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::OptionDefinition::Builder] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#46
  def initialize(name, options = T.unsafe(nil)); end

  # For applying options for OptionDefinition
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#102
  def apply_options!(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#69
  def default(value = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#73
  def delegate_to(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#65
  def depends_on(*values); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#77
  def helper(name, *_args, &block); end

  # Returns the value of attribute helpers.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#43
  def helpers; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#81
  def lazy(value = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#119
  def meta; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#85
  def on_set(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#89
  def resetter(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#93
  def setter(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#115
  def to_definition; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#97
  def type(value = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#10
Datadog::Core::Configuration::OptionDefinition::IDENTITY = T.let(T.unsafe(nil), Proc)

# Represents a set of configuration option definitions for an integration
#
# source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#9
class Datadog::Core::Configuration::OptionDefinitionSet < ::Hash
  # source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#14
  def dependency_graph; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#10
  def dependency_order; end
end

# source://ddtrace//lib/datadog/core/configuration/option_set.rb#6
class Datadog::Core::Configuration::OptionSet < ::Hash; end

# Behavior for a configuration object that has options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#12
module Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/configuration/options.rb#13
    def included(base); end
  end
end

# Class behavior for a configuration object with options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#20
module Datadog::Core::Configuration::Options::ClassMethods
  # source://ddtrace//lib/datadog/core/configuration/options.rb#21
  def options; end

  protected

  # source://ddtrace//lib/datadog/core/configuration/options.rb#28
  def option(name, meta = T.unsafe(nil), &block); end

  private

  # source://ddtrace//lib/datadog/core/configuration/options.rb#41
  def default_helpers(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#54
  def define_helpers(helpers); end
end

# Instance behavior for a configuration object with options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#65
module Datadog::Core::Configuration::Options::InstanceMethods
  # source://ddtrace//lib/datadog/core/configuration/options.rb#75
  def get_option(name); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#85
  def option_defined?(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#66
  def options; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#89
  def options_hash; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#80
  def reset_option(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#95
  def reset_options!; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#70
  def set_option(name, value); end

  private

  # source://ddtrace//lib/datadog/core/configuration/options.rb#101
  def add_option(name); end

  # @raise [InvalidOptionError]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#109
  def assert_valid_option!(name); end
end

# source://ddtrace//lib/datadog/core/configuration/options.rb#114
class Datadog::Core::Configuration::Options::InvalidOptionError < ::StandardError; end

# Global configuration settings for the Datadog library.
#
# source://ddtrace//lib/datadog/core/configuration/settings.rb#20
class Datadog::Core::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods
  extend ::Datadog::Tracing::Configuration::Settings
  extend ::Datadog::CI::Configuration::Settings

  # @return [Settings] a new instance of Settings
  #
  # source://ddtrace//lib/datadog/core/configuration/settings.rb#24
  def initialize(*_); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def agent; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def agent=(value); end

  # Datadog API key.
  #
  # For internal use only.
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def api_key; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def api_key=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def ci; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def ci=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def diagnostics; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def diagnostics=(value); end

  # The `env` tag in Datadog. Use it to separate out your staging, development, and production environments.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def env; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def env=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def logger; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def logger=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def profiling; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def profiling=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def runtime_metrics; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def runtime_metrics=(value); end

  # The `service` tag in Datadog. Use it to group related traces into a service.
  #
  # @return [String]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/settings.rb#322
  def service_without_fallback; end

  # The Datadog site host to send data to.
  # By default, data is sent to the Datadog US site: `app.datadoghq.com`.
  #
  # If your organization is on another site, you must update this value to the new site.
  #
  # For internal use only.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/agent/troubleshooting/site/
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def site; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def site=(value); end

  # Default tags
  #
  # These tags are used by all Datadog products, when applicable.
  # e.g. trace spans, profiles, etc.
  #
  # @return [Hash<String,String>]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tags; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tags=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def telemetry; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def telemetry=(value); end

  # The time provider used by Datadog. It must respect the interface of [Time](https://ruby-doc.org/core-3.0.1/Time.html).
  #
  # When testing, it can be helpful to use a different time provider.
  #
  # For [Timecop](https://rubygems.org/gems/timecop), for example, `->{ Time.now_without_mock_time }`
  # allows Datadog features to use the real wall time when time is frozen.
  #
  # @return [Proc<Time>]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def time_now_provider; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def time_now_provider=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tracing=(value); end

  # The `version` tag in Datadog. Use it to enable [Deployment Tracking](https://docs.datadoghq.com/tracing/deployment_tracking/).
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def version; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def version=(value); end
end

# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#9
module Datadog::Core::Diagnostics; end

# Collects environment information for diagnostic logging
#
# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#60
class Datadog::Core::Diagnostics::EnvironmentCollector
  # Error returned by Datadog agent during a tracer flush attempt
  #
  # @return [String] concatenated list of transport errors
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#123
  def agent_error(transport_responses); end

  # @return [String, nil] target agent URL for trace flushing
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#110
  def agent_url; end

  # @return [Boolean, nil] analytics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#137
  def analytics_enabled; end

  # @return [Hash] environment information available at call time
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#233
  def collect!(transport_responses); end

  # @return [String] current time in ISO8601 format
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#62
  def date; end

  # @return [String] configured application version
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#105
  def dd_version; end

  # @return [Boolean, nil] debug mode enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#132
  def debug; end

  # @return [Boolean, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#95
  def enabled; end

  # @return [String] configured application environment
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#90
  def env; end

  # @return [Boolean, nil] health metrics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#220
  def health_metrics_enabled; end

  # Concatenated list of integrations activated, with their gem version.
  # Example: "rails@6.0.3,rack@2.2.3"
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#188
  def integrations_loaded; end

  # @return [String] "ruby"
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#78
  def lang; end

  # Supported Ruby language version.
  # Will be distinct from VM version for non-MRI environments.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#85
  def lang_version; end

  # Best portable guess of OS information.
  #
  # @return [String] platform string
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#68
  def os_name; end

  # @return [Boolean, nil] partial flushing enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#210
  def partial_flushing_enabled; end

  # @return [Boolean, nil] priority sampling enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#215
  def priority_sampling_enabled; end

  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#224
  def profiling_enabled; end

  # @return [Boolean, nil] runtime metrics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#180
  def runtime_metrics_enabled; end

  # @return [Numeric, nil] tracer sample rate configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#142
  def sample_rate; end

  # DEV: We currently only support SimpleRule instances.
  # DEV: These are the most commonly used rules.
  # DEV: We should expand support for other rules in the future,
  # DEV: although it is tricky to serialize arbitrary rules.
  #
  # @return [Hash, nil] sample rules configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#155
  def sampling_rules; end

  # @return [String] configured application service name
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#100
  def service; end

  # @return [Hash, nil] concatenated list of global tracer tags configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#172
  def tags; end

  # @return [String] ddtrace version
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#73
  def version; end

  # Ruby VM name and version.
  # Examples: "ruby-2.7.1", "jruby-9.2.11.1", "truffleruby-20.1.0"
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#198
  def vm; end

  private

  # Outputs "k1:v1,k2:v2,..."
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#282
  def hash_serializer(h); end

  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#264
  def instrumented_integrations; end

  # Capture all active integration settings into "integrationName_settingName: value" entries.
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#269
  def instrumented_integrations_settings; end
end

# A holistic collection of the environment in which ddtrace is running.
# This logger should allow for easy reporting by users to Datadog support.
#
# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#13
module Datadog::Core::Diagnostics::EnvironmentLogger
  class << self
    # Outputs environment information to {Datadog.logger}.
    # Executes only once for the lifetime of the program.
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#17
    def log!(transport_responses); end

    private

    # Are we logging the environment data?
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#42
    def log?; end

    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#33
    def log_environment!(line); end

    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#37
    def log_error!(type, error); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#53
    def repl?; end
  end
end

# Health-related diagnostics
#
# source://ddtrace//lib/datadog/core/diagnostics/health.rb#10
module Datadog::Core::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://ddtrace//lib/datadog/core/diagnostics/health.rb#12
class Datadog::Core::Diagnostics::Health::Metrics < ::Datadog::Core::Metrics::Client
  extend ::Datadog::Tracing::Diagnostics::Health::Metrics

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_errors(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_requests(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_responses(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_context_overflow(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_instrumentation_patch(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_span_finish(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_unfinished_spans(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def instrumentation_patched(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_accepted(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_accepted_lengths(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_dropped(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_max_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_spans(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def sampling_service_cache_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def traces_filtered(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def transport_chunked(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def transport_trace_too_large(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def writer_cpu_time(*args, &block); end
end

# Encoding module that encodes data for the AgentTransport
#
# source://ddtrace//lib/datadog/core/encoding.rb#9
module Datadog::Core::Encoding; end

# Encoder interface that provides the logic to encode traces and service
#
# @abstract
#
# source://ddtrace//lib/datadog/core/encoding.rb#12
module Datadog::Core::Encoding::Encoder
  include ::Kernel

  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#15
  def content_type; end

  # Serializes a single trace into a String suitable for network transmission.
  #
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#25
  def encode(_); end

  # Concatenates a list of elements previously encoded by +#encode+.
  #
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#20
  def join(encoded_elements); end
end

# Encoder for the JSON format
#
# source://ddtrace//lib/datadog/core/encoding.rb#31
module Datadog::Core::Encoding::JSONEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://ddtrace//lib/datadog/core/encoding.rb#38
  def content_type; end

  # source://ddtrace//lib/datadog/core/encoding.rb#42
  def encode(obj); end

  # source://ddtrace//lib/datadog/core/encoding.rb#46
  def join(encoded_data); end

  class << self
    # source://ddtrace//lib/datadog/core/encoding.rb#38
    def content_type; end

    # source://ddtrace//lib/datadog/core/encoding.rb#42
    def encode(obj); end

    # source://ddtrace//lib/datadog/core/encoding.rb#46
    def join(encoded_data); end
  end
end

# source://ddtrace//lib/datadog/core/encoding.rb#34
Datadog::Core::Encoding::JSONEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Encoder for the Msgpack format
#
# source://ddtrace//lib/datadog/core/encoding.rb#52
module Datadog::Core::Encoding::MsgpackEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://ddtrace//lib/datadog/core/encoding.rb#59
  def content_type; end

  # source://ddtrace//lib/datadog/core/encoding.rb#63
  def encode(obj); end

  # source://ddtrace//lib/datadog/core/encoding.rb#67
  def join(encoded_data); end

  class << self
    # source://ddtrace//lib/datadog/core/encoding.rb#59
    def content_type; end

    # source://ddtrace//lib/datadog/core/encoding.rb#63
    def encode(obj); end

    # source://ddtrace//lib/datadog/core/encoding.rb#67
    def join(encoded_data); end
  end
end

# source://ddtrace//lib/datadog/core/encoding.rb#57
Datadog::Core::Encoding::MsgpackEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Namespace for handling application environment
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#6
module Datadog::Core::Environment; end

# Reads information from Linux cgroups.
# This information is used to extract information
# about the current Linux container identity.
#
# @see https://man7.org/linux/man-pages/man7/cgroups.7.html
#
# source://ddtrace//lib/datadog/core/environment/cgroup.rb#12
module Datadog::Core::Environment::Cgroup
  include ::Kernel

  private

  # source://ddtrace//lib/datadog/core/environment/cgroup.rb#26
  def descriptors(process = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/environment/cgroup.rb#45
  def parse(line); end

  class << self
    # source://ddtrace//lib/datadog/core/environment/cgroup.rb#26
    def descriptors(process = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/environment/cgroup.rb#45
    def parse(line); end
  end
end

# source://ddtrace//lib/datadog/core/environment/cgroup.rb#17
class Datadog::Core::Environment::Cgroup::Descriptor < ::Struct
  # Returns the value of attribute controllers
  #
  # @return [Object] the current value of controllers
  def controllers; end

  # Sets the attribute controllers
  #
  # @param value [Object] the value to set the attribute controllers to.
  # @return [Object] the newly set value
  def controllers=(_); end

  # Returns the value of attribute groups
  #
  # @return [Object] the current value of groups
  def groups; end

  # Sets the attribute groups
  #
  # @param value [Object] the value to set the attribute groups to.
  # @return [Object] the newly set value
  def groups=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/environment/cgroup.rb#15
Datadog::Core::Environment::Cgroup::LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# Retrieves number of classes from runtime
#
# source://ddtrace//lib/datadog/core/environment/class_count.rb#7
module Datadog::Core::Environment::ClassCount
  private

  # source://ddtrace//lib/datadog/core/environment/class_count.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/class_count.rb#10
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/class_count.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/class_count.rb#10
    def value; end
  end
end

# For container environments
#
# source://ddtrace//lib/datadog/core/environment/container.rb#9
module Datadog::Core::Environment::Container
  include ::Kernel

  private

  # source://ddtrace//lib/datadog/core/environment/container.rb#32
  def container_id; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#40
  def descriptor; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#28
  def platform; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#36
  def task_uid; end

  class << self
    # source://ddtrace//lib/datadog/core/environment/container.rb#32
    def container_id; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#40
    def descriptor; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#28
    def platform; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#36
    def task_uid; end
  end
end

# source://ddtrace//lib/datadog/core/environment/container.rb#13
Datadog::Core::Environment::Container::CONTAINER_PATTERN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/container.rb#17
Datadog::Core::Environment::Container::CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#20
class Datadog::Core::Environment::Container::Descriptor < ::Struct
  # Returns the value of attribute container_id
  #
  # @return [Object] the current value of container_id
  def container_id; end

  # Sets the attribute container_id
  #
  # @param value [Object] the value to set the attribute container_id to.
  # @return [Object] the newly set value
  def container_id=(_); end

  # Returns the value of attribute platform
  #
  # @return [Object] the current value of platform
  def platform; end

  # Sets the attribute platform
  #
  # @param value [Object] the value to set the attribute platform to.
  # @return [Object] the newly set value
  def platform=(_); end

  # Returns the value of attribute task_uid
  #
  # @return [Object] the current value of task_uid
  def task_uid; end

  # Sets the attribute task_uid
  #
  # @param value [Object] the value to set the attribute task_uid to.
  # @return [Object] the newly set value
  def task_uid=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/environment/container.rb#18
Datadog::Core::Environment::Container::FARGATE_14_CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#15
Datadog::Core::Environment::Container::PLATFORM_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#16
Datadog::Core::Environment::Container::POD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#12
Datadog::Core::Environment::Container::UUID_PATTERN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#9
module Datadog::Core::Environment::Ext; end

# e.g for CRuby '3.0.1', for JRuby '9.2.19.0', for TruffleRuby '21.1.0'
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#11
Datadog::Core::Environment::Ext::ENGINE_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#18
Datadog::Core::Environment::Ext::ENV_API_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#19
Datadog::Core::Environment::Ext::ENV_ENVIRONMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#20
Datadog::Core::Environment::Ext::ENV_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#21
Datadog::Core::Environment::Ext::ENV_SITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#22
Datadog::Core::Environment::Ext::ENV_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#23
Datadog::Core::Environment::Ext::ENV_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#24
Datadog::Core::Environment::Ext::FALLBACK_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#31
Datadog::Core::Environment::Ext::LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#32
Datadog::Core::Environment::Ext::LANG_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#33
Datadog::Core::Environment::Ext::LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#34
Datadog::Core::Environment::Ext::LANG_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#35
Datadog::Core::Environment::Ext::LANG_VERSION = T.let(T.unsafe(nil), String)

# e.g. 'ruby', 'jruby', 'truffleruby'
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#36
Datadog::Core::Environment::Ext::RUBY_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#37
Datadog::Core::Environment::Ext::TAG_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#38
Datadog::Core::Environment::Ext::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#39
Datadog::Core::Environment::Ext::TAG_VERSION = T.let(T.unsafe(nil), String)

# TODO: Migrate to Datadog::Tracing
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#42
Datadog::Core::Environment::Ext::TRACER_VERSION = T.let(T.unsafe(nil), String)

# Retrieves garbage collection statistics
#
# source://ddtrace//lib/datadog/core/environment/gc.rb#7
module Datadog::Core::Environment::GC
  private

  # source://ddtrace//lib/datadog/core/environment/gc.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/gc.rb#10
  def stat; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/gc.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/gc.rb#10
    def stat; end
  end
end

# For runtime identity
#
# source://ddtrace//lib/datadog/core/environment/identity.rb#13
module Datadog::Core::Environment::Identity
  extend ::Datadog::Core::Utils::Forking

  private

  # Retrieves number of classes from runtime
  #
  # source://ddtrace//lib/datadog/core/environment/identity.rb#19
  def id; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#32
  def lang; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#36
  def lang_engine; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#40
  def lang_interpreter; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#44
  def lang_platform; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#48
  def lang_version; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#28
  def pid; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#52
  def tracer_version; end

  class << self
    # Retrieves number of classes from runtime
    #
    # source://ddtrace//lib/datadog/core/environment/identity.rb#19
    def id; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#32
    def lang; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#36
    def lang_engine; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#40
    def lang_interpreter; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#44
    def lang_platform; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#48
    def lang_version; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#28
    def pid; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#52
    def tracer_version; end
  end
end

# For gathering information about the platform
#
# source://ddtrace//lib/datadog/core/environment/platform.rb#11
module Datadog::Core::Environment::Platform
  private

  # @return [String] name of host; `uname -n`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#15
  def hostname; end

  # @return [String] name of kernel; `uname -s`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#20
  def kernel_name; end

  # @return [String] kernel release; `uname -r`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#25
  def kernel_release; end

  # @return [String] kernel version; `uname -v`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#34
  def kernel_version; end

  class << self
    # @return [String] name of host; `uname -n`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#15
    def hostname; end

    # @return [String] name of kernel; `uname -s`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#20
    def kernel_name; end

    # @return [String] kernel release; `uname -r`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#25
    def kernel_release; end

    # @return [String] kernel version; `uname -v`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#34
    def kernel_version; end
  end
end

# For runtime identity
#
# source://ddtrace//lib/datadog/core/environment/socket.rb#10
module Datadog::Core::Environment::Socket
  extend ::Datadog::Core::Utils::Forking

  private

  # source://ddtrace//lib/datadog/core/environment/socket.rb#15
  def hostname; end

  class << self
    # source://ddtrace//lib/datadog/core/environment/socket.rb#15
    def hostname; end
  end
end

# Retrieves number of threads from runtime
#
# source://ddtrace//lib/datadog/core/environment/thread_count.rb#7
module Datadog::Core::Environment::ThreadCount
  private

  # source://ddtrace//lib/datadog/core/environment/thread_count.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/thread_count.rb#10
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/thread_count.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/thread_count.rb#10
    def value; end
  end
end

# Reports Ruby VM cache performance statistics.
# This currently encompasses cache invalidation counters and is CRuby-specific.
#
# JRuby emulates some CRuby global cache statistics, but they are synthetic and don't
# provide actionable performance information in the same way CRuby does.
# TruffleRuby does not have a global runtime cache invalidation cache.
#
# @see https://github.com/jruby/jruby/issues/4384#issuecomment-267069314
# @see http://archive.today/2021.09.10-205702/https://medium.com/graalvm/precise-method-and-constant-invalidation-in-truffleruby-4dd56c6bac1a
#
# source://ddtrace//lib/datadog/core/environment/vm_cache.rb#15
module Datadog::Core::Environment::VMCache
  private

  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#41
  def available?; end

  # Global constant cache "generation" counter.
  #
  # Whenever a constant creation busts the global constant cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#23
  def global_constant_state; end

  # Global method cache "generation" counter.
  #
  # Whenever a method creation busts the global method cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # Since Ruby 3.0, the method class is kept on a per-class basis,
  # largely mitigating global method cache busting. `global_method_state`
  # is thus not available since Ruby 3.0.
  #
  # @see https://bugs.ruby-lang.org/issues/16614
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#37
  def global_method_state; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#41
    def available?; end

    # Global constant cache "generation" counter.
    #
    # Whenever a constant creation busts the global constant cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#23
    def global_constant_state; end

    # Global method cache "generation" counter.
    #
    # Whenever a method creation busts the global method cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # Since Ruby 3.0, the method class is kept on a per-class basis,
    # largely mitigating global method cache busting. `global_method_state`
    # is thus not available since Ruby 3.0.
    #
    # @see https://bugs.ruby-lang.org/issues/16614
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#37
    def global_method_state; end
  end
end

# Defines helper methods for environment
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#9
module Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Environment::VariableHelpers

  # Reads an environment variable as a Boolean.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Boolean] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Boolean] if the environment value is the string `true`
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#21
  def env_to_bool(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Reads an environment variable as a Float.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Float] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Float] if the environment value is a valid Float
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#49
  def env_to_float(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Reads an environment variable as an Integer.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Integer] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Integer] if the environment value is a valid Integer
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#35
  def env_to_int(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Parses comma- or space-separated lists.
  #
  # If a comma is present, then the list is considered comma-separated.
  # Otherwise, it is considered space-separated.
  #
  # After the entries are separated, commas and whitespaces that are
  # either trailing or leading are trimmed.
  #
  # Empty entries, after trimmed, are also removed from the result.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Array<Object>] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Array<Object>] if the environment value is a valid list
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#71
  def env_to_list(var, default = T.unsafe(nil), comma_separated_only:, deprecation_warning: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#97
  def decode_array(var, deprecation_warning); end
end

# Error is a value-object responsible for sanitizing/encapsulating error data
#
# source://ddtrace//lib/datadog/core/error.rb#10
class Datadog::Core::Error
  # @return [Error] a new instance of Error
  #
  # source://ddtrace//lib/datadog/core/error.rb#89
  def initialize(type = T.unsafe(nil), message = T.unsafe(nil), backtrace = T.unsafe(nil)); end

  # Returns the value of attribute backtrace.
  #
  # source://ddtrace//lib/datadog/core/error.rb#11
  def backtrace; end

  # Returns the value of attribute message.
  #
  # source://ddtrace//lib/datadog/core/error.rb#11
  def message; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/error.rb#11
  def type; end

  class << self
    # source://ddtrace//lib/datadog/core/error.rb#14
    def build_from(value); end

    private

    # Outputs the following format for exceptions:
    #
    # ```
    # error_spec.rb:55:in `wrapper': wrapper layer (RuntimeError)
    # 	from error_spec.rb:40:in `wrapper'
    # 	from error_spec.rb:61:in `caller'
    #   ...
    # ```
    #
    # source://ddtrace//lib/datadog/core/error.rb#62
    def backtrace_for(ex, backtrace); end

    # Returns a stack trace with nested error causes and details.
    #
    # This manually implements Ruby >= 2.6 error output for two reasons:
    #
    # 1. It is not available in Ruby < 2.6.
    # 2. It's measurably faster to manually implement it in Ruby.
    #
    # This method mimics the exact output of
    # `ex.full_message(highlight: false, order: :top)`
    # but it's around 3x faster in our benchmark test
    # at `error_spec.rb`.
    #
    # source://ddtrace//lib/datadog/core/error.rb#37
    def full_backtrace(ex); end
  end
end

# source://ddtrace//lib/datadog/core/error.rb#97
Datadog::Core::Error::BlankError = T.let(T.unsafe(nil), Datadog::Core::Error)

# source://ddtrace//lib/datadog/core/error.rb#98
Datadog::Core::Error::ContainsMessage = T.let(T.unsafe(nil), Proc)

# Used to decorate Datadog module with additional behavior
#
# source://ddtrace//lib/datadog/core/extensions.rb#10
module Datadog::Core::Extensions
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/extensions.rb#11
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/core/git/ext.rb#5
module Datadog::Core::Git; end

# Defines constants for Git tags
#
# source://ddtrace//lib/datadog/core/git/ext.rb#7
module Datadog::Core::Git::Ext; end

# source://ddtrace//lib/datadog/core/git/ext.rb#23
Datadog::Core::Git::Ext::ENV_BRANCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#28
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#27
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#26
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#31
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#30
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#29
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#25
Datadog::Core::Git::Ext::ENV_COMMIT_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#22
Datadog::Core::Git::Ext::ENV_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#21
Datadog::Core::Git::Ext::ENV_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#24
Datadog::Core::Git::Ext::ENV_TAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#8
Datadog::Core::Git::Ext::TAG_BRANCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#12
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#13
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#14
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#15
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#16
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#17
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#18
Datadog::Core::Git::Ext::TAG_COMMIT_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#19
Datadog::Core::Git::Ext::TAG_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#9
Datadog::Core::Git::Ext::TAG_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#10
Datadog::Core::Git::Ext::TAG_TAG = T.let(T.unsafe(nil), String)

# A header collection implementation that looks up headers in a Hash.
#
# source://ddtrace//lib/datadog/core/header_collection.rb#28
class Datadog::Core::HashHeaderCollection < ::Datadog::Core::HeaderCollection
  # @return [HashHeaderCollection] a new instance of HashHeaderCollection
  #
  # source://ddtrace//lib/datadog/core/header_collection.rb#29
  def initialize(hash); end

  # source://ddtrace//lib/datadog/core/header_collection.rb#36
  def get(header_name); end
end

# A some-what abstract class representing a collection of headers.
#
# Use the `HeaderCollection.from_hash` function to create a header collection from a `Hash`.
# Another option is to use `HashHeaderCollection` directly.
#
# source://ddtrace//lib/datadog/core/header_collection.rb#7
class Datadog::Core::HeaderCollection
  # Gets a single value of the header with the given name, case insensitive.
  #
  # @param header_name [String] Name of the header to get the value of.
  #
  # source://ddtrace//lib/datadog/core/header_collection.rb#13
  def get(header_name); end

  class << self
    # Create a header collection that retrieves headers from the given Hash.
    #
    # This can be useful for testing or other trivial use cases.
    #
    # @param hash [Hash] Hash with the headers.
    #
    # source://ddtrace//lib/datadog/core/header_collection.rb#22
    def from_hash(hash); end
  end
end

# A custom logger with minor enhancements:
# - progname defaults to ddtrace to clearly identify Datadog dd-trace-rb related messages
# - adds last caller stack-trace info to know where the message comes from
#
# source://ddtrace//lib/datadog/core/logger.rb#11
class Datadog::Core::Logger < ::Logger
  # @return [Logger] a new instance of Logger
  #
  # source://ddtrace//lib/datadog/core/logger.rb#15
  def initialize(*args, &block); end

  # source://ddtrace//lib/datadog/core/logger.rb#21
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/logger.rb#21
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# TODO: Consider renaming this to 'datadog'
#
# source://ddtrace//lib/datadog/core/logger.rb#13
Datadog::Core::Logger::PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/logging/ext.rb#3
module Datadog::Core::Logging; end

# source://ddtrace//lib/datadog/core/logging/ext.rb#4
module Datadog::Core::Logging::Ext; end

# The technology from which the log originated.
#
# @see https://docs.datadoghq.com/api/latest/logs/#send-logs
#
# source://ddtrace//lib/datadog/core/logging/ext.rb#7
Datadog::Core::Logging::Ext::DD_SOURCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#5
module Datadog::Core::Metrics; end

# Acts as client for sending metrics (via Statsd)
# Wraps a Statsd client with default tags and additional configuration.
#
# source://ddtrace//lib/datadog/core/metrics/client.rb#18
class Datadog::Core::Metrics::Client
  include ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Helpers

  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#25
  def initialize(statsd: T.unsafe(nil), enabled: T.unsafe(nil), **_); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#166
  def close; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#83
  def configure(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#92
  def count(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#53
  def default_hostname; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#57
  def default_port; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#61
  def default_statsd_client; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#105
  def distribution(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#49
  def enabled=(enabled); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#45
  def enabled?; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#130
  def gauge(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#118
  def increment(stat, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#162
  def send_metrics(metrics); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#88
  def send_stats?; end

  # Returns the value of attribute statsd.
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#23
  def statsd; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#36
  def supported?; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#143
  def time(stat, options = T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/metrics/client.rb#172
  def dogstatsd_version; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#188
  def ignored_statsd_warning; end
end

# source://ddtrace//lib/datadog/core/metrics/client.rb#185
Datadog::Core::Metrics::Client::IGNORED_STATSD_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#7
module Datadog::Core::Metrics::Ext; end

# source://ddtrace//lib/datadog/core/metrics/ext.rb#8
Datadog::Core::Metrics::Ext::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#9
Datadog::Core::Metrics::Ext::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#11
Datadog::Core::Metrics::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#12
Datadog::Core::Metrics::Ext::TAG_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#13
Datadog::Core::Metrics::Ext::TAG_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#14
Datadog::Core::Metrics::Ext::TAG_TRACER_VERSION = T.let(T.unsafe(nil), String)

# For defining and adding helpers to metrics
#
# source://ddtrace//lib/datadog/core/metrics/helpers.rb#7
module Datadog::Core::Metrics::Helpers
  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def count(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def distribution(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def gauge(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def increment(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def time(name, stat); end
end

# source://ddtrace//lib/datadog/core/metrics/logging.rb#9
module Datadog::Core::Metrics::Logging; end

# Surrogate for Datadog::Statsd to log elsewhere
#
# source://ddtrace//lib/datadog/core/metrics/logging.rb#11
class Datadog::Core::Metrics::Logging::Adapter
  # @return [Adapter] a new instance of Adapter
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#14
  def initialize(logger = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#25
  def count(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#29
  def distribution(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#37
  def gauge(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#33
  def increment(stat, options = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#12
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#12
  def logger=(_arg0); end
end

# source://ddtrace//lib/datadog/core/metrics/metric.rb#6
class Datadog::Core::Metrics::Metric < ::Struct
  # @return [Metric] a new instance of Metric
  #
  # source://ddtrace//lib/datadog/core/metrics/metric.rb#7
  def initialize(*args); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# For defining and adding default options to metrics
#
# source://ddtrace//lib/datadog/core/metrics/options.rb#11
module Datadog::Core::Metrics::Options
  # source://ddtrace//lib/datadog/core/metrics/options.rb#34
  def default_metric_options; end

  # source://ddtrace//lib/datadog/core/metrics/options.rb#21
  def metric_options(options = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/metrics/options.rb#12
Datadog::Core::Metrics::Options::DEFAULT = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/core/metrics/options.rb#13
Datadog::Core::Metrics::Options::DEFAULT_TAGS = T.let(T.unsafe(nil), Array)

# A {Datadog::Core::Pin} sets metadata on a particular object.
#
# This is useful if you want the object to reflect
# customized behavior or attributes, like an eigenclass.
#
# source://ddtrace//lib/datadog/core/pin.rb#9
class Datadog::Core::Pin
  # @return [Pin] a new instance of Pin
  #
  # source://ddtrace//lib/datadog/core/pin.rb#27
  def initialize(**options); end

  # source://ddtrace//lib/datadog/core/pin.rb#31
  def [](name); end

  # source://ddtrace//lib/datadog/core/pin.rb#35
  def []=(name, value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/pin.rb#39
  def key?(name); end

  # source://ddtrace//lib/datadog/core/pin.rb#44
  def onto(obj); end

  # source://ddtrace//lib/datadog/core/pin.rb#65
  def to_s; end

  private

  # Returns the value of attribute options.
  #
  # source://ddtrace//lib/datadog/core/pin.rb#72
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://ddtrace//lib/datadog/core/pin.rb#72
  def options=(_arg0); end

  class << self
    # source://ddtrace//lib/datadog/core/pin.rb#10
    def get_from(obj); end

    # source://ddtrace//lib/datadog/core/pin.rb#16
    def set_on(obj, **options); end
  end
end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#5
module Datadog::Core::Runtime; end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#7
module Datadog::Core::Runtime::Ext; end

# Metrics
#
# source://ddtrace//lib/datadog/core/runtime/ext.rb#14
module Datadog::Core::Runtime::Ext::Metrics; end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#15
Datadog::Core::Runtime::Ext::Metrics::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#17
Datadog::Core::Runtime::Ext::Metrics::METRIC_CLASS_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#18
Datadog::Core::Runtime::Ext::Metrics::METRIC_GC_PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#20
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_CONSTANT_STATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#21
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_METHOD_STATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#19
Datadog::Core::Runtime::Ext::Metrics::METRIC_THREAD_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#23
Datadog::Core::Runtime::Ext::Metrics::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#8
Datadog::Core::Runtime::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#9
Datadog::Core::Runtime::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#10
Datadog::Core::Runtime::Ext::TAG_PROCESS_ID = T.let(T.unsafe(nil), String)

# For generating runtime metrics
#
# source://ddtrace//lib/datadog/core/runtime/metrics.rb#15
class Datadog::Core::Runtime::Metrics < ::Datadog::Core::Metrics::Client
  # @return [Metrics] a new instance of Metrics
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#16
  def initialize(**options); end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#85
  def default_metric_options; end

  # Flush all runtime metrics to Statsd client
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#41
  def flush; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#73
  def gc_metrics; end

  # Associate service with runtime metrics
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#26
  def register_service(service); end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#79
  def try_flush; end

  private

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#102
  def compile_service_tags!; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#108
  def nested_gc_metric(prefix, k, v); end

  # Returns the value of attribute service_tags.
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#98
  def service_tags; end

  # Returns the value of attribute services.
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#98
  def services; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#120
  def to_metric_name(str); end
end

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#5
module Datadog::Core::Telemetry; end

# Telemetry entrypoint, coordinates sending telemetry events at various points in app lifecyle
#
# source://ddtrace//lib/datadog/core/telemetry/client.rb#11
class Datadog::Core::Telemetry::Client
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @param enabled [Boolean] Determines whether telemetry events should be sent to the API
  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#49
  def initialize(*args, **kwargs, &block); end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#31
  def disable!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#50
  def emit_closing!; end

  # Returns the value of attribute emitter.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def emitter; end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def enabled; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#63
  def integrations_change!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#36
  def started!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#56
  def stop!; end

  # Returns the value of attribute unsupported.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def unsupported; end

  # Returns the value of attribute worker.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def worker; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#71
  def heartbeat!; end
end

# Module defining methods for collecting metadata for telemetry
#
# source://ddtrace//lib/datadog/core/telemetry/collector.rb#21
module Datadog::Core::Telemetry::Collector
  include ::Datadog::Core::Configuration

  # Forms a hash of configuration key value pairs to be sent in the additional payload
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#25
  def additional_payload; end

  # Forms a telemetry application object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#30
  def application; end

  # Forms a hash of standard key value pairs to be sent in the app-started event configuration
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#45
  def configurations; end

  # Forms a telemetry app-started dependencies object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#55
  def dependencies; end

  # Forms a telemetry host object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#64
  def host; end

  # Forms a telemetry app-started integrations object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#75
  def integrations; end

  # Returns the runtime ID of the current process
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#91
  def runtime_id; end

  # Returns the current as a UNIX timestamp in seconds
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#96
  def tracer_time; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#122
  def additional_payload_variables; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#185
  def agent_transport; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#181
  def appsec; end

  # Manual implementation of hash.compact used because it is unsupported by older Ruby versions (<2.4)
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#153
  def compact_hash(hash); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#157
  def env; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#142
  def format_configuration_value(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#198
  def instrumented?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#194
  def instrumented_integrations; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#206
  def integration_auto_instrument?(integration); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#210
  def integration_compatible?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#214
  def integration_version(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#169
  def library_version; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#218
  def patch_error(integration); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#202
  def patched?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#173
  def products; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#177
  def profiler; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#161
  def service_name; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#165
  def service_version; end
end

# source://ddtrace//lib/datadog/core/telemetry/collector.rb#102
Datadog::Core::Telemetry::Collector::TARGET_OPTIONS = T.let(T.unsafe(nil), Array)

# Class that emits telemetry events
#
# source://ddtrace//lib/datadog/core/telemetry/emitter.rb#12
class Datadog::Core::Telemetry::Emitter
  extend ::Datadog::Core::Utils::Forking

  # @param sequence [Datadog::Core::Utils::Sequence] Sequence object that stores and increments a counter
  # @param http_transport [Datadog::Core::Telemetry::Http::Transport] Transport object that can be used to send
  #   telemetry requests via the agent
  # @return [Emitter] a new instance of Emitter
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#20
  def initialize(http_transport: T.unsafe(nil)); end

  # Returns the value of attribute http_transport.
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#13
  def http_transport; end

  # Retrieves and emits a TelemetryRequest object based on the request type specified
  #
  # @param request_type [String] the type of telemetry request to collect data for
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#26
  def request(request_type); end

  class << self
    # Initializes a Sequence object to track seq_id if not already initialized; else returns stored
    # Sequence object
    #
    # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#41
    def sequence; end
  end
end

# Class defining methods to construct a Telemetry event
#
# source://ddtrace//lib/datadog/core/telemetry/event.rb#11
class Datadog::Core::Telemetry::Event
  include ::Datadog::Core::Configuration
  include ::Datadog::Core::Telemetry::Collector

  # @return [Event] a new instance of Event
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#21
  def initialize; end

  # Returns the value of attribute api_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#18
  def api_version; end

  # Forms a TelemetryRequest object based on the event request_type
  #
  # @param request_type [String] the type of telemetry request to collect data for
  # @param seq_id [Integer] the ID of the request; incremented each time a telemetry request is sent to the API
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#28
  def telemetry_request(request_type:, seq_id:); end

  private

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#65
  def app_integrations_change; end

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#56
  def app_started; end

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#43
  def payload(request_type); end
end

# source://ddtrace//lib/datadog/core/telemetry/event.rb#16
Datadog::Core::Telemetry::Event::API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#6
module Datadog::Core::Telemetry::Ext; end

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#7
Datadog::Core::Telemetry::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Periodically (every DEFAULT_INTERVAL_SECONDS) sends a heartbeat event to the telemetry API.
#
# source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#10
class Datadog::Core::Telemetry::Heartbeat < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [Heartbeat] a new instance of Heartbeat
  #
  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#15
  def initialize(enabled: T.unsafe(nil), interval: T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#25
  def loop_wait_before_first_iteration?; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#31
  def start; end
end

# source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#13
Datadog::Core::Telemetry::Heartbeat::DEFAULT_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/telemetry/http/env.rb#6
module Datadog::Core::Telemetry::Http; end

# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#9
module Datadog::Core::Telemetry::Http::Adapters; end

# Class defining methods to make http requests via NET
#
# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#11
class Datadog::Core::Telemetry::Http::Adapters::Net
  # @return [Net] a new instance of Net
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#20
  def initialize(hostname:, port: T.unsafe(nil), timeout: T.unsafe(nil), ssl: T.unsafe(nil)); end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#12
  def hostname; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#27
  def open(&block); end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#12
  def port; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#36
  def post(env); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#12
  def ssl; end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#12
  def timeout; end
end

# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#18
Datadog::Core::Telemetry::Http::Adapters::Net::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Data structure for an HTTP Response
#
# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#53
class Datadog::Core::Telemetry::Http::Adapters::Net::Response
  include ::Datadog::Core::Telemetry::Http::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#58
  def initialize(http_response); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#92
  def client_error?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#68
  def code; end

  # Returns the value of attribute http_response.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#56
  def http_response; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#104
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#86
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#74
  def ok?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#62
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#98
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#80
  def unsupported?; end
end

# Data structure for an HTTP request
#
# source://ddtrace//lib/datadog/core/telemetry/http/env.rb#8
class Datadog::Core::Telemetry::Http::Env
  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def body=(_arg0); end

  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#13
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#11
  def headers=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def path=(_arg0); end
end

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#5
module Datadog::Core::Telemetry::Http::Ext; end

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#15
Datadog::Core::Telemetry::Http::Ext::AGENT_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#13
Datadog::Core::Telemetry::Http::Ext::API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#12
Datadog::Core::Telemetry::Http::Ext::CONTENT_TYPE_APPLICATION_JSON = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#8
Datadog::Core::Telemetry::Http::Ext::HEADER_CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#7
Datadog::Core::Telemetry::Http::Ext::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#6
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_API_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#9
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_TELEMETRY_API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#10
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_TELEMETRY_REQUEST_TYPE = T.let(T.unsafe(nil), String)

# A generic error response for internal errors
#
# source://ddtrace//lib/datadog/core/telemetry/http/response.rb#48
class Datadog::Core::Telemetry::Http::InternalErrorResponse
  include ::Datadog::Core::Telemetry::Http::Response

  # @return [InternalErrorResponse] a new instance of InternalErrorResponse
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#53
  def initialize(error); end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#51
  def error; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#61
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#57
  def internal_error?; end
end

# Module for base HTTP response
#
# source://ddtrace//lib/datadog/core/telemetry/http/response.rb#8
module Datadog::Core::Telemetry::Http::Response
  include ::Kernel

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#27
  def client_error?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#39
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#35
  def internal_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#23
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#15
  def ok?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#11
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#31
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#19
  def unsupported?; end
end

# Class to send telemetry data to Telemetry API
#
# source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#13
class Datadog::Core::Telemetry::Http::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#20
  def initialize; end

  # Returns the value of attribute host.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#14
  def host; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#14
  def path; end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#14
  def port; end

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#28
  def request(request_type:, payload:); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#14
  def ssl; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#46
  def adapter; end

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#38
  def headers(request_type:, api_version: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#4
module Datadog::Core::Telemetry::V1; end

# Describes payload for telemetry V1 API app-integrations-change event
#
# source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#6
class Datadog::Core::Telemetry::V1::AppEvent
  # @param additional_payload [Array<Telemetry::V1::Configuration>] List of Additional payload to track (any key
  #   value not mentioned and doesn't fit under a metric)
  # @param configuration [Array<Telemetry::V1::Configuration>] List of Tracer related configuration data
  # @param dependencies [Array<Telemetry::V1::Dependency>] List of all loaded modules requested by the app
  # @param integrations [Array<Telemetry::V1::Integration>] List of integrations that are available within the app
  #   and applicable to be traced
  # @return [AppEvent] a new instance of AppEvent
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#21
  def initialize(additional_payload: T.unsafe(nil), configuration: T.unsafe(nil), dependencies: T.unsafe(nil), integrations: T.unsafe(nil)); end

  # Returns the value of attribute additional_payload.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def additional_payload; end

  # Returns the value of attribute configuration.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def configuration; end

  # Returns the value of attribute dependencies.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def dependencies; end

  # Returns the value of attribute integrations.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def integrations; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#28
  def to_h; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#45
  def map_array(arr); end

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#39
  def map_hash(hash); end
end

# Describes attributes for application environment object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#6
class Datadog::Core::Telemetry::V1::Application
  # @param env [String] Service's environment
  # @param language_name [String] 'ruby'
  # @param language_version [String] Version of language used
  # @param products [Telemetry::V1::Product] Contains information about specific products added to the environment
  # @param runtime_name [String] Runtime being used
  # @param runtime_patches [String] String of patches applied to the runtime
  # @param runtime_version [String] Runtime version; potentially the same as :language_version
  # @param service_name [String] Services name (DD_SERVICE)
  # @param service_version [String] Services version (DD_VERSION)
  # @param tracer_version [String] Version of the used tracer
  # @return [Application] a new instance of Application
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#34
  def initialize(language_name:, language_version:, service_name:, tracer_version:, env: T.unsafe(nil), products: T.unsafe(nil), runtime_name: T.unsafe(nil), runtime_patches: T.unsafe(nil), runtime_version: T.unsafe(nil), service_version: T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def env; end

  # Returns the value of attribute language_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def language_name; end

  # Returns the value of attribute language_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def language_version; end

  # Returns the value of attribute products.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def products; end

  # Returns the value of attribute runtime_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def runtime_name; end

  # Returns the value of attribute runtime_patches.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def runtime_patches; end

  # Returns the value of attribute runtime_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def runtime_version; end

  # Returns the value of attribute service_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def service_name; end

  # Returns the value of attribute service_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def service_version; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#56
  def to_h; end

  # Returns the value of attribute tracer_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
  def tracer_version; end

  private

  # Validates required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#76
  def validate(language_name:, language_version:, service_name:, tracer_version:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#7
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_LANGUAGE_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#8
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_LANGUAGE_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#9
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_SERVICE_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#10
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_TRACER_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for dependency object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#6
class Datadog::Core::Telemetry::V1::Dependency
  # @param name [String] Module name
  # @param version [String] Version of resolved module
  # @param hash [String] Dependency hash
  # @raise [ArgumentError]
  # @return [Dependency] a new instance of Dependency
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#17
  def initialize(name:, version: T.unsafe(nil), hash: T.unsafe(nil)); end

  # Returns the value of attribute hash.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#9
  def hash; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#9
  def name; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#25
  def to_h; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#9
  def version; end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#7
Datadog::Core::Telemetry::V1::Dependency::ERROR_NIL_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for host object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#6
class Datadog::Core::Telemetry::V1::Host
  # @param container_id [String] Docker container ID
  # @param hostname [String] uname -n
  # @param kernel_name [String] uname -s
  # @param kernel_release [String] uname -r
  # @param kernel_version [String] uname -v
  # @param os [String] uname -o
  # @param os_version [String] Version of OS running
  # @return [Host] a new instance of Host
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#23
  def initialize(container_id: T.unsafe(nil), hostname: T.unsafe(nil), kernel_name: T.unsafe(nil), kernel_release: T.unsafe(nil), kernel_version: T.unsafe(nil), os_version: T.unsafe(nil), os: T.unsafe(nil)); end

  # Returns the value of attribute container_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def container_id; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def hostname; end

  # Returns the value of attribute kernel_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def kernel_name; end

  # Returns the value of attribute kernel_release.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def kernel_release; end

  # Returns the value of attribute kernel_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def kernel_version; end

  # Returns the value of attribute os.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def os; end

  # Returns the value of attribute os_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#7
  def os_version; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#36
  def to_h; end
end

# Describes attributes for integration object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#6
class Datadog::Core::Telemetry::V1::Integration
  # @param enabled [Boolean] Whether integration is enabled at time of request
  # @param name [String] Integration name
  # @param auto_enabled [Boolean] If integration is not enabled by default, but by user choice
  # @param compatible [Boolean] If integration is available, but incompatible
  # @param error [String] Error message if integration fails to load
  # @param version [String] Integration version (if specified in app-started, it should be for other events too)
  # @return [Integration] a new instance of Integration
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#24
  def initialize(enabled:, name:, auto_enabled: T.unsafe(nil), compatible: T.unsafe(nil), error: T.unsafe(nil), version: T.unsafe(nil)); end

  # Returns the value of attribute auto_enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def auto_enabled; end

  # Returns the value of attribute compatible.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def compatible; end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def enabled; end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def error; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def name; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#34
  def to_h; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#10
  def version; end

  private

  # Validates all required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#50
  def validate(enabled:, name:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#7
Datadog::Core::Telemetry::V1::Integration::ERROR_NIL_ENABLED_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#8
Datadog::Core::Telemetry::V1::Integration::ERROR_NIL_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for products object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#6
class Datadog::Core::Telemetry::V1::Product
  # @param appsec [Telemetry::V1::AppSec] Holds custom information about the appsec product
  # @param profiler [Telemetry::V1::Profiler] Holds custom information about the profiler product
  # @return [Product] a new instance of Product
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#13
  def initialize(appsec: T.unsafe(nil), profiler: T.unsafe(nil)); end

  # Returns the value of attribute appsec.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#7
  def appsec; end

  # Returns the value of attribute profiler.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#7
  def profiler; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#18
  def to_h; end
end

# Describes attributes for telemetry API request
#
# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#6
class Datadog::Core::Telemetry::V1::TelemetryRequest
  # @param api_version [String] Requested API version, `v1`
  # @param application [Telemetry::V1::Application] Object that contains information about the environment of the
  #   application
  # @param host [Telemetry::V1::Host] Object that holds host related information
  # @param payload [Telemetry::V1::AppEvent] The payload of the request, type impacted by :request_type
  # @param request_type [String] Requested API function impacting the Payload type, `app-started`
  # @param runtime_id [String] V4 UUID that represents a tracer session
  # @param seq_id [Integer] Counter that should be auto incremented every time an API call is being made
  # @param tracer_time [Integer] Unix timestamp (in seconds) of when the message is being sent
  # @param debug [Boolean] Flag that enables payload debug mode
  # @param session_id [String] V4 UUID that represents the session of the top level tracer process, often same\
  #   as runtime_id
  # @return [TelemetryRequest] a new instance of TelemetryRequest
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#40
  def initialize(api_version:, application:, host:, payload:, request_type:, runtime_id:, seq_id:, tracer_time:, debug: T.unsafe(nil), session_id: T.unsafe(nil)); end

  # Returns the value of attribute api_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def api_version; end

  # Returns the value of attribute application.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def application; end

  # Returns the value of attribute debug.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def debug; end

  # Returns the value of attribute host.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def host; end

  # Returns the value of attribute payload.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def payload; end

  # Returns the value of attribute request_type.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def request_type; end

  # Returns the value of attribute runtime_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def runtime_id; end

  # Returns the value of attribute seq_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def seq_id; end

  # Returns the value of attribute session_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def session_id; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#66
  def to_h; end

  # Returns the value of attribute tracer_time.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
  def tracer_time; end

  private

  # Validates all required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#86
  def validate(api_version:, application:, host:, payload:, request_type:, runtime_id:, seq_id:, tracer_time:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#7
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_API_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#8
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_APPLICATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#9
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_HOST_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#10
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_PAYLOAD_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#11
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_REQUEST_TYPE_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#12
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_RUNTIME_ID_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#13
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_SEQ_ID_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#14
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_TRACER_TIME_MESSAGE = T.let(T.unsafe(nil), String)

# Utils contains low-level utilities, typically to provide pseudo-random trace IDs.
#
# source://ddtrace//lib/datadog/core/utils/time.rb#5
module Datadog::Core::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # Extracts hostname and port from
    # a string that contains both, separated by ':'.
    #
    # @return [String, Integer] hostname and port
    # @return [nil] if format did not match
    #
    # source://ddtrace//lib/datadog/core/utils.rb#86
    def extract_host_port(host_port); end

    # Stringifies `value` and ensures the outcome is
    # string is no longer than `size`.
    # `omission` replaces the end of the output if
    # `value.to_s` does not fit in `size`, to signify
    # truncation.
    #
    # If `omission.size` is larger than `size`, the output
    # will still be `omission.size` in length.
    #
    # source://ddtrace//lib/datadog/core/utils.rb#23
    def truncate(value, size, omission = T.unsafe(nil)); end

    # Ensure `str` is a valid UTF-8, ready to be
    # sent through the tracer transport.
    #
    # @param str [String, #to_s] object to be converted to a UTF-8 string
    # @param binary [Boolean] whether to expect binary data in the `str` parameter
    # @param placeholder [String] string to be returned when encoding fails
    # @return a UTF-8 string version of `str`
    #
    # source://ddtrace//lib/datadog/core/utils.rb#47
    def utf8_encode(str, binary: T.unsafe(nil), placeholder: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/utils.rb#70
    def without_warnings; end
  end
end

# source://ddtrace//lib/datadog/core/utils.rb#12
Datadog::Core::Utils::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Helper methods for managing forking behavior
#
# source://ddtrace//lib/datadog/core/utils/forking.rb#7
module Datadog::Core::Utils::Forking
  # source://ddtrace//lib/datadog/core/utils/forking.rb#20
  def after_fork!; end

  # source://ddtrace//lib/datadog/core/utils/forking.rb#38
  def fork_pid; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#30
  def forked?; end

  # source://ddtrace//lib/datadog/core/utils/forking.rb#34
  def update_fork_pid!; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/utils/forking.rb#12
    def extended(base); end

    # @private
    #
    # source://ddtrace//lib/datadog/core/utils/forking.rb#8
    def included(base); end
  end
end

# Adds additional functionality for Classes that implement Forking
#
# source://ddtrace//lib/datadog/core/utils/forking.rb#43
module Datadog::Core::Utils::Forking::ClassExtensions
  # source://ddtrace//lib/datadog/core/utils/forking.rb#49
  def initialize(*args, **kwargs, &block); end
end

# Helper class to execute something only once such as not repeating warning logs, and instrumenting classes
# only once.
#
# Thread-safe when used correctly (e.g. be careful of races when lazily initializing instances of this class).
#
# Note: In its current state, this class is not Ractor-safe.
# In https://github.com/DataDog/dd-trace-rb/pull/1398#issuecomment-797378810 we have a discussion of alternatives,
# including an alternative implementation that is Ractor-safe once spent.
#
# source://ddtrace//lib/datadog/core/utils/only_once.rb#16
class Datadog::Core::Utils::OnlyOnce
  # @return [OnlyOnce] a new instance of OnlyOnce
  #
  # source://ddtrace//lib/datadog/core/utils/only_once.rb#17
  def initialize; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/only_once.rb#32
  def ran?; end

  # source://ddtrace//lib/datadog/core/utils/only_once.rb#22
  def run; end

  private

  # source://ddtrace//lib/datadog/core/utils/only_once.rb#38
  def reset_ran_once_state_for_tests; end
end

# Helper methods for safer dup
#
# source://ddtrace//lib/datadog/core/utils/safe_dup.rb#7
module Datadog::Core::Utils::SafeDup
  class << self
    # source://ddtrace//lib/datadog/core/utils/safe_dup.rb#21
    def frozen_or_dup(v); end
  end
end

# Generates values from a consistent sequence
#
# source://ddtrace//lib/datadog/core/utils/sequence.rb#7
class Datadog::Core::Utils::Sequence
  # @return [Sequence] a new instance of Sequence
  #
  # source://ddtrace//lib/datadog/core/utils/sequence.rb#8
  def initialize(seed = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/utils/sequence.rb#14
  def next; end

  # source://ddtrace//lib/datadog/core/utils/sequence.rb#20
  def reset!; end
end

# Common database-related utility functions.
#
# source://ddtrace//lib/datadog/core/utils/time.rb#7
module Datadog::Core::Utils::Time
  include ::Kernel

  private

  # source://ddtrace//lib/datadog/core/utils/time.rb#46
  def as_utc_epoch_ns(time); end

  # Current monotonic time
  #
  # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
  # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#16
  def get_time(unit = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/utils/time.rb#39
  def measure(unit = T.unsafe(nil)); end

  # Current wall time.
  #
  # @return [Time] current time object
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#23
  def now; end

  # Overrides the implementation of `#now
  # with the provided callable.
  #
  # Overriding the method `#now` instead of
  # indirectly calling `block` removes
  # one level of method call overhead.
  #
  # @param block [Proc] block that returns a `Time` object representing the current wall time
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#35
  def now_provider=(block); end

  class << self
    # source://ddtrace//lib/datadog/core/utils/time.rb#46
    def as_utc_epoch_ns(time); end

    # Current monotonic time
    #
    # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
    # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#16
    def get_time(unit = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/utils/time.rb#39
    def measure(unit = T.unsafe(nil)); end

    # Current wall time.
    #
    # @return [Time] current time object
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#23
    def now; end

    # Overrides the implementation of `#now
    # with the provided callable.
    #
    # Overriding the method `#now` instead of
    # indirectly calling `block` removes
    # one level of method call overhead.
    #
    # @param block [Proc] block that returns a `Time` object representing the current wall time
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#35
    def now_provider=(block); end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#11
module Datadog::Core::Vendor; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#12
module Datadog::Core::Vendor::Multipart; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#13
module Datadog::Core::Vendor::Multipart::Post; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#22
class Datadog::Core::Vendor::Multipart::Post::CompositeReadIO
  # Create a new composite-read IO from the arguments, all of which should
  # respond to #read in a manner consistent with IO.
  #
  # @return [CompositeReadIO] a new instance of CompositeReadIO
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#25
  def initialize(*ios); end

  # Read from IOs in order until `length` bytes have been received.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#31
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#48
  def rewind; end

  private

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#59
  def advance_io; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#55
  def current_io; end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#18
module Datadog::Core::Vendor::Multipart::Post::Multipartable
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#33
  def initialize(path, params, headers = T.unsafe(nil), boundary = T.unsafe(nil)); end

  # Returns the value of attribute boundary.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#55
  def boundary; end

  class << self
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#19
    def secure_boundary; end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#14
module Datadog::Core::Vendor::Multipart::Post::Parts; end

# Represents the epilogue or closing boundary.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#126
class Datadog::Core::Vendor::Multipart::Post::Parts::EpiloguePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @return [EpiloguePart] a new instance of EpiloguePart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#129
  def initialize(boundary); end
end

# Represents a part to be filled from file IO.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#71
class Datadog::Core::Vendor::Multipart::Post::Parts::FilePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param name [#to_s]
  # @param io [IO]
  # @param headers [Hash]
  # @return [FilePart] a new instance of FilePart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#80
  def initialize(boundary, name, io, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param name [#to_s]
  # @param filename [String]
  # @param type [String]
  # @param content_len [Integer]
  # @param opts [Hash]
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#95
  def build_head(boundary, name, filename, type, content_len, opts = T.unsafe(nil)); end

  # Returns the value of attribute length.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#74
  def length; end
end

# Represents a parametric part to be filled with given value.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#39
class Datadog::Core::Vendor::Multipart::Post::Parts::ParamPart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param name [#to_s]
  # @param value [String]
  # @param headers [Hash] Content-Type and Content-ID are used, if present.
  # @return [ParamPart] a new instance of ParamPart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#46
  def initialize(boundary, name, value, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param name [#to_s]
  # @param value [String]
  # @param headers [Hash] Content-Type is used, if present.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#59
  def build_part(boundary, name, value, headers = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#51
  def length; end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#15
module Datadog::Core::Vendor::Multipart::Post::Parts::Part
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#29
  def length; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#33
  def to_io; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#25
    def file?(value); end

    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#16
    def new(boundary, name, value, headers = T.unsafe(nil)); end
  end
end

# Convenience methods for dealing with files and IO that are to be uploaded.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#65
class Datadog::Core::Vendor::Multipart::Post::UploadIO
  # Create an upload IO suitable for including in the params hash of a
  # Net::HTTP::Post::Multipart.
  #
  # Can take two forms. The first accepts a filename and content type, and
  # opens the file for reading (to be closed by finalizer).
  #
  # The second accepts an already-open IO, but also requires a third argument,
  # the filename from which it was opened (particularly useful/recommended if
  # uploading directly from a form in a framework, which often save the file to
  # an arbitrarily named RackMultipart file in /tmp).
  #
  # @example
  #   UploadIO.new("file.txt", "text/plain")
  #   UploadIO.new(file_io, "text/plain", "file.txt")
  # @return [UploadIO] a new instance of UploadIO
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#82
  def initialize(filename_or_io, content_type, filename = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Returns the value of attribute content_type.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#66
  def content_type; end

  # Returns the value of attribute io.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#66
  def io; end

  # Returns the value of attribute local_path.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#66
  def local_path; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#108
  def method_missing(*args); end

  # Returns the value of attribute opts.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#66
  def opts; end

  # Returns the value of attribute original_filename.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#66
  def original_filename; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#112
  def respond_to?(meth, include_all = T.unsafe(nil)); end

  class << self
    # @raise [ArgumentError]
    #
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#102
    def convert!(io, content_type, original_filename, local_path); end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#19
module Datadog::Core::Vendor::Net; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#20
class Datadog::Core::Vendor::Net::HTTP; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#27
class Datadog::Core::Vendor::Net::HTTP::Post; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#28
class Datadog::Core::Vendor::Net::HTTP::Post::Multipart < ::Net::HTTP::Post
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#21
class Datadog::Core::Vendor::Net::HTTP::Put; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#22
class Datadog::Core::Vendor::Net::HTTP::Put::Multipart < ::Net::HTTP::Put
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# Base class for work tasks
#
# source://ddtrace//lib/datadog/core/worker.rb#6
class Datadog::Core::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://ddtrace//lib/datadog/core/worker.rb#10
  def initialize(&block); end

  # source://ddtrace//lib/datadog/core/worker.rb#14
  def perform(*args); end

  # Returns the value of attribute task.
  #
  # source://ddtrace//lib/datadog/core/worker.rb#7
  def task; end

  protected

  # Sets the attribute task
  #
  # @param value the value to set the attribute task to.
  #
  # source://ddtrace//lib/datadog/core/worker.rb#20
  def task=(_arg0); end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#7
module Datadog::Core::Workers; end

# source://ddtrace//lib/datadog/core/workers/async.rb#8
module Datadog::Core::Workers::Async; end

# Adds threading behavior to workers
# to run tasks asynchronously.
#
# source://ddtrace//lib/datadog/core/workers/async.rb#11
module Datadog::Core::Workers::Async::Thread
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#69
  def completed?; end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#27
  def error; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#63
  def error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#73
  def failed?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#81
  def fork_policy; end

  # Sets the attribute fork_policy
  #
  # @param value the value to set the attribute fork_policy to.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#31
  def fork_policy=(_arg0); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#77
  def forked?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#34
  def join(timeout = T.unsafe(nil)); end

  # Returns the value of attribute result.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#27
  def result; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#49
  def run_async?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#59
  def running?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#55
  def started?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#40
  def terminate; end

  protected

  # source://ddtrace//lib/datadog/core/workers/async.rb#94
  def after_fork; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#90
  def mutex; end

  # Sets the attribute result
  #
  # @param value the value to set the attribute result to.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#87
  def result=(_arg0); end

  private

  # source://ddtrace//lib/datadog/core/workers/async.rb#103
  def mutex_after_fork; end

  # Returns the value of attribute pid.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#100
  def pid; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#165
  def restart_after_fork(&block); end

  # source://ddtrace//lib/datadog/core/workers/async.rb#111
  def start_async(&block); end

  # source://ddtrace//lib/datadog/core/workers/async.rb#128
  def start_worker; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#152
  def stop_fork; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#107
  def worker; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/async.rb#16
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#13
Datadog::Core::Workers::Async::Thread::FORK_POLICY_RESTART = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/datadog/core/workers/async.rb#12
Datadog::Core::Workers::Async::Thread::FORK_POLICY_STOP = T.let(T.unsafe(nil), Symbol)

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/async.rb#21
module Datadog::Core::Workers::Async::Thread::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/async.rb#22
  def perform(*args); end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#14
Datadog::Core::Workers::Async::Thread::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Adds looping behavior to workers, with a sleep
# interval between each loop.
#
# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#8
module Datadog::Core::Workers::IntervalLoop
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#65
  def loop_back_off!; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#53
  def loop_back_off_max; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#49
  def loop_back_off_ratio; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#45
  def loop_base_interval; end

  # Should perform_loop just straight into work, or start by waiting?
  #
  # The use case is if we want to report some information (like profiles) from time to time, we may not want to
  # report empty/zero/some residual value immediately when the worker starts.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#73
  def loop_wait_before_first_iteration?; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#57
  def loop_wait_time; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#61
  def loop_wait_time=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#39
  def run_loop?; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#24
  def stop_loop; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#35
  def work_pending?; end

  protected

  # Sets the attribute loop_back_off_max
  #
  # @param value the value to set the attribute loop_back_off_max to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#79
  def loop_back_off_max=(_arg0); end

  # Sets the attribute loop_back_off_ratio
  #
  # @param value the value to set the attribute loop_back_off_ratio to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#79
  def loop_back_off_ratio=(_arg0); end

  # Sets the attribute loop_base_interval
  #
  # @param value the value to set the attribute loop_base_interval to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#79
  def loop_base_interval=(_arg0); end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#84
  def mutex; end

  private

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#90
  def perform_loop; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#113
  def shutdown; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#13
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#10
Datadog::Core::Workers::IntervalLoop::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#9
Datadog::Core::Workers::IntervalLoop::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#11
Datadog::Core::Workers::IntervalLoop::BASE_INTERVAL = T.let(T.unsafe(nil), Integer)

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#18
module Datadog::Core::Workers::IntervalLoop::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#19
  def perform(*args); end
end

# Adds polling (async looping) behavior to workers
#
# source://ddtrace//lib/datadog/core/workers/polling.rb#10
module Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # Allow worker to be started
  #
  # source://ddtrace//lib/datadog/core/workers/polling.rb#52
  def enabled=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/polling.rb#45
  def enabled?; end

  # source://ddtrace//lib/datadog/core/workers/polling.rb#26
  def stop(force_stop = T.unsafe(nil), timeout = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/polling.rb#13
    def included(base); end
  end
end

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/polling.rb#20
module Datadog::Core::Workers::Polling::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/polling.rb#21
  def perform(*args); end
end

# source://ddtrace//lib/datadog/core/workers/polling.rb#11
Datadog::Core::Workers::Polling::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Emits runtime metrics asynchronously on a timed loop
#
# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#13
class Datadog::Core::Workers::RuntimeMetrics < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [RuntimeMetrics] a new instance of RuntimeMetrics
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#23
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#20
  def metrics; end

  # source://ddtrace//lib/datadog/core/workers/polling.rb#21
  def perform(*args); end

  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#42
  def register_service(service); end

  # TODO: `close_metrics` is only needed because
  # Datadog::Core::Configuration::Components directly manipulates
  # the lifecycle of Runtime::Metrics.statsd instances.
  # This should be avoided, as it prevents this class from
  # ensuring correct resource decommission of its internal
  # dependencies.
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#53
  def stop(*args, close_metrics: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#18
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# In seconds
#
# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#17
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# Datadog::Kit holds public-facing APIs for higher level user-facing
# features, these features not belonging to a specific product. Contrary to
# Datadog::Core, Kit depends on products.
#
# source://ddtrace//lib/datadog/kit.rb#7
module Datadog::Kit; end

# Tracking identity via traces
#
# source://ddtrace//lib/datadog/kit/identity.rb#7
module Datadog::Kit::Identity
  class << self
    # Attach user information to the trace
    #
    #
    # @param trace [TraceOperation] Trace to attach data to.
    # @param id [String] Mandatory. Username or client id extracted
    #   from the access token or Authorization header in the inbound request
    #   from outside the system.
    # @param email [String] Email of the authenticated user associated
    #   to the trace.
    # @param name [String] User-friendly name. To be displayed in the
    #   UI if set.
    # @param session_id [String] Session ID of the authenticated user.
    # @param role [String] Actual/assumed role the client is making
    #   the request under extracted from token or application security
    #   context.
    # @param scope [String] Scopes or granted authorities the client
    #   currently possesses extracted from token or application security
    #   context. The value would come from the scope associated with an OAuth
    #   2.0 Access Token or an attribute value in a SAML 2.0 Assertion.
    # @param others [Hash<Symbol, String>] Additional free-form
    #   user information to attach to the trace.
    # @raise [ArgumentError]
    #
    # source://ddtrace//lib/datadog/kit/identity.rb#31
    def set_user(trace, id:, email: T.unsafe(nil), name: T.unsafe(nil), session_id: T.unsafe(nil), role: T.unsafe(nil), scope: T.unsafe(nil), **others); end
  end
end

# Contains profiler for generating stack profiles, etc.
#
# source://ddtrace//lib/datadog/profiling/ext.rb#4
module Datadog::Profiling
  class << self
    # Starts the profiler, if the profiler is supported by in
    # this runtime environment and if the profiler has been enabled
    # in configuration.
    #
    # @return [Boolean] `true` if the profiler has successfully started, otherwise `false`.
    #
    # source://ddtrace//lib/datadog/profiling.rb#34
    def start_if_enabled; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#13
    def supported?; end

    # source://ddtrace//lib/datadog/profiling.rb#17
    def unsupported_reason; end

    private

    # source://ddtrace//lib/datadog/profiling.rb#145
    def load_profiling; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#44
    def native_library_compilation_skipped?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#119
    def native_library_failed_to_load?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#83
    def protobuf_failed_to_load?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#64
    def protobuf_gem_unavailable?; end

    # The `google-protobuf` gem depends on a native component, and its creators helpfully tried to provide precompiled
    # versions of this extension on rubygems.org.
    #
    # Unfortunately, for a long time, the supported Ruby versions metadata on these precompiled versions of the extension
    # was not correctly set. (This is fixed in newer versions -- but not all Ruby versions we want to support can use
    # these.)
    #
    # Thus, the gem can still be installed, but can be in a broken state. To avoid breaking customer applications, we
    # use this helper to load it and gracefully handle failures.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#98
    def protobuf_loaded_successfully?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#73
    def protobuf_version_unsupported?; end

    # source://ddtrace//lib/datadog/profiling.rb#133
    def try_loading_native_library; end

    # source://ddtrace//lib/datadog/profiling.rb#50
    def try_reading_skipped_reason_file(file_api = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/profiling/ext.rb#5
module Datadog::Profiling::Ext; end

# source://ddtrace//lib/datadog/profiling/ext.rb#9
Datadog::Profiling::Ext::ENV_AGENTLESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#6
Datadog::Profiling::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#10
Datadog::Profiling::Ext::ENV_ENDPOINT_COLLECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#8
Datadog::Profiling::Ext::ENV_MAX_FRAMES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#7
Datadog::Profiling::Ext::ENV_UPLOAD_TIMEOUT = T.let(T.unsafe(nil), String)

# TODO: Consider removing this once the Ruby-based pprof encoding is removed and replaced by libdatadog
#
# source://ddtrace//lib/datadog/profiling/ext.rb#13
module Datadog::Profiling::Ext::Pprof; end

# source://ddtrace//lib/datadog/profiling/ext.rb#14
Datadog::Profiling::Ext::Pprof::LABEL_KEY_LOCAL_ROOT_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#15
Datadog::Profiling::Ext::Pprof::LABEL_KEY_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#16
Datadog::Profiling::Ext::Pprof::LABEL_KEY_THREAD_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#17
Datadog::Profiling::Ext::Pprof::LABEL_KEY_TRACE_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#18
Datadog::Profiling::Ext::Pprof::SAMPLE_VALUE_NO_VALUE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/profiling/ext.rb#19
Datadog::Profiling::Ext::Pprof::VALUE_TYPE_CPU = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#20
Datadog::Profiling::Ext::Pprof::VALUE_TYPE_WALL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#21
Datadog::Profiling::Ext::Pprof::VALUE_UNIT_NANOSECONDS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#24
module Datadog::Profiling::Ext::Transport; end

# source://ddtrace//lib/datadog/profiling/ext.rb#25
module Datadog::Profiling::Ext::Transport::HTTP; end

# source://ddtrace//lib/datadog/profiling/ext.rb#40
Datadog::Profiling::Ext::Transport::HTTP::CODE_PROVENANCE_FILENAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#26
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#27
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#28
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_LANGUAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#29
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_PID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#30
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_PROFILER_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#31
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#32
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#33
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#34
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#35
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#36
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#37
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#39
Datadog::Profiling::Ext::Transport::HTTP::PPROF_DEFAULT_FILENAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling.rb#10
Datadog::Profiling::GOOGLE_PROTOBUF_MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Datadog APM tracing public API.
#
# The Datadog team ensures that public methods in this module
# only receive backwards compatible changes, and breaking changes
# will only occur in new major versions releases.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#4
module Datadog::Tracing
  class << self
    # The active, unfinished span, representing the currently instrumented application section.
    #
    # The active span belongs to an {.active_trace}.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::SpanOperation] the active span
    # @return [nil] if no trace is active, and thus no span is active
    #
    # source://ddtrace//lib/datadog/tracing.rb#50
    def active_span; end

    # The active, unfinished trace, representing the current instrumentation context.
    #
    # The active trace is fiber-local.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::TraceSegment] the active trace
    # @return [nil] if no trace is active
    #
    # source://ddtrace//lib/datadog/tracing.rb#41
    def active_trace; end

    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://ddtrace//lib/datadog/tracing.rb#117
    def before_flush(*processors, &processor_block); end

    # Setup a new trace to continue from where another
    # trace left off.
    #
    # Used to continue distributed or async traces.
    #
    # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Object] If a block is provided, the result of the block execution.
    # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
    # @yield Optional block where this {#continue_trace!} `digest` scope is active.
    #   If no block, the `digest` remains active after {#continue_trace!} returns.
    #
    # source://ddtrace//lib/datadog/tracing.rb#23
    def continue_trace!(digest, &block); end

    # Information about the currently active trace.
    #
    # The most common use cases are tagging log messages and metrics.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::Correlation::Identifier] correlation object
    #
    # source://ddtrace//lib/datadog/tracing.rb#75
    def correlation; end

    # Is the tracer collecting telemetry data in this process?
    #
    # @return [Boolean] `true` if the tracer is collecting data in this process, otherwise `false`.
    #
    # source://ddtrace//lib/datadog/tracing.rb#123
    def enabled?; end

    # If an active trace is present, forces it to be retained by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://ddtrace//lib/datadog/tracing.rb#60
    def keep!; end

    # Textual representation of {.correlation}, which can be
    # added to individual log lines in order to correlate them with the active
    # trace.
    #
    # Example:
    #
    # ```
    # MyLogger.log("#{Datadog::Tracing.log_correlation}] My message")
    # # dd.env=prod dd.service=auth dd.version=13.8 dd.trace_id=5458478252992251 dd.span_id=7117552347370098 My message
    # ```
    #
    # @return [String] correlation information
    #
    # source://ddtrace//lib/datadog/tracing.rb#95
    def log_correlation; end

    # The tracer's internal logger instance.
    # All tracing log output is handled by this object.
    #
    # The logger can be configured through {.configure},
    # through {Datadog::Core::Configuration::Settings::DSL::Logger} options.
    #
    # source://ddtrace//lib/datadog/tracing.rb#35
    def logger; end

    # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://ddtrace//lib/datadog/tracing.rb#68
    def reject!; end

    # Gracefully shuts down the tracer.
    #
    # The public tracing API will still respond to method calls as usual
    # but might not internally perform the expected internal work after shutdown.
    #
    # This avoids errors being raised across the host application
    # during shutdown while allowing for the graceful decommission of resources.
    #
    # {.shutdown!} cannot be reversed.
    #
    # source://ddtrace//lib/datadog/tracing.rb#109
    def shutdown!; end

    # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
    # that will trace an operation called `name`.
    #
    # You could trace your code using a <tt>do-block</tt> like:
    #
    # ```
    # tracer.trace('web.request') do |span_op, trace_op|
    #   span_op.service = 'my-web-site'
    #   span_op.resource = '/'
    #   span_op.set_tag('http.method', request.request_method)
    #   do_something()
    # end
    # ```
    #
    # The {#trace} method can also be used without a block in this way:
    # ```
    # span_op = tracer.trace('web.request', service: 'my-web-site')
    # do_something()
    # span_op.finish()
    # ```
    #
    # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
    #
    # When a Trace is started, {#trace} will store the created span; subsequent spans will
    # become its children and will inherit some properties:
    # ```
    # parent = tracer.trace('parent')   # has no parent span
    # child  = tracer.trace('child')    # is a child of 'parent'
    # child.finish()
    # parent.finish()
    # parent2 = tracer.trace('parent2') # has no parent span
    # parent2.finish()
    # ```
    #
    #
    # @param name [String] {Datadog::Tracing::Span} operation name.
    #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
    # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
    #   Used for linking traces that are executed asynchronously.
    # @param on_error [Proc] a block that overrides error handling behavior for this operation.
    # @param resource [String] the resource this span refers, or `name` if it's missing
    # @param service [String] the service name for this span.
    # @param start_time [Time] time which the span should have started.
    # @param tags [Hash<String,String>] extra tags which should be added to the span.
    # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
    # @return [Object] If a block is provided, returns the result of the block execution.
    # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
    #   unfinished {Datadog::Tracing::SpanOperation}.
    # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
    # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
    # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
    #
    # source://ddtrace//lib/datadog/tracing.rb#17
    def trace(name, continue_from: T.unsafe(nil), **span_options, &block); end

    private

    # DEV: components hosts both tracing and profiling inner objects today
    #
    # source://ddtrace//lib/datadog/tracing.rb#133
    def components; end

    # source://ddtrace//lib/datadog/tracing.rb#137
    def tracer; end
  end
end

# Defines analytics behavior
#
# source://ddtrace//lib/datadog/tracing/analytics.rb#8
module Datadog::Tracing::Analytics
  class << self
    # source://ddtrace//lib/datadog/tracing/analytics.rb#16
    def set_measured(span_op, value = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/analytics.rb#10
    def set_sample_rate(span_op, sample_rate); end
  end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# @see Datadog::Core::Buffer::CRuby
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#114
class Datadog::Tracing::CRubyTraceBuffer < ::Datadog::Core::Buffer::CRuby
  include ::Datadog::Tracing::MeasuredBuffer
end

# Common functions for supporting the `http.client_ip` span attribute.
#
# source://ddtrace//lib/datadog/tracing/client_ip.rb#12
module Datadog::Tracing::ClientIp
  class << self
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#159
    def configuration; end

    # source://ddtrace//lib/datadog/tracing/client_ip.rb#150
    def ip_headers(headers); end

    # Returns whether the given value is more likely to be an IPv4 than an IPv6 address.
    #
    # This is done by checking if a dot (`'.'`) character appears before a colon (`':'`) in the value.
    # The rationale is that in valid IPv6 addresses, colons will always preced dots,
    #   and in valid IPv4 addresses dots will always preced colons.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#129
    def likely_ipv4?(value); end

    # Returns a result struct that holds the raw client IP associated with the request if it was
    #   retrieved successfully.
    #
    # The client IP is looked up by the following logic:
    # * If the user has configured a header name, return that header's value.
    # * If exactly one of the known IP headers is present, return that header's value.
    # * If none of the known IP headers are present, return the remote IP from the request.
    #
    # If more than one of the known IP headers is present, the result will have a `multiple_ip_headers`
    #   field with the name of the present IP headers.
    #
    # @param headers [Datadog::Core::HeaderCollection, #get, nil] The request headers
    # @param remote_ip [String] The remote IP of the request.
    # @return [IpExtractionResult] A struct that holds the unprocessed IP value,
    #   or `nil` if it wasn't found. Additionally, the `multiple_ip_headers` fields will hold the
    #   name of known IP headers present in the request if more than one of these were found.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#83
    def raw_ip_from_request(headers, remote_ip); end

    # Sets the `http.client_ip` tag on the given span.
    #
    # This function respects the user's settings: if they disable the client IP tagging,
    #   or provide a different IP header name.
    #
    # If multiple IP headers are present in the request, this function will instead set
    #   the `_dd.multiple-ip-headers` tag with the names of the present headers,
    #   and **NOT** set the `http.client_ip` tag.
    #
    # @param span [Span] The span that's associated with the request.
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#39
    def set_client_ip_tag(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    # Forcefully sets the `http.client_ip` tag on the given span.
    #
    # This function ignores the user's `enabled` setting.
    #
    # @param span [Span] The span that's associated with the request.
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#52
    def set_client_ip_tag!(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    # Removes any port notations or zone specifiers from the IP address without
    #   verifying its validity.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#100
    def strip_decorations(address); end

    # source://ddtrace//lib/datadog/tracing/client_ip.rb#112
    def strip_ipv4_port(ip); end

    # source://ddtrace//lib/datadog/tracing/client_ip.rb#116
    def strip_ipv6_port(ip); end

    # source://ddtrace//lib/datadog/tracing/client_ip.rb#108
    def strip_zone_specifier(ipv6); end

    # Determines whether the given string is a valid IPv4 or IPv6 address.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#137
    def valid_ip?(ip); end
  end
end

# source://ddtrace//lib/datadog/tracing/client_ip.rb#13
Datadog::Tracing::ClientIp::DEFAULT_IP_HEADERS_NAMES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/client_ip.rb#65
class Datadog::Tracing::ClientIp::IpExtractionResult < ::Struct
  # Returns the value of attribute multiple_ip_headers
  #
  # @return [Object] the current value of multiple_ip_headers
  def multiple_ip_headers; end

  # Sets the attribute multiple_ip_headers
  #
  # @param value [Object] the value to set the attribute multiple_ip_headers to.
  # @return [Object] the newly set value
  def multiple_ip_headers=(_); end

  # Returns the value of attribute raw_ip
  #
  # @return [Object] the current value of raw_ip
  def raw_ip; end

  # Sets the attribute raw_ip
  #
  # @param value [Object] the value to set the attribute raw_ip to.
  # @return [Object] the newly set value
  def raw_ip=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/tracing/client_ip.rb#25
Datadog::Tracing::ClientIp::TAG_MULTIPLE_IP_HEADERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#5
module Datadog::Tracing::Configuration; end

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#8
module Datadog::Tracing::Configuration::Ext; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#12
module Datadog::Tracing::Configuration::Ext::Analytics; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#13
Datadog::Tracing::Configuration::Ext::Analytics::ENV_TRACE_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#86
module Datadog::Tracing::Configuration::Ext::ClientIp; end

# TODO: deprecated, remove later
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#88
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_DISABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#87
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#89
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_HEADER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#17
module Datadog::Tracing::Configuration::Ext::Correlation; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#18
Datadog::Tracing::Configuration::Ext::Correlation::ENV_LOGS_INJECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#22
module Datadog::Tracing::Configuration::Ext::Distributed; end

# Sets both extract and inject propagation style tho the provided value.
# Has lower precedence than `DD_TRACE_PROPAGATION_STYLE_INJECT` or
# `DD_TRACE_PROPAGATION_STYLE_EXTRACT`.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#40
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#46
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_EXTRACT = T.let(T.unsafe(nil), String)

# @deprecated Use `DD_TRACE_PROPAGATION_STYLE_EXTRACT` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#48
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_EXTRACT_OLD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#42
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_INJECT = T.let(T.unsafe(nil), String)

# @deprecated Use `DD_TRACE_PROPAGATION_STYLE_INJECT` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#44
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_INJECT_OLD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#54
Datadog::Tracing::Configuration::Ext::Distributed::ENV_X_DATADOG_TAGS_MAX_LENGTH = T.let(T.unsafe(nil), String)

# @deprecated Use `b3multi` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#28
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3 = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#26
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_MULTI_HEADER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#30
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_SINGLE_HEADER = T.let(T.unsafe(nil), String)

# @deprecated Use `b3` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#32
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_SINGLE_HEADER_OLD = T.let(T.unsafe(nil), String)

# Custom Datadog format
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#24
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_DATADOG = T.let(T.unsafe(nil), String)

# A no-op propagator. Compatible with OpenTelemetry's `none` propagator.
#
# @see https://opentelemetry.io/docs/concepts/sdk-configuration/general-sdk-configuration/#get_otel__propagators
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#52
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_NONE = T.let(T.unsafe(nil), String)

# W3C Trace Context
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#35
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_TRACE_CONTEXT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#9
Datadog::Tracing::Configuration::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#58
module Datadog::Tracing::Configuration::Ext::NET; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#59
Datadog::Tracing::Configuration::Ext::NET::ENV_REPORT_HOSTNAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#63
module Datadog::Tracing::Configuration::Ext::Sampling; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#65
Datadog::Tracing::Configuration::Ext::Sampling::ENV_RATE_LIMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#64
Datadog::Tracing::Configuration::Ext::Sampling::ENV_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#68
module Datadog::Tracing::Configuration::Ext::Sampling::Span; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#69
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#70
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES_FILE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#75
module Datadog::Tracing::Configuration::Ext::Test; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#76
Datadog::Tracing::Configuration::Ext::Test::ENV_MODE_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#80
module Datadog::Tracing::Configuration::Ext::Transport; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#81
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#82
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_URL = T.let(T.unsafe(nil), String)

# Configuration settings for tracing.
#
# source://ddtrace//lib/datadog/tracing/configuration/settings.rb#15
module Datadog::Tracing::Configuration::Settings
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/configuration/settings.rb#16
    def extended(base); end
  end
end

# {Datadog::Tracing::Context} is used to keep track of a the active trace for the current
# execution flow. During each logical execution, the same {Datadog::Tracing::Context} is
# used to represent a single logical trace, even if the trace is built
# asynchronously.
#
# A single code execution may use multiple {Datadog::Tracing::Context} if part of the execution
# must not be related to the current tracing. As example, a delayed job may
# compose a standalone trace instead of being related to the same trace that
# generates the job itself. On the other hand, if it's part of the same
# {Datadog::Tracing::Context}, it will be related to the original trace.
#
# source://ddtrace//lib/datadog/tracing/context.rb#17
class Datadog::Tracing::Context
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @return [Context] a new instance of Context
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#49
  def initialize(*args, **kwargs, &block); end

  # Handles trace activation.
  #
  # Permits nil, allowing traces to be deactivated.
  #
  # If given a block, it will reset to the original
  # trace after the block completes.
  #
  # When restoring the original trace, if it is finished,
  # it will deactivate it. This prevents the context from
  # holding references to completed traces thereby releasing
  # its memory.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#40
  def activate!(trace); end

  # Returns the value of attribute active_trace.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#20
  def active_trace; end

  # Creates a copy of the context, when forked.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#55
  def fork_clone; end

  private

  # source://ddtrace//lib/datadog/tracing/context.rb#62
  def set_active_trace!(trace); end
end

# Out-of-the-box instrumentation for tracing
#
# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#5
module Datadog::Tracing::Contrib; end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#6
module Datadog::Tracing::Contrib::ActionCable; end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionCable::Configuration; end

# Custom settings for the ActionCable integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionCable::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#13
module Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#14
    def included(base); end
  end
end

# Class methods for events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#20
module Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#29
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#21
  def span_options; end
end

# Defines collection of instrumented ActionCable events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#12
module Datadog::Tracing::Contrib::ActionCable::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#22
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#30
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#26
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#22
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#30
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#26
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#14
Datadog::Tracing::Contrib::ActionCable::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for 'broadcast.action_cable' event.
#
# A single 'broadcast' event will trigger as many 'transmit' events
# as there are clients subscribed to a channel.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#17
module Datadog::Tracing::Contrib::ActionCable::Events::Broadcast
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#24
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#37
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#28
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#32
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#24
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#37
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#28
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#32
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#20
Datadog::Tracing::Contrib::ActionCable::Events::Broadcast::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'perform_action.action_cable' event.
#
# An action, triggered by a WebSockets client, invokes a method
# in the server's channel instance.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#16
module Datadog::Tracing::Contrib::ActionCable::Events::PerformAction
  include ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#23
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#36
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#27
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#31
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#23
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#36
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#27
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#31
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#19
Datadog::Tracing::Contrib::ActionCable::Events::PerformAction::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'transmit.action_cable' event.
#
# A 'transmit' event sends a message to a single client subscribed to a channel.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#16
module Datadog::Tracing::Contrib::ActionCable::Events::Transmit
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#23
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#36
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#27
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#31
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#23
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#36
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#27
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#31
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#19
Datadog::Tracing::Contrib::ActionCable::Events::Transmit::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionCable integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#9
module Datadog::Tracing::Contrib::ActionCable::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#11
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#12
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#10
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#13
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#14
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_BROADCAST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#15
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ON_OPEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#16
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_TRANSMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#17
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#18
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_BROADCAST_CODER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#19
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#20
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL_CLASS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#21
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#22
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CONNECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#23
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#24
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_BROADCAST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#25
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ON_OPEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#26
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_TRANSMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#27
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_TRANSMIT_VIA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#11
module Datadog::Tracing::Contrib::ActionCable::Instrumentation; end

# Instrumentation for when a Channel is subscribed to/unsubscribed from.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#39
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#40
    def included(base); end
  end
end

# Instrumentation for Channel hooks.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#59
class Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel::Tracer
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#60
    def trace(channel, hook); end
  end
end

# When a new WebSocket is open, we receive a Rack request resource name "GET -1".
# This module overrides the current Rack resource name to provide a meaningful name.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#14
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableConnection
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#15
  def on_open; end
end

# Description of ActionCable integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#13
class Datadog::Tracing::Contrib::ActionCable::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#16
Datadog::Tracing::Contrib::ActionCable::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_cable' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#13
module Datadog::Tracing::Contrib::ActionCable::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
    def target_version; end
  end
end

# Defines behavior for the first event of a thread execution.
#
# This event is not expected to be nested with other event,
# but to start a fresh tracing context.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#39
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#40
    def included(base); end
  end
end

# Class methods for events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#46
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods
  include ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#49
  def subscription(*args); end

  private

  # Context objects are thread-bound.
  # If an integration re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#61
  def ensure_clean_context!; end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#6
module Datadog::Tracing::Contrib::ActionMailer; end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionMailer::Configuration; end

# Custom settings for the ActionMailer integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionMailer::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def email_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def email_data=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActionMailer event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#13
    def included(base); end
  end
end

# Class methods for ActionMailer events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#19
module Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#30
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActionMailer events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#11
module Datadog::Tracing::Contrib::ActionMailer::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#12
Datadog::Tracing::Contrib::ActionMailer::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for deliver.action_mailer event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#13
module Datadog::Tracing::Contrib::ActionMailer::Events::Deliver
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#33
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#24
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#28
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#20
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#33
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#24
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#28
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#16
Datadog::Tracing::Contrib::ActionMailer::Events::Deliver::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process.action_mailer event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#13
module Datadog::Tracing::Contrib::ActionMailer::Events::Process
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#33
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#24
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#28
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#20
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#33
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#24
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#28
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#16
Datadog::Tracing::Contrib::ActionMailer::Events::Process::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionMailer integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#9
module Datadog::Tracing::Contrib::ActionMailer::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#11
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#12
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#10
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#14
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_DELIVER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#13
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_PROCESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#16
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#25
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_BCC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#26
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_CC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#15
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#27
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#24
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_FROM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#17
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MAILER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#18
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MSG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#19
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_DELIVER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#20
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_PROCESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#28
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_PERFORM_DELIVERIES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#22
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_SUBJECT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#23
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_TO = T.let(T.unsafe(nil), String)

# Description of ActionMailer integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#13
class Datadog::Tracing::Contrib::ActionMailer::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#16
Datadog::Tracing::Contrib::ActionMailer::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_mailer' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#6
module Datadog::Tracing::Contrib::ActionPack; end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#15
module Datadog::Tracing::Contrib::ActionPack::ActionController; end

# Instrumentation for ActionController components
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#17
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#86
  def exception_controller?(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#48
  def finish_processing(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#20
  def start_processing(payload); end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#86
    def exception_controller?(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#48
    def finish_processing(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#20
    def start_processing(payload); end
  end
end

# Instrumentation for ActionController::Metal
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#107
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation::Metal
  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#144
  def datadog_response_status; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#108
  def process_action(*args); end
end

# Patcher for ActionController components
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#12
module Datadog::Tracing::Contrib::ActionPack::ActionController::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionPack::Configuration; end

# Custom settings for the ActionPack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionPack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def exception_controller; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def exception_controller=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# ActionPack integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#9
module Datadog::Tracing::Contrib::ActionPack::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#11
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#12
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#10
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#13
Datadog::Tracing::Contrib::ActionPack::Ext::SPAN_ACTION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#14
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#15
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_OPERATION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#16
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#17
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_CONTROLLER = T.let(T.unsafe(nil), String)

# Describes the ActionPack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#13
class Datadog::Tracing::Contrib::ActionPack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#16
Datadog::Tracing::Contrib::ActionPack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_pack' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#11
module Datadog::Tracing::Contrib::ActionPack::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#16
    def target_version; end
  end
end

# Common utilities for ActionPack
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#10
module Datadog::Tracing::Contrib::ActionPack::Utils
  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#11
    def exception_is_error?(exception); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#23
    def set_analytics_sample_rate(span); end

    private

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#32
    def datadog_configuration; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#6
module Datadog::Tracing::Contrib::ActionView; end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionView::Configuration; end

# Custom settings for the ActionView integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionView::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def template_base_path; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def template_base_path=(value); end
end

# Defines basic behavior for an ActionView event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#10
module Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#11
    def included(base); end
  end
end

# Class methods for ActionView events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#17
module Datadog::Tracing::Contrib::ActionView::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#18
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#22
  def record_exception(span, payload); end
end

# Defines collection of instrumented ActionView events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#13
module Datadog::Tracing::Contrib::ActionView::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#12
Datadog::Tracing::Contrib::ActionView::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render_partial.action_view event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#15
module Datadog::Tracing::Contrib::ActionView::Events::RenderPartial
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#22
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#30
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#26
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#22
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#30
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#26
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#18
Datadog::Tracing::Contrib::ActionView::Events::RenderPartial::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for render_template.action_view event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#15
module Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#22
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#30
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#26
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#22
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#30
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#26
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#18
Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionView integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#9
module Datadog::Tracing::Contrib::ActionView::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#11
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#12
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#10
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#13
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#14
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#15
Datadog::Tracing::Contrib::ActionView::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#16
Datadog::Tracing::Contrib::ActionView::Ext::TAG_LAYOUT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#17
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#18
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#19
Datadog::Tracing::Contrib::ActionView::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#10
module Datadog::Tracing::Contrib::ActionView::Instrumentation; end

# Legacy instrumentation for partial rendering for Rails < 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#12
module Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#38
  def datadog_render_partial(template); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#13
  def render(*args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#25
  def render_partial(*args); end

  private

  # Returns the value of attribute active_datadog_span.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#55
  def active_datadog_span; end

  # Sets the attribute active_datadog_span
  #
  # @param value the value to set the attribute active_datadog_span to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#55
  def active_datadog_span=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#57
  def with_datadog_span(span); end
end

# Rails < 4 partial rendering
# ActiveSupport events are used instead for Rails >= 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#66
module Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer::RailsLessThan4
  include ::Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#69
  def datadog_template(*args); end
end

# Legacy instrumentation for template rendering for Rails < 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#12
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer; end

# Legacy shared code for Rails >= 3.1 template rendering
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#14
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::Rails31Plus
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#40
  def datadog_render_template(template, layout_name); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#15
  def render(*args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#27
  def render_template(*args); end

  private

  # Returns the value of attribute active_datadog_span.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#67
  def active_datadog_span; end

  # Sets the attribute active_datadog_span
  #
  # @param value the value to set the attribute active_datadog_span to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#67
  def active_datadog_span=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#69
  def with_datadog_span(span); end
end

# Rails >= 3.1, < 4 template rendering
# ActiveSupport events are used instead for Rails >= 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#79
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::RailsLessThan4
  include ::Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::Rails31Plus

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#82
  def datadog_parse_args(template, layout_name, *args); end
end

# Describes the ActionView integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#13
class Datadog::Tracing::Contrib::ActionView::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#42
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#46
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#50
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#36
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#32
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#16
Datadog::Tracing::Contrib::ActionView::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of ActionView module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#16
module Datadog::Tracing::Contrib::ActionView::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#25
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#29
  def patch_renderer; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#21
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#29
    def patch_renderer; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#21
    def target_version; end
  end
end

# common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#10
module Datadog::Tracing::Contrib::ActionView::Utils
  private

  # in Rails the template name includes the template full path
  # and it's better to avoid storing such information. This method
  # returns the relative path from `views/` or the template name
  # if a `views/` folder is not in the template full path. A wrong
  # usage ensures that this method will not crash the tracing system.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#18
  def normalize_template_name(name); end

  class << self
    # in Rails the template name includes the template full path
    # and it's better to avoid storing such information. This method
    # returns the relative path from `views/` or the template name
    # if a `views/` folder is not in the template full path. A wrong
    # usage ensures that this method will not crash the tracing system.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#18
    def normalize_template_name(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#6
module Datadog::Tracing::Contrib::ActiveJob; end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#11
module Datadog::Tracing::Contrib::ActiveJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#14
class Datadog::Tracing::Contrib::ActiveJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveJob event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#13
    def included(base); end
  end
end

# Class methods for ActiveJob events.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#19
module Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#30
  def set_common_tags(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActiveJob events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#27
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#35
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#31
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#27
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#35
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#31
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#16
Datadog::Tracing::Contrib::ActiveJob::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for discard.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Discard
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Discard::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_at.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_retry.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for perform.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::Perform
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::Perform::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for retry_stopped.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#14
module Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#29
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#25
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#29
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#25
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#17
Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#8
module Datadog::Tracing::Contrib::ActiveJob::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#10
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#11
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#9
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#13
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_DISCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#14
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#15
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#16
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#17
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#27
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#19
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#28
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ERROR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#29
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_EXECUTIONS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#30
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#31
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#32
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#33
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_RETRY_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#34
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_SCHEDULED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#20
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_DISCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#21
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#22
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#23
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#24
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#25
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# Describes the ActiveJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#13
class Datadog::Tracing::Contrib::ActiveJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#16
Datadog::Tracing::Contrib::ActiveJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Active Job log injection wrapped around job execution
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/log_injection.rb#8
module Datadog::Tracing::Contrib::ActiveJob::LogInjection
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/log_injection.rb#9
    def included(base); end
  end
end

# Patcher enables patching of 'active_job' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#13
module Datadog::Tracing::Contrib::ActiveJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#27
  def inject_log_correlation; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#27
    def inject_log_correlation; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#6
module Datadog::Tracing::Contrib::ActiveModelSerializers; end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration; end

# Custom settings for the ActiveModelSerializers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Defines basic behaviors for an ActiveModelSerializers event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#13
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#14
    def included(base); end
  end
end

# Class methods for ActiveModelSerializers events.
# Note, they share the same process method and before_trace method.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#21
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#30
  def set_common_tags(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#22
  def span_options; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#54
  def resource(serializer); end
end

# Defines collection of instrumented ActiveModelSerializers events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#11
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render.active_model_serializers event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#13
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#25
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#33
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#29
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#20
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#25
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#33
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#29
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#20
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#16
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for !serialize.active_model_serializers event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#12
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#27
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#35
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#31
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#19
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#27
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#35
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#31
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#19
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActiveModelSerializers integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#9
module Datadog::Tracing::Contrib::ActiveModelSerializers::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#11
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#10
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#13
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#14
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_SERIALIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#16
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#17
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#18
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_SERIALIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#19
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_SERIALIZER = T.let(T.unsafe(nil), String)

# Description of ActiveModelSerializers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#12
class Datadog::Tracing::Contrib::ActiveModelSerializers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#34
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_model_serializers' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#12
module Datadog::Tracing::Contrib::ActiveModelSerializers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#12
module Datadog::Tracing::Contrib::ActiveRecord; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#7
module Datadog::Tracing::Contrib::ActiveRecord::Configuration; end

# The `makara` gem has the concept of **role**, which can be
# inferred from the configuration `name`, in the form of:
# `master/0`, `replica/0`, `replica/1`, etc.
# The first part of this string is the database role.
#
# This allows the matching of a connection based on its role,
# instead of connection-specific information.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#15
module Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#16
  def normalize_for_config(active_record_config); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#22
  def normalize_for_resolve(active_record_config); end
end

# Converts Symbols, Strings, and Hashes to a normalized connection settings Hash.
#
# When matching using a Hash, these are the valid fields:
# ```
# {
#   adapter: ...,
#   host: ...,
#   port: ...,
#   database: ...,
#   username: ...,
#   role: ...,
# }
# ```
#
# Partial matching is supported: not including certain fields or setting them to `nil`
# will cause them to matching all values for that field. For example: `database: nil`
# will match any database, given the remaining fields match.
#
# Any fields not listed above are discarded.
#
# When more than one configuration could be matched, the last one to match is selected,
# based on addition order (`#add`).
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#34
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  include ::Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver

  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#37
  def initialize(active_record_configuration = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#43
  def active_record_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#47
  def add(matcher, value); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#16
  def normalize_for_config(active_record_config); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  # Both resolvers perform the same operations for this implementation, but can be specialized
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#22
  def normalize_for_resolve(active_record_config); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#56
  def resolve(db_config); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#95
  def connection_resolver; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#80
  def parse_matcher(matcher); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#109
  def resolve_connection_key(key); end
end

# Custom settings for the ActiveRecord integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#14
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#10
module Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#11
    def included(base); end
  end
end

# Class methods for ActiveRecord events.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#17
module Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#22
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#18
  def span_options; end
end

# Defines collection of instrumented ActiveRecord events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#12
module Datadog::Tracing::Contrib::ActiveRecord::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for instantiation.active_record event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#14
module Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#26
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#34
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#30
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#21
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#26
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#34
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#30
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#21
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sql.active_record event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#16
module Datadog::Tracing::Contrib::ActiveRecord::Events::SQL
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#24
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#32
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#28
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#24
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#32
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#28
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#19
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::PAYLOAD_CACHE = T.let(T.unsafe(nil), String)

# ActiveRecord integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#9
module Datadog::Tracing::Contrib::ActiveRecord::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#11
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#10
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#13
Datadog::Tracing::Contrib::ActiveRecord::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#14
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#15
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_SQL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#16
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_TYPE_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_CACHED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#21
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#22
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#23
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_CLASS_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#24
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_RECORD_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#19
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_SQL = T.let(T.unsafe(nil), String)

# Describes the ActiveRecord integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#15
class Datadog::Tracing::Contrib::ActiveRecord::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#37
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#41
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#45
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#49
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#31
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#27
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#23
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_record' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#16
    def target_version; end
  end
end

# Common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Utils
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#22
    def adapter_host; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#14
    def adapter_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#26
    def adapter_port; end

    # Returns the connection configuration hash from the
    # current connection
    #
    # Since Rails 6.0, we have direct access to the object,
    # while older versions of Rails only provide us the
    # connection id.
    #
    # @see https://github.com/rails/rails/pull/34602
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#38
    def connection_config(connection = T.unsafe(nil), connection_id = T.unsafe(nil)); end

    # JRuby does not enable {ObjectSpace._id2ref} by default,
    # as it has large performance impact:
    # https://github.com/jruby/jruby/wiki/PerformanceTuning/cf155dd9#dont-enable-objectspace
    #
    # This fallback code does not support the makara gem,
    # as its connections don't live in the ActiveRecord
    # connection pool.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#64
    def connection_from_id(connection_id); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#18
    def database_name; end

    # @return [Hash]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#117
    def db_config(connection_pool); end

    # @return [Hash]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#101
    def default_connection_config; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Utils::EMPTY_CONFIG = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#13
module Datadog::Tracing::Contrib::ActiveRecord::Vendor; end

# Copy/paste from:
# https://github.com/rails/rails/blob/5-2-stable/activerecord/lib/active_record/connection_adapters/connection_specification.rb
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#22
module Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#23
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification
  # @return [ConnectionSpecification] a new instance of ConnectionSpecification
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#26
  def initialize(name, config, adapter_method); end

  # Returns the value of attribute adapter_method.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#24
  def adapter_method; end

  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#24
  def config; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#24
  def name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#34
  def to_hash; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#30
  def initialize_dup(original); end
end

# Expands a connection string into a hash.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#39
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  # == Example
  #
  #   url = "postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000"
  #   ConnectionUrlResolver.new(url).to_hash
  #   # => {
  #     "adapter"  => "postgresql",
  #     "host"     => "localhost",
  #     "port"     => 9000,
  #     "database" => "foo_test",
  #     "username" => "foo",
  #     "password" => "bar",
  #     "pool"     => "5",
  #     "timeout"  => "3000"
  #   }
  #
  # @return [ConnectionUrlResolver] a new instance of ConnectionUrlResolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#54
  def initialize(url); end

  # Converts the given URL to a full connection hash.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#68
  def to_hash; end

  private

  # Returns name of the database.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#114
  def database_from_path; end

  # Converts the query parameters of the URI into a hash.
  #
  #   "localhost?pool=5&reaping_frequency=2"
  #   # => { "pool" => "5", "reaping_frequency" => "2" }
  #
  # returns empty hash if no query present.
  #
  #   "localhost"
  #   # => {}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#93
  def query_hash; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#97
  def raw_config; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#76
  def uri; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#80
  def uri_parser; end
end

# Builds a ConnectionSpecification from user input.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#132
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification::Resolver
  # Accepts a hash two layers deep, keys on the first layer represent
  # environments such as "production". Keys must be strings.
  #
  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#137
  def initialize(configurations); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#133
  def configurations; end

  # Returns a hash with database connection information.
  #
  # == Examples
  #
  # Full hash Configuration.
  #
  #   configurations = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3"}
  #
  # Initialized with URL configuration strings.
  #
  #   configurations = { "production" => "postgresql://localhost/foo" }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#157
  def resolve(config); end

  # Expands each key in @configurations hash into fully resolved hash
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#168
  def resolve_all; end

  # Returns an instance of ConnectionSpecification for a given adapter.
  # Accepts a hash one layer deep that contains all connection information.
  #
  # == Example
  #
  #   config = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   spec = Resolver.new(config).spec(:production)
  #   spec.adapter_method
  #   # => "sqlite3_connection"
  #   spec.config
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" }
  #
  # @raise [AdapterNotSpecified]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#197
  def spec(config); end

  private

  # Returns fully resolved connection, accepts hash, string or symbol.
  # Always returns a hash.
  #
  # == Examples
  #
  # Symbol representing current environment.
  #
  #   Resolver.new("production" => {}).resolve_connection(:production)
  #   # => {}
  #
  # One layer deep hash of connection values.
  #
  #   Resolver.new({}).resolve_connection("adapter" => "sqlite3")
  #   # => { "adapter" => "sqlite3" }
  #
  # Connection URL.
  #
  #   Resolver.new({}).resolve_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#254
  def resolve_connection(spec); end

  # Accepts a hash. Expands the "url" key that contains a
  # URL database connection to a full connection
  # hash and merges with the rest of the hash.
  # Connection details inside of the "url" key win any merge conflicts
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#284
  def resolve_hash_connection(spec); end

  # Takes the environment such as +:production+ or +:development+.
  # This requires that the @configurations was initialized with a key that
  # matches.
  #
  #   Resolver.new("production" => {}).resolve_symbol_connection(:production)
  #   # => {}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#272
  def resolve_symbol_connection(spec); end

  # Takes a connection URL.
  #
  #   Resolver.new({}).resolve_url_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#297
  def resolve_url_connection(url); end
end

# Copy/paste from:
# https://github.com/rails/rails/blob/5-2-stable/activerecord/lib/active_record/connection_handling.rb
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#16
module Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionHandling; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#6
module Datadog::Tracing::Contrib::ActiveSupport; end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Cache; end

# Defines instrumentation for ActiveSupport caching
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#108
  def enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#53
  def finish_trace_cache(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#80
  def finish_trace_cache_multi(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#17
  def start_trace_cache(payload); end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#108
    def enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#53
    def finish_trace_cache(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#80
    def finish_trace_cache_multi(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#17
    def start_trace_cache(payload); end
  end
end

# Defines instrumentation for ActiveSupport cache deleting
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#253
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Delete
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#254
  def delete(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache fetching
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#159
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Fetch
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#160
  def fetch(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache fetching of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#182
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::FetchMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#183
  def fetch_multi(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache reading
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#113
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Read
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#114
  def read(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache reading of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#136
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::ReadMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#137
  def read_multi(*keys, &block); end
end

# Defines instrumentation for ActiveSupport cache writing
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#207
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Write
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#208
  def write(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache writing of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#230
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::WriteMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#231
  def write_multi(hash, options = T.unsafe(nil)); end
end

# Patcher enables patching of 'active_support' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#12
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#31
  def cache_store_class(meth); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#65
  def patch_cache_store_delete; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
  def patch_cache_store_fetch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
  def patch_cache_store_fetch_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#35
  def patch_cache_store_read; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#39
  def patch_cache_store_read_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#54
  def patch_cache_store_write; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#58
  def patch_cache_store_write_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#31
    def cache_store_class(meth); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#65
    def patch_cache_store_delete; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
    def patch_cache_store_fetch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
    def patch_cache_store_fetch_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#35
    def patch_cache_store_read; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#39
    def patch_cache_store_read_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#54
    def patch_cache_store_write; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#58
    def patch_cache_store_write_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#17
    def target_version; end
  end
end

# Support for Redis with ActiveSupport
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis; end

# Patching behavior for Redis with ActiveSupport
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#31
  def cache_store_class(meth); end

  # For Rails < 5.2 w/ redis-activesupport...
  # When Redis is used, we can't only patch Cache::Store as it is
  # Cache::RedisStore, a sub-class of it that is used, in practice.
  # We need to do a per-method monkey patching as some of them might
  # be redefined, and some of them not. The latest version of redis-activesupport
  # redefines write but leaves untouched read and delete:
  # https://github.com/redis-store/redis-activesupport/blob/v4.1.5/lib/active_support/cache/redis_store.rb
  #
  # For Rails >= 5.2 w/o redis-activesupport...
  # ActiveSupport includes a Redis cache store internally, and does not require these overrides.
  # https://github.com/rails/rails/blob/master/activesupport/lib/active_support/cache/redis_cache_store.rb
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#25
  def patch_redis?(meth); end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveSupport::Configuration; end

# Custom settings for the ActiveSupport integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveSupport::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def cache_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def cache_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# ActiveSupport integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#9
module Datadog::Tracing::Contrib::ActiveSupport::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#11
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#12
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#10
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#13
Datadog::Tracing::Contrib::ActiveSupport::Ext::QUANTIZE_CACHE_MAX_KEY_SIZE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#14
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_DELETE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#15
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_GET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#16
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MGET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#18
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#17
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_SET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#19
Datadog::Tracing::Contrib::ActiveSupport::Ext::SERVICE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#20
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#21
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#22
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_BACKEND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#23
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#24
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY_MULTI = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#25
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#26
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_OPERATION_CACHE = T.let(T.unsafe(nil), String)

# Describes the ActiveSupport integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#14
class Datadog::Tracing::Contrib::ActiveSupport::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#36
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#40
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#44
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#26
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#22
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#17
Datadog::Tracing::Contrib::ActiveSupport::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#7
module Datadog::Tracing::Contrib::ActiveSupport::Notifications; end

# Defines behaviors for an ActiveSupport::Notifications event.
# Compose this into a module or class, then define
# #event_name, #span_name, and #process. You can then
# invoke Event.subscribe! to more easily subscribe to an event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#15
    def included(base); end
  end
end

# Redefines some class behaviors for a Subscriber to make
# it a bit simpler for an Event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#23
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#61
  def payload_exception(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#56
  def report_if_exception(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#52
  def span_options; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#37
  def subscribe(pattern = T.unsafe(nil), span_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Publicly exposes protected method `subscribe!`
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#25
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#29
  def subscription(span_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#48
  def supported?; end
end

# For classes that listen to ActiveSupport::Notification events.
# Creates subscriptions that are wrapped with tracing.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#14
    def included(base); end
  end
end

# Class methods that are implemented in the inheriting class.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#19
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  # Returns whether subscriptions have been activated, via #subscribe!
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#26
  def subscribed?; end

  # Returns a list of subscriptions created for this class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#21
  def subscriptions; end

  protected

  # Defines a callback for when subscribe! is called.
  # Should contain subscription setup, defined by the inheriting class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#34
  def on_subscribe(&block); end

  # Creates a subscription and immediately activates it.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#48
  def subscribe(pattern, span_name, options = T.unsafe(nil), &block); end

  # Runs the on_subscribe callback once, to activate subscriptions.
  # Should be triggered by the inheriting class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#40
  def subscribe!; end

  # Creates a subscription without activating it.
  # Subscription is added to the inheriting class' list of subscriptions.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#56
  def subscription(span_name, options = T.unsafe(nil), &block); end

  private

  # Returns the value of attribute on_subscribe_block.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#64
  def on_subscribe_block; end

  # Returns the value of attribute subscribed.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#64
  def subscribed; end
end

# An ActiveSupport::Notification subscription that wraps events with tracing.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#9
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription
  # @raise [ArgumentError]
  # @return [Subscription] a new instance of Subscription
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#14
  def initialize(span_name, options, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#43
  def after_trace(&block); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#39
  def before_trace(&block); end

  # ActiveSupport 3.x calls this
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#24
  def call(name, start, finish, id, payload); end

  # ActiveSupport 4+ calls this on finish
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#35
  def finish(name, id, payload); end

  # Returns the value of attribute options.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def options=(_arg0); end

  # Returns the value of attribute span_name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_name; end

  # Sets the attribute span_name
  #
  # @param value the value to set the attribute span_name to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#10
  def span_name=(_arg0); end

  # ActiveSupport 4+ calls this on start
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#30
  def start(name, id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#47
  def subscribe(pattern); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#54
  def unsubscribe(pattern); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#62
  def unsubscribe_all; end

  protected

  # Returns the value of attribute callbacks.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#71
  def callbacks; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#87
  def finish_span(name, id, payload, finish = T.unsafe(nil)); end

  # Returns the value of attribute handler.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#71
  def handler; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#75
  def start_span(name, id, payload, start = T.unsafe(nil)); end

  # Pattern => ActiveSupport:Notifications::Subscribers
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#104
  def subscribers; end
end

# Wrapper for subscription callbacks
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#130
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Callbacks
  # @return [Callbacks] a new instance of Callbacks
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#133
  def initialize; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#137
  def add(key, &block); end

  # Returns the value of attribute blocks.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#131
  def blocks; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#141
  def run(event, key, *args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#155
  def blocks_for(key); end
end

# Wrapper for subscription handler
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#109
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Handler
  # @return [Handler] a new instance of Handler
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#112
  def initialize(&block); end

  # Returns the value of attribute block.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#110
  def block; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#116
  def run(span, name, id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#124
  def run!(*args); end
end

# Patcher enables patching of 'active_support' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#16
    def target_version; end
  end
end

# Defines analytics behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#10
module Datadog::Tracing::Contrib::Analytics
  private

  # Checks whether analytics should be enabled.
  # `flag` is a truthy/falsey value that represents a setting on the integration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#15
  def enabled?(flag = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#23
  def set_measured(span, value = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#19
  def set_sample_rate(span, sample_rate); end

  class << self
    # Checks whether analytics should be enabled.
    # `flag` is a truthy/falsey value that represents a setting on the integration.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#15
    def enabled?(flag = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#23
    def set_measured(span, value = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#19
    def set_sample_rate(span, sample_rate); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#6
module Datadog::Tracing::Contrib::Aws; end

# source://ddtrace//lib/datadog/tracing/contrib/aws/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Aws::Configuration; end

# Custom settings for the AWS integration
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Aws::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# AWS integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#9
module Datadog::Tracing::Contrib::Aws::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#14
Datadog::Tracing::Contrib::Aws::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#12
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#13
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#10
Datadog::Tracing::Contrib::Aws::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#11
Datadog::Tracing::Contrib::Aws::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#15
Datadog::Tracing::Contrib::Aws::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#16
Datadog::Tracing::Contrib::Aws::Ext::TAG_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#17
Datadog::Tracing::Contrib::Aws::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#18
Datadog::Tracing::Contrib::Aws::Ext::TAG_DEFAULT_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#19
Datadog::Tracing::Contrib::Aws::Ext::TAG_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#20
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#21
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#22
Datadog::Tracing::Contrib::Aws::Ext::TAG_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#23
Datadog::Tracing::Contrib::Aws::Ext::TAG_REGION = T.let(T.unsafe(nil), String)

# Description of AWS integration
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#12
class Datadog::Tracing::Contrib::Aws::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#36
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#40
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#32
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#28
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#15
Datadog::Tracing::Contrib::Aws::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'aws' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#11
module Datadog::Tracing::Contrib::Aws::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#32
  def add_plugin(*targets); end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#50
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#36
  def loaded_constants; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#32
    def add_plugin(*targets); end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#50
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#36
    def loaded_constants; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#8
module Datadog::Tracing::Contrib::ConcurrentRuby; end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Configuration; end

# Custom settings for the ConcurrentRuby integration
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ConcurrentRuby::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# ConcurrentRuby integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#9
module Datadog::Tracing::Contrib::ConcurrentRuby::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#10
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#11
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Describes the ConcurrentRuby integration
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#12
class Datadog::Tracing::Contrib::ConcurrentRuby::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#15
Datadog::Tracing::Contrib::ConcurrentRuby::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'Future' class.
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#20
  def patch; end

  # Propagate tracing context in Concurrent::Future
  #
  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#26
  def patch_future; end

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # Propagate tracing context in Concurrent::Future
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#26
    def patch_future; end

    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#16
    def target_version; end
  end
end

# Defines configurable behavior for integrations.
#
# This module is responsible for coordination between
# the configuration resolver and default configuration
# fallback.
#
# source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#14
module Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#15
    def included(base); end
  end
end

# Configurable instance behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#20
module Datadog::Tracing::Contrib::Configurable::InstanceMethods
  # Get matching configuration by matcher.
  # If no match, returns the default configuration instance.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#23
  def configuration(matcher = T.unsafe(nil)); end

  # Returns all registered matchers and their respective configurations.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#38
  def configurations; end

  # Create or update configuration associated with `matcher` with
  # the provided `options` and `&block`.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#44
  def configure(matcher = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the integration-specific configuration object.
  #
  # If one does not exist, invoke {.new_configuration} a memoize
  # its value.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] the memoized integration-specific settings object
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#69
  def default_configuration; end

  # Resets all configuration options
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#58
  def reset_configuration!; end

  # Resolves the matching configuration for integration-specific value.
  # If no match, returns the default configuration instance.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#31
  def resolve(value); end

  protected

  # Returns a new configuration object for this integration.
  #
  # This method normally needs to be overridden for each integration
  # as their settings, defaults and environment variables are
  # specific for each integration.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] a new, integration-specific settings object
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#82
  def new_configuration; end

  # Overridable configuration resolver.
  #
  # This resolver is responsible for performing the matching
  # of `#configure(matcher)` `matcher`s with `value`s provided
  # in subsequent calls to `#resolve(value)`.
  #
  # By default, the `value` in `#resolve(value)` must be equal
  # to the `matcher` object provided in `#configure(matcher)`
  # to retrieve the associated configuration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#95
  def resolver; end
end

# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#6
module Datadog::Tracing::Contrib::Configuration; end

# Resolves an integration-specific matcher to an associated
# object.
#
# Integrations that perform any configuration matching
# based on patterns might want to override this class
# to provide richer matching. For example, match configuration
# based on: HTTP request parameters, request headers,
# async queue name.
#
# When overriding this class, for simple use cases, only
# overriding `#parse_matcher` might suffice. See
# `#parse_matcher`'s documentation for more information.
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#19
class Datadog::Tracing::Contrib::Configuration::Resolver
  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#22
  def initialize; end

  # Adds a new `matcher`, associating with it a `value`.
  #
  # This `value` is returned when `#resolve` is called
  # with a matching value for this matcher. When multiple
  # matchers would match, `#resolve` returns the latest
  # added one.
  #
  # The `matcher` can be transformed internally by the
  # `#parse_matcher` method before being stored.
  #
  # The `value` can also be retrieved by calling `#get`
  # with the same `matcher` added by this method.
  #
  # @param matcher [Object] integration-specific matcher
  # @param value [Object] arbitrary value to be associated with `matcher`
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#41
  def add(matcher, value); end

  # Returns the value of attribute configurations.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#20
  def configurations; end

  # Retrieves the stored value for a `matcher`
  # previously stored by `#add`.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] previously stored `value` from `#add`, or `nil` if not found
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#50
  def get(matcher); end

  # Matches an arbitrary value against the configured
  # matchers previously set with `#add`.
  #
  # If multiple matchers would match, returns the latest one.
  #
  # @param value [Object] integration-specific value
  # @return [Object] matching `value` configured at `#add`, or `nil` if none match
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#61
  def resolve(value); end

  protected

  # Converts `matcher` into an appropriate key
  # for the internal Hash storage.
  #
  # It's recommended to override this method,
  # instead of the public methods, if the
  # integration can simply convert both
  # `matcher` (provided to `#add`) and `value`
  # (provided to `#resolve`) to the same value.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] processed matcher
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#78
  def parse_matcher(matcher); end
end

# Resolves a value to a configuration key
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#10
module Datadog::Tracing::Contrib::Configuration::Resolvers; end

# Matches Strings and Regexps against `object.to_s` objects
# and Procs against plain objects.
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#13
class Datadog::Tracing::Contrib::Configuration::Resolvers::PatternResolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#14
  def resolve(value); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#31
  def parse_matcher(matcher); end
end

# Common settings for all integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#32
  def [](name); end

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#36
  def []=(name, value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Tracing::Contrib::Configuration::Settings] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#24
  def configure(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#15
Datadog::Tracing::Contrib::Configuration::Settings::DEPRECATION_WARN_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#6
module Datadog::Tracing::Contrib::Dalli; end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Dalli::Configuration; end

# Custom settings for the Dalli integration
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Dalli::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Dalli integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#9
module Datadog::Tracing::Contrib::Dalli::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#15
Datadog::Tracing::Contrib::Dalli::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#11
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#12
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#10
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#13
Datadog::Tracing::Contrib::Dalli::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#14
Datadog::Tracing::Contrib::Dalli::Ext::QUANTIZE_MAX_CMD_LENGTH = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#16
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#17
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#18
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#19
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#20
Datadog::Tracing::Contrib::Dalli::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#21
Datadog::Tracing::Contrib::Dalli::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instruments every interaction with the memcached server
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#14
module Datadog::Tracing::Contrib::Dalli::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#15
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#20
module Datadog::Tracing::Contrib::Dalli::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#21
  def request(op, *args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#53
  def datadog_configuration; end
end

# Description of Dalli integration
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#12
class Datadog::Tracing::Contrib::Dalli::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#41
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#45
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#29
    def compatible?; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#33
    def dalli_class; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#16
Datadog::Tracing::Contrib::Dalli::Integration::DALLI_PROTOCOL_BINARY_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#15
Datadog::Tracing::Contrib::Dalli::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'dalli' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#12
module Datadog::Tracing::Contrib::Dalli::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#17
    def target_version; end
  end
end

# Quantize contains dalli-specic quantization tools.
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#10
module Datadog::Tracing::Contrib::Dalli::Quantize
  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#13
  def format_command(operation, args); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#13
    def format_command(operation, args); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#6
module Datadog::Tracing::Contrib::DelayedJob; end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#11
module Datadog::Tracing::Contrib::DelayedJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#14
class Datadog::Tracing::Contrib::DelayedJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def client_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def client_service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# DelayedJob integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#9
module Datadog::Tracing::Contrib::DelayedJob::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#11
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#12
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#10
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#14
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#13
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#15
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#16
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#20
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#17
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#21
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#22
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#23
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#18
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#19
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#12
class Datadog::Tracing::Contrib::DelayedJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#15
Datadog::Tracing::Contrib::DelayedJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'delayed_job' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#10
module Datadog::Tracing::Contrib::DelayedJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
  def add_instrumentation(klass); end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
  def patch_server_internals; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
    def add_instrumentation(klass); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
    def patch_server_internals; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#6
module Datadog::Tracing::Contrib::Elasticsearch; end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Elasticsearch::Configuration; end

# Custom settings for the Elasticsearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Elasticsearch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Elasticsearch integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#9
module Datadog::Tracing::Contrib::Elasticsearch::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#14
Datadog::Tracing::Contrib::Elasticsearch::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#12
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#13
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#10
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#11
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#15
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#16
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_TYPE_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#17
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#21
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#18
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#22
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#19
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#24
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#20
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_URL = T.let(T.unsafe(nil), String)

# Description of Elasticsearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#12
class Datadog::Tracing::Contrib::Elasticsearch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#35
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#29
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#15
Datadog::Tracing::Contrib::Elasticsearch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'elasticsearch' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#15
module Datadog::Tracing::Contrib::Elasticsearch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#24
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#38
  def patch_elasticsearch_transport_client; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#20
  def target_version; end

  # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
  #
  # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
  #
  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#142
  def transport_module; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#38
    def patch_elasticsearch_transport_client; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#20
    def target_version; end

    # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
    #
    # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#142
    def transport_module; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#32
Datadog::Tracing::Contrib::Elasticsearch::Patcher::SELF_DEPRECATION_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#6
module Datadog::Tracing::Contrib::Ethon; end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Ethon::Configuration; end

# Custom settings for the Ethon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Ethon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Ethon integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#9
module Datadog::Tracing::Contrib::Ethon::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#14
Datadog::Tracing::Contrib::Ethon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#12
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#13
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#10
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#11
Datadog::Tracing::Contrib::Ethon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#17
Datadog::Tracing::Contrib::Ethon::Ext::NOT_APPLICABLE_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#16
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#15
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#18
Datadog::Tracing::Contrib::Ethon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#20
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#19
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Ethon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#13
class Datadog::Tracing::Contrib::Ethon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#16
Datadog::Tracing::Contrib::Ethon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'ethon' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#10
module Datadog::Tracing::Contrib::Ethon::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#6
module Datadog::Tracing::Contrib::Excon; end

# source://ddtrace//lib/datadog/tracing/contrib/excon/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Excon::Configuration; end

# Custom settings for the Excon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Excon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Excon integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#9
module Datadog::Tracing::Contrib::Excon::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#14
Datadog::Tracing::Contrib::Excon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#12
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#13
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#10
Datadog::Tracing::Contrib::Excon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#11
Datadog::Tracing::Contrib::Excon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#15
Datadog::Tracing::Contrib::Excon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#16
Datadog::Tracing::Contrib::Excon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#17
Datadog::Tracing::Contrib::Excon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Excon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#13
class Datadog::Tracing::Contrib::Excon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#16
Datadog::Tracing::Contrib::Excon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'excon' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#10
module Datadog::Tracing::Contrib::Excon::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#24
  def add_middleware; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#24
    def add_middleware; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#15
    def target_version; end
  end
end

# Contrib specific constants
#
# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#7
module Datadog::Tracing::Contrib::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#9
module Datadog::Tracing::Contrib::Ext::DB; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#10
Datadog::Tracing::Contrib::Ext::DB::TAG_INSTANCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#14
Datadog::Tracing::Contrib::Ext::DB::TAG_ROW_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#13
Datadog::Tracing::Contrib::Ext::DB::TAG_STATEMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#12
Datadog::Tracing::Contrib::Ext::DB::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#11
Datadog::Tracing::Contrib::Ext::DB::TAG_USER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#17
module Datadog::Tracing::Contrib::Ext::RPC; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#20
Datadog::Tracing::Contrib::Ext::RPC::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#19
Datadog::Tracing::Contrib::Ext::RPC::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#18
Datadog::Tracing::Contrib::Ext::RPC::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Extensions that can be added to the base library
# Adds registry, configuration access for integrations.
#
# DEV: The Registry should probably be part of the core tracer
# as it represents a global tracer repository that is strongly intertwined
# with the tracer lifecycle and deeply modifies the tracer initialization
# process.
# Most of this file should probably live inside the tracer core.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#20
module Datadog::Tracing::Contrib::Extensions
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#21
    def extend!; end
  end
end

# Configuration methods for Datadog module.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#58
module Datadog::Tracing::Contrib::Extensions::Configuration
  # TODO: Is is not possible to separate this configuration method
  # TODO: from core ddtrace parts ()e.g. the registry).
  # TODO: Today this method sits here in the `Datadog::Tracing::Contrib::Extensions` namespace
  # TODO: but cannot empirically constraints to the contrib domain only.
  # TODO: We should promote most of this logic to core parts of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#64
  def configure(&block); end
end

# Extensions for Datadog::Core::Configuration::Settings
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#110
module Datadog::Tracing::Contrib::Extensions::Configuration::Settings
  # For the provided `integration_name`, resolves a matching configuration
  # for the provided integration from an integration-specific `key`.
  #
  # How the matching is performed is integration-specific.
  #
  # @example
  #   Datadog.configuration.tracing[:integration_name]
  # @example
  #   Datadog.configuration.tracing[:integration_name][:sub_configuration]
  # @param integration_name [Symbol] the integration name
  # @param key [Object] the integration-specific lookup key
  # @return [Datadog::Tracing::Contrib::Configuration::Settings]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#156
  def [](integration_name, key = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#178
  def fetch_integration(name); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#188
  def ignore_integration_load_errors=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#184
  def ignore_integration_load_errors?; end

  # Applies instrumentation for the provided `integration_name`.
  #
  # Options may be provided, that are specific to that instrumentation.
  # See the instrumentation's settings file for a list of available options.
  #
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name }
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name, option_key: :option_value }
  # @param integration_name [Symbol] the integration name
  # @param options [Hash] the integration-specific configuration settings
  # @return [Datadog::Tracing::Contrib::Integration]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#125
  def instrument(integration_name, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#167
  def instrumented_integrations; end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#162
  def integrations_pending_activation; end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#172
  def reset!; end

  # Applies instrumentation for the provided `integration_name`.
  #
  # Options may be provided, that are specific to that instrumentation.
  # See the instrumentation's settings file for a list of available options.
  # TODO: Deprecate in the next major version, as `instrument` better describes this method's purpose
  #
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name }
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name, option_key: :option_value }
  # @param integration_name [Symbol] the integration name
  # @param options [Hash] the integration-specific configuration settings
  # @return [Datadog::Tracing::Contrib::Integration]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#125
  def use(integration_name, options = T.unsafe(nil), &block); end
end

# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#111
class Datadog::Tracing::Contrib::Extensions::Configuration::Settings::InvalidIntegrationError < ::StandardError; end

# Helper methods for Datadog module.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#33
module Datadog::Tracing::Contrib::Extensions::Helpers
  # The global integration registry.
  #
  # This registry holds a reference to all integrations available
  # to the tracer.
  #
  # Integrations registered in the {.registry} can be activated as follows:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :my_registered_integration, **my_options
  # end
  # ```
  #
  # New integrations can be registered by implementing the {Datadog::Tracing::Contrib::Integration} interface.
  #
  # @return [Datadog::Tracing::Contrib::Registry]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#52
  def registry; end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#6
module Datadog::Tracing::Contrib::Faraday; end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Faraday::Configuration; end

# Custom settings for the Faraday integration
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Faraday::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#14
Datadog::Tracing::Contrib::Faraday::Configuration::Settings::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# Handles installation of our middleware if the user has *not*
# already explicitly configured our middleware for this correction.
#
# Wraps Faraday::Connection#initialize:
# https://github.com/lostisland/faraday/blob/ff9dc1d1219a1bbdba95a9a4cf5d135b97247ee2/lib/faraday/connection.rb#L62-L92
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/connection.rb#12
module Datadog::Tracing::Contrib::Faraday::Connection
  # source://ddtrace//lib/datadog/tracing/contrib/faraday/connection.rb#13
  def initialize(*args, &block); end
end

# Faraday integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#9
module Datadog::Tracing::Contrib::Faraday::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#14
Datadog::Tracing::Contrib::Faraday::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#12
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#13
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#10
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#11
Datadog::Tracing::Contrib::Faraday::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#15
Datadog::Tracing::Contrib::Faraday::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#16
Datadog::Tracing::Contrib::Faraday::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#17
Datadog::Tracing::Contrib::Faraday::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Faraday integration
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#13
class Datadog::Tracing::Contrib::Faraday::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#16
Datadog::Tracing::Contrib::Faraday::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'faraday' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#13
module Datadog::Tracing::Contrib::Faraday::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#33
  def add_default_middleware!; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#29
  def register_middleware!; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#33
    def add_default_middleware!; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#29
    def register_middleware!; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#18
    def target_version; end
  end
end

# Handles installation of our middleware if the user has *not*
# already explicitly configured it for this correction.
#
# RackBuilder class was introduced in faraday 0.9.0:
# https://github.com/lostisland/faraday/commit/77d7546d6d626b91086f427c56bc2cdd951353b3
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/rack_builder.rb#12
module Datadog::Tracing::Contrib::Faraday::RackBuilder
  # source://ddtrace//lib/datadog/tracing/contrib/faraday/rack_builder.rb#13
  def adapter(*args); end
end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#6
module Datadog::Tracing::Contrib::GRPC; end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#11
module Datadog::Tracing::Contrib::GRPC::Configuration; end

# Custom settings for the gRPC integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#14
class Datadog::Tracing::Contrib::GRPC::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# gRPC integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#9
module Datadog::Tracing::Contrib::GRPC::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#14
Datadog::Tracing::Contrib::GRPC::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#12
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#13
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#10
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#11
Datadog::Tracing::Contrib::GRPC::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#15
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#16
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#17
Datadog::Tracing::Contrib::GRPC::Ext::TAG_CLIENT_DEADLINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#18
Datadog::Tracing::Contrib::GRPC::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#19
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#20
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#22
Datadog::Tracing::Contrib::GRPC::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Description of gRPC integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#12
class Datadog::Tracing::Contrib::GRPC::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#15
Datadog::Tracing::Contrib::GRPC::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grpc' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#11
module Datadog::Tracing::Contrib::GRPC::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#27
  def prepend_interceptor; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#27
    def prepend_interceptor; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#6
module Datadog::Tracing::Contrib::Grape; end

# source://ddtrace//lib/datadog/tracing/contrib/grape/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Grape::Configuration; end

# Custom settings for the Grape integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Grape::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_statuses; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_statuses=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Endpoint module includes a list of subscribers to create
# traces when a Grape endpoint is hit
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#14
module Datadog::Tracing::Contrib::Grape::Endpoint
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#133
    def endpoint_render(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#69
    def endpoint_run(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#157
    def endpoint_run_filters(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#38
    def endpoint_start_process(_name, _start, _finish, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#114
    def endpoint_start_render(*_arg0); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#19
    def subscribe; end

    private

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#220
    def analytics_enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#224
    def analytics_sample_rate; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#197
    def api_view(api); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#242
    def datadog_configuration; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#237
    def enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#208
    def endpoint_expand_path(endpoint); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#228
    def exception_is_error?(exception); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#216
    def service_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#16
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#15
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RUN = T.let(T.unsafe(nil), String)

# Grape integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#9
module Datadog::Tracing::Contrib::Grape::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#11
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#12
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#10
Datadog::Tracing::Contrib::Grape::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#13
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#14
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#15
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#16
Datadog::Tracing::Contrib::Grape::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#17
Datadog::Tracing::Contrib::Grape::Ext::TAG_FILTER_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#18
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#19
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#20
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#21
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#23
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#22
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# Instrumentation for Grape::Endpoint
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#8
module Datadog::Tracing::Contrib::Grape::Instrumentation
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#9
    def included(base); end
  end
end

# ClassMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#15
module Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#16
  def generate_api_method(*params, &block); end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#27
module Datadog::Tracing::Contrib::Grape::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#28
  def run(*args); end
end

# Description of Grape integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#12
class Datadog::Tracing::Contrib::Grape::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#15
Datadog::Tracing::Contrib::Grape::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grape' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#13
module Datadog::Tracing::Contrib::Grape::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#6
module Datadog::Tracing::Contrib::GraphQL; end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#10
module Datadog::Tracing::Contrib::GraphQL::Configuration; end

# Custom settings for the GraphQL integration
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#13
class Datadog::Tracing::Contrib::GraphQL::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def schemas; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def schemas=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# GraphQL integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#9
module Datadog::Tracing::Contrib::GraphQL::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#11
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#12
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#10
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#13
Datadog::Tracing::Contrib::GraphQL::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#14
Datadog::Tracing::Contrib::GraphQL::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# Description of GraphQL integration
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#12
class Datadog::Tracing::Contrib::GraphQL::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#15
Datadog::Tracing::Contrib::GraphQL::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for `graphql` through the GraphQL tracing framework
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#11
module Datadog::Tracing::Contrib::GraphQL::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#66
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#20
  def patch; end

  # Before https://github.com/rmosolgo/graphql-ruby/pull/4038 was introduced,
  # we were left with incompatibilities between ddtrace 1.0 and older graphql gem versions.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#60
  def patch_legacy_gem!; end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#28
  def patch_schema!(schema); end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#66
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # Before https://github.com/rmosolgo/graphql-ruby/pull/4038 was introduced,
    # we were left with incompatibilities between ddtrace 1.0 and older graphql gem versions.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#60
    def patch_legacy_gem!; end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#28
    def patch_schema!(schema); end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#16
    def target_version; end
  end
end

# Patches the graphql gem to support ddtrace 1.0.
# This is not necessary in versions containing https://github.com/rmosolgo/graphql-ruby/pull/4038.
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#72
module Datadog::Tracing::Contrib::GraphQL::Patcher::PatchLegacyGem
  # Ensure resource name is not left as `nil`.
  # This is fixed in graphql > 2.0.6.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#82
  def fallback_transaction_name(context); end

  # Ensure invocation to #trace method targets the new namespaced public API object,
  # instead of the old global Datadog.trace.
  # This is fixed in graphql > 2.0.3.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#76
  def tracer; end
end

# Datadog Net/HTTP integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#9
module Datadog::Tracing::Contrib::HTTP
  extend ::Datadog::Tracing::Contrib::HTTP::CircuitBreaker
end

# HTTP integration circuit breaker behavior
# For avoiding recursive traces.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#11
module Datadog::Tracing::Contrib::HTTP::CircuitBreaker
  # We don't want to trace our own call to the API (they use net/http)
  # TODO: We don't want this kind of soft-check on HTTP requests.
  #       Remove this when transport implements its own "skip tracing" mechanism.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#26
  def datadog_http_request?(request); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#34
  def should_skip_distributed_tracing?(client_config); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#12
  def should_skip_tracing?(request); end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/configuration/settings.rb#10
module Datadog::Tracing::Contrib::HTTP::Configuration; end

# Custom settings for the HTTP integration
#
# source://ddtrace//lib/datadog/tracing/contrib/http/configuration/settings.rb#13
class Datadog::Tracing::Contrib::HTTP::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#10
module Datadog::Tracing::Contrib::HTTP::Distributed; end

# Retrieves HTTP headers from carrier.
# Headers will also match if Rack-formatted:
# 'my-header' will match 'my-header' and 'HTTP_MY_HEADER'.
#
# In case both variants are present, the verbatim match will be used.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#16
class Datadog::Tracing::Contrib::HTTP::Distributed::Fetcher < ::Datadog::Tracing::Distributed::Fetcher
  # DEV: Should we try to parse both verbatim an Rack-formatted headers,
  # DEV: given Rack-formatted is the most common format in Ruby?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#19
  def [](name); end
end

# Extracts and injects propagation through HTTP headers.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/propagation.rb#18
class Datadog::Tracing::Contrib::HTTP::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/distributed/propagation.rb#19
  def initialize; end
end

# HTTP integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#9
module Datadog::Tracing::Contrib::HTTP::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#15
Datadog::Tracing::Contrib::HTTP::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#12
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#13
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#10
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#14
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#11
Datadog::Tracing::Contrib::HTTP::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#16
Datadog::Tracing::Contrib::HTTP::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#17
Datadog::Tracing::Contrib::HTTP::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#18
Datadog::Tracing::Contrib::HTTP::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Net::HTTP
#
# source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#14
module Datadog::Tracing::Contrib::HTTP::Instrumentation
  class << self
    # Span hook invoked after request is completed.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#20
    def after_request(&block); end

    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#15
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#31
module Datadog::Tracing::Contrib::HTTP::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#101
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#72
  def annotate_span_with_request!(span, request, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#93
  def annotate_span_with_response!(span, response, request_options); end

  # :yield: +response+
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#35
  def request(req, body = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#105
  def set_analytics_sample_rate(span, request_options); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#125
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#129
  def analytics_sample_rate(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#121
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#113
  def host_and_port(request); end
end

# Description of HTTP integration
#
# source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#18
class Datadog::Tracing::Contrib::HTTP::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#34
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#38
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#42
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#30
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#26
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#21
Datadog::Tracing::Contrib::HTTP::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'net/http' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#13
module Datadog::Tracing::Contrib::HTTP::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch if needed
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#23
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#18
  def target_version; end

  class << self
    # patch applies our patch if needed
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#6
module Datadog::Tracing::Contrib::Hanami; end

# Hanami Instrumentation for `hanami.action`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#12
class Datadog::Tracing::Contrib::Hanami::ActionTracer
  # @return [ActionTracer] a new instance of ActionTracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#13
  def initialize(app, action); end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#18
  def call(env); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#40
  def configuration; end
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Hanami::Configuration; end

# Configuration for Hanami instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Hanami::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Hanami integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#9
module Datadog::Tracing::Contrib::Hanami::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#10
Datadog::Tracing::Contrib::Hanami::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#12
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#14
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#13
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ROUTING = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#16
Datadog::Tracing::Contrib::Hanami::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#17
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#19
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#18
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ROUTING = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#12
class Datadog::Tracing::Contrib::Hanami::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/patcher.rb#13
module Datadog::Tracing::Contrib::Hanami::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# Hanami Instrumentation for `hanami.render`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RendererPolicyTracing
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#34
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#12
  def render(env, response); end
end

# Hanami Instrumentation for `hanami.routing`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RouterTracing
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#12
  def call(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#37
  def configuration; end
end

# Contains methods helpful for tracing/annotating HTTP request libraries
#
# source://ddtrace//lib/datadog/tracing/contrib/http_annotation_helper.rb#7
module Datadog::Tracing::Contrib::HttpAnnotationHelper
  # source://ddtrace//lib/datadog/tracing/contrib/http_annotation_helper.rb#8
  def service_name(hostname, configuration_options, pin = T.unsafe(nil)); end
end

# Datadog Httpclient integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#6
module Datadog::Tracing::Contrib::Httpclient; end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Httpclient::Configuration; end

# Custom settings for the Httpclient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Httpclient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Httpclient integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#9
module Datadog::Tracing::Contrib::Httpclient::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#15
Datadog::Tracing::Contrib::Httpclient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#12
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#13
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#10
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#14
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#11
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#16
Datadog::Tracing::Contrib::Httpclient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#17
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#18
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httpclient
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#13
module Datadog::Tracing::Contrib::Httpclient::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#19
module Datadog::Tracing::Contrib::Httpclient::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#22
  def do_get_block(req, proxy, conn, &block); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#93
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#85
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#53
  def annotate_span_with_request!(span, req, req_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#75
  def annotate_span_with_response!(span, response, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#89
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#97
  def logger; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#107
  def set_analytics_sample_rate(span, request_options); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#101
  def should_skip_distributed_tracing?(client_config); end
end

# Description of Httpclient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#13
class Datadog::Tracing::Contrib::Httpclient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#16
Datadog::Tracing::Contrib::Httpclient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httpclient' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#13
module Datadog::Tracing::Contrib::Httpclient::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#29
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#20
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#24
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#30
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#24
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#16
Datadog::Tracing::Contrib::Httpclient::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Datadog Httprb integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#6
module Datadog::Tracing::Contrib::Httprb; end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Httprb::Configuration; end

# Custom settings for the Httprb integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Httprb::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Httprb integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#9
module Datadog::Tracing::Contrib::Httprb::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#15
Datadog::Tracing::Contrib::Httprb::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#12
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#13
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#10
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#14
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#11
Datadog::Tracing::Contrib::Httprb::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#16
Datadog::Tracing::Contrib::Httprb::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#17
Datadog::Tracing::Contrib::Httprb::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#18
Datadog::Tracing::Contrib::Httprb::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httprb
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#13
module Datadog::Tracing::Contrib::Httprb::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#19
module Datadog::Tracing::Contrib::Httprb::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#22
  def perform(req, options); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#104
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#96
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#53
  def annotate_span_with_request!(span, req, req_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#84
  def annotate_span_with_response!(span, response, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#100
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#108
  def logger; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#118
  def set_analytics_sample_rate(span, request_options); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#112
  def should_skip_distributed_tracing?(client_config); end
end

# Description of Httprb integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#13
class Datadog::Tracing::Contrib::Httprb::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#16
Datadog::Tracing::Contrib::Httprb::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httprb' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#13
module Datadog::Tracing::Contrib::Httprb::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#29
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#20
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#24
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#30
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#24
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#16
Datadog::Tracing::Contrib::Httprb::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# {Integration} provides the basic contract of a tracing integration.
#
# An example for a simple instrumentation of a fictional `BillingApi::Client`:
#
# ```
# require 'ddtrace'
#
# module BillingApi
#   class Integration
#     include ::Datadog::Tracing::Contrib::Integration
#
#     register_as :billing_api # Register in the global tracing registry
#
#     def self.available?
#       defined?(::BillingApi::Client) # Check if the target for instrumentation is present.
#     end
#
#     def new_configuration
#       Settings.new
#     end
#
#     def patcher
#       Patcher
#     end
#   end
#
#   class Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
#     # Custom service name, if a separate service is desirable for BillingApi calls.
#     option :service, default: nil
#   end
#
#   module Patcher
#     include ::Datadog::Tracing::Contrib::Patcher
#
#     def self.patch
#       ::BillingApi::Client.prepend(Instrumentation)
#     end
#   end
#
#   module Instrumentation
#     def api_request!(env)
#       Tracing.trace('billing.request',
#                            type: 'http',
#                            service: Datadog.configuration.tracing[:billing_api][:service]) do |span|
#         span.resource = env[:route].to_s
#         span.set_tag('client_id', env[:client][:id])
#
#         super
#       end
#     end
#   end
# end
#
# Datadog.configure do |c|
#   c.tracing.instrument :billing_api # Settings (e.g. `service:`) can be provided as keyword arguments.
# end
# ```
#
# source://ddtrace//lib/datadog/tracing/contrib/integration.rb#69
module Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/integration.rb#70
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#6
module Datadog::Tracing::Contrib::Kafka; end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Kafka::Configuration; end

# Custom settings for the Kafka integration
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Kafka::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an event for a consumer.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_event.rb#9
  def process(span, _event, _id, payload); end
end

# Defines basic behaviors for an event for a consumer group.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#9
  def process(span, _event, _id, payload); end
end

# Defines basic behaviors for an ActiveSupport event.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#12
module Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#13
    def included(base); end
  end
end

# Class methods for Kafka events.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#19
module Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#28
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#32
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#24
  def span_options; end
end

# Defines collection of instrumented Kafka events
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#10
module Datadog::Tracing::Contrib::Kafka::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#33
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#41
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#37
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#33
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#41
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#37
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#19
Datadog::Tracing::Contrib::Kafka::Events::ALL = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Connection; end

# Defines instrumentation for request.connection.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::Connection::Request
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#29
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#33
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#18
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#29
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#33
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Connection::Request::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#12
module Datadog::Tracing::Contrib::Kafka::Events::Consumer; end

# Defines instrumentation for process_batch.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#14
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#36
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#40
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#20
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#36
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#40
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#18
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#14
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#34
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#38
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#20
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#34
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#38
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#18
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup; end

# Defines instrumentation for heartbeat.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#34
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#38
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#22
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#34
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#38
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for join_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#24
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#28
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#24
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#28
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for leave_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#24
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#28
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#24
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#28
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sync_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#15
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#24
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#28
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#24
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#28
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#20
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation; end

# Defines instrumentation for send_messages.producer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#28
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#32
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#18
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#28
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#32
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#16
Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Producer; end

# Defines instrumentation for deliver_messages.producer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#31
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#35
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#18
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#31
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#35
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# Kafka integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#9
module Datadog::Tracing::Contrib::Kafka::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#11
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#12
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#10
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#13
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#14
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#15
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#16
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#17
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#18
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#19
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#20
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#21
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#23
Datadog::Tracing::Contrib::Kafka::Ext::TAG_API = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#22
Datadog::Tracing::Contrib::Kafka::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#24
Datadog::Tracing::Contrib::Kafka::Ext::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#38
Datadog::Tracing::Contrib::Kafka::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#29
Datadog::Tracing::Contrib::Kafka::Ext::TAG_DELIVERED_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#25
Datadog::Tracing::Contrib::Kafka::Ext::TAG_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#26
Datadog::Tracing::Contrib::Kafka::Ext::TAG_HIGHWATER_MARK_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#27
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#28
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#30
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#31
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET_LAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#39
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#40
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#41
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#42
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#43
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#44
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#45
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#46
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#47
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#32
Datadog::Tracing::Contrib::Kafka::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#33
Datadog::Tracing::Contrib::Kafka::Ext::TAG_REQUEST_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#34
Datadog::Tracing::Contrib::Kafka::Ext::TAG_RESPONSE_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#35
Datadog::Tracing::Contrib::Kafka::Ext::TAG_SENT_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#36
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#37
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC_PARTITIONS = T.let(T.unsafe(nil), String)

# Description of Kafka integration
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#12
class Datadog::Tracing::Contrib::Kafka::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#15
Datadog::Tracing::Contrib::Kafka::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'kafka' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#12
module Datadog::Tracing::Contrib::Kafka::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#17
    def target_version; end
  end
end

# Datadog Lograge integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#6
module Datadog::Tracing::Contrib::Lograge; end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Lograge::Configuration; end

# Custom settings for the Lograge integration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Lograge::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Lograge integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#9
module Datadog::Tracing::Contrib::Lograge::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#10
Datadog::Tracing::Contrib::Lograge::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for Lograge
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#10
module Datadog::Tracing::Contrib::Lograge::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#16
module Datadog::Tracing::Contrib::Lograge::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#17
  def custom_options(event); end
end

# Description of Lograge integration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#12
class Datadog::Tracing::Contrib::Lograge::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration and has a hard dependancy on rails
  # so can safely say this shouldn't ever be part of auto instrumentation
  # https://github.com/roidrage/lograge/blob/1729eab7956bb95c5992e4adab251e4f93ff9280/lograge.gemspec#L18-L20
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#15
Datadog::Tracing::Contrib::Lograge::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'lograge' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#12
module Datadog::Tracing::Contrib::Lograge::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#17
    def target_version; end
  end
end

# MongoDB module includes classes and functions to instrument MongoDB clients
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#6
module Datadog::Tracing::Contrib::MongoDB
  private

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#43
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#39
  def quantization_options; end

  # returns a formatted and normalized query
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#21
  def query_builder(command_name, database_name, command); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#43
    def configuration; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#39
    def quantization_options; end

    # returns a formatted and normalized query
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#21
    def query_builder(command_name, database_name, command); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#10
module Datadog::Tracing::Contrib::MongoDB::Configuration; end

# Custom settings for the MongoDB integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#13
class Datadog::Tracing::Contrib::MongoDB::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#14
Datadog::Tracing::Contrib::MongoDB::Configuration::Settings::DEFAULT_QUANTIZE = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#12
Datadog::Tracing::Contrib::MongoDB::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#10
Datadog::Tracing::Contrib::MongoDB::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# MongoDB integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#9
module Datadog::Tracing::Contrib::MongoDB::Ext; end

# Temporary namespace to accommodate unified tags which has naming collision, before
# making breaking changes
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#28
module Datadog::Tracing::Contrib::MongoDB::Ext::DB; end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#29
Datadog::Tracing::Contrib::MongoDB::Ext::DB::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#14
Datadog::Tracing::Contrib::MongoDB::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#12
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#13
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#10
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#11
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#15
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#16
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#17
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#22
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#18
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#19
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#23
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#20
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#21
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_ROWS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#24
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instrumentation for Mongo integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#12
module Datadog::Tracing::Contrib::MongoDB::Instrumentation; end

# Instrumentation for Mongo::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#14
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client
  include ::Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#15
    def included(base); end
  end
end

# Instance methods for Mongo::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#20
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#21
  def datadog_pin; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#30
  def datadog_pin=(pin); end
end

# Description of MongoDB integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#13
class Datadog::Tracing::Contrib::MongoDB::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#37
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#41
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#16
Datadog::Tracing::Contrib::MongoDB::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# `MongoCommandSubscriber` listens to all events from the `Monitoring`
# system available in the Mongo driver.
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#15
class Datadog::Tracing::Contrib::MongoDB::MongoCommandSubscriber
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#62
  def failed(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#16
  def started(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#78
  def succeeded(event); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#112
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#116
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#106
  def clear_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#120
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#96
  def get_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#101
  def set_span(event, span); end
end

# skipped keys are related to command names, since they are already
# extracted by the query_builder
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#18
Datadog::Tracing::Contrib::MongoDB::PLACEHOLDER = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'mongo' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#12
module Datadog::Tracing::Contrib::MongoDB::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
  def add_mongo_monitoring; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
    def add_mongo_monitoring; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#11
Datadog::Tracing::Contrib::MongoDB::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#6
module Datadog::Tracing::Contrib::Mysql2; end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Mysql2::Configuration; end

# Custom settings for the Mysql2 integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Mysql2::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def comment_propagation; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def comment_propagation=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Mysql2 integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#9
module Datadog::Tracing::Contrib::Mysql2::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#14
Datadog::Tracing::Contrib::Mysql2::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#12
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#13
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#10
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#11
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#15
Datadog::Tracing::Contrib::Mysql2::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#17
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#16
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#18
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#19
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Mysql2::Client patch module
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#15
module Datadog::Tracing::Contrib::Mysql2::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#16
    def included(base); end
  end
end

# Mysql2::Client patch instance methods
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#21
module Datadog::Tracing::Contrib::Mysql2::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#22
  def query(sql, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#61
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#65
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#69
  def comment_propagation; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#57
  def datadog_configuration; end
end

# Description of Mysql2 integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#12
class Datadog::Tracing::Contrib::Mysql2::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#15
Datadog::Tracing::Contrib::Mysql2::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'mysql2' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#11
module Datadog::Tracing::Contrib::Mysql2::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
  def patch_mysql2_client; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
    def patch_mysql2_client; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
    def target_version; end
  end
end

# Base provides features that are shared across all integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#7
module Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#8
    def included(base); end
  end
end

# Class methods for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#15
module Datadog::Tracing::Contrib::Patchable::ClassMethods
  # Is the target available to be instrumented? (e.g. gem installed?)
  #
  # The target doesn't have to be loaded (e.g. `require`) yet, but needs to be able
  # to be loaded before instrumentation can commence.
  #
  # By default, {.available?} checks if {.version} returned a non-nil object.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Boolean] is the target available for instrumentation in this Ruby environment?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#37
  def available?; end

  # Is this instrumentation compatible with the available target? (e.g. minimum version met?)
  #
  # @return [Boolean] is the available target compatible with this instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#53
  def compatible?; end

  # Is the target loaded into the application? (e.g. gem required? Constant defined?)
  #
  # The target's objects should be ready to be referenced by the instrumented when {.loaded}
  # returns `true`.
  #
  # @return [Boolean] is the target ready to be referenced during instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#47
  def loaded?; end

  # Can the patch for this integration be applied?
  #
  # By default, this is equivalent to {#available?}, {#loaded?}, and {#compatible?}
  # all being truthy.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#61
  def patchable?; end

  # Version of the integration target code in the environment.
  #
  # This is the gem version, when the instrumentation target is a Ruby gem.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Object] the target version
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#23
  def version; end
end

# Instance methods for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#68
module Datadog::Tracing::Contrib::Patchable::InstanceMethods
  # Can the patch for this integration be applied automatically?
  # For example: test integrations should only be applied
  # by the user explicitly setting `c.ci.instrument :rspec`
  # and rails sub-modules are auto-instrumented by enabling rails
  # so auto-instrumenting them on their own will cause changes in
  # service naming behavior
  #
  # @return [Boolean] can the tracer activate this instrumentation without explicit user input?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#102
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#80
  def patch; end

  # The patcher module to inject instrumented objects into the instrumentation target.
  #
  # {Contrib::Patcher} includes the basic functionality of a patcher. `include`ing
  # {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
  #
  # @return [Contrib::Patcher] a module that `include`s {Contrib::Patcher}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#75
  def patcher; end
end

# Common behavior for patcher modules.
#
# `include`ing {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
# The patcher can then be provided to a custom {Datadog::Tracing::Contrib::Integration} for instrumentation.
#
# source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#13
module Datadog::Tracing::Contrib::Patcher
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#14
    def included(base); end
  end
end

# Prepended instance methods for all patchers
#
# source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#21
module Datadog::Tracing::Contrib::Patcher::CommonMethods
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#69
  def default_tags; end

  # Processes patching errors. This default implementation logs the error and reports relevant metrics.
  #
  # @param e [Exception]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#52
  def on_patch_error(e); end

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
  def patch; end

  # Returns the value of attribute patch_error_result.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_error_result; end

  # Sets the attribute patch_error_result
  #
  # @param value the value to set the attribute patch_error_result to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_error_result=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#26
  def patch_name; end

  # Returns the value of attribute patch_successful.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_successful; end

  # Sets the attribute patch_successful
  #
  # @param value the value to set the attribute patch_successful to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#22
  def patch_successful=(_arg0); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#30
  def patched?; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#78
  def patch_only_once; end
end

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#6
module Datadog::Tracing::Contrib::Pg; end

# source://ddtrace//lib/datadog/tracing/contrib/pg/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Pg::Configuration; end

# Custom settings for the Pg integration
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Pg::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def comment_propagation; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def comment_propagation=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# pg integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#9
module Datadog::Tracing::Contrib::Pg::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#14
Datadog::Tracing::Contrib::Pg::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#12
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#13
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#10
Datadog::Tracing::Contrib::Pg::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#11
Datadog::Tracing::Contrib::Pg::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#18
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#19
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#20
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#15
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#16
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#17
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#21
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#22
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#23
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#25
Datadog::Tracing::Contrib::Pg::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#24
Datadog::Tracing::Contrib::Pg::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#26
Datadog::Tracing::Contrib::Pg::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#28
Datadog::Tracing::Contrib::Pg::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# PG::Connection patch module
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#16
module Datadog::Tracing::Contrib::Pg::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#17
    def included(base); end
  end
end

# PG::Connection patch methods
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#22
module Datadog::Tracing::Contrib::Pg::Instrumentation::InstanceMethods
  # async_exec is an alias to exec
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#42
  def async_exec(sql, *args, &block); end

  # async_exec_params is an alias to exec_params
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#49
  def async_exec_params(sql, params, *args, &block); end

  # async_exec_prepared is an alias to exec_prepared
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#56
  def async_exec_prepared(statement_name, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#23
  def exec(sql, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#29
  def exec_params(sql, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#35
  def exec_prepared(statement_name, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#62
  def sync_exec(sql, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#68
  def sync_exec_params(sql, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#74
  def sync_exec_prepared(statement_name, params, *args, &block); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#152
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#156
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#122
  def annotate_span_with_query!(span, service); end

  # @param result [PG::Result]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#144
  def annotate_span_with_result!(span, result); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#160
  def comment_propagation; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#148
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#82
  def trace(name, sql: T.unsafe(nil), statement_name: T.unsafe(nil), block: T.unsafe(nil)); end
end

# Description of pg integration
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#12
class Datadog::Tracing::Contrib::Pg::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#15
Datadog::Tracing::Contrib::Pg::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#11
module Datadog::Tracing::Contrib::Pg::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#6
module Datadog::Tracing::Contrib::Presto; end

# source://ddtrace//lib/datadog/tracing/contrib/presto/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Presto::Configuration; end

# Custom settings for the Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Presto::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Presto integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#9
module Datadog::Tracing::Contrib::Presto::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#14
Datadog::Tracing::Contrib::Presto::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#12
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#13
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#10
Datadog::Tracing::Contrib::Presto::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#11
Datadog::Tracing::Contrib::Presto::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#16
Datadog::Tracing::Contrib::Presto::Ext::SPAN_KILL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#15
Datadog::Tracing::Contrib::Presto::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#18
Datadog::Tracing::Contrib::Presto::Ext::TAG_CATALOG_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#26
Datadog::Tracing::Contrib::Presto::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#21
Datadog::Tracing::Contrib::Presto::Ext::TAG_LANGUAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#23
Datadog::Tracing::Contrib::Presto::Ext::TAG_MODEL_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#28
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_KILL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#27
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#22
Datadog::Tracing::Contrib::Presto::Ext::TAG_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#25
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#24
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#17
Datadog::Tracing::Contrib::Presto::Ext::TAG_SCHEMA_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#20
Datadog::Tracing::Contrib::Presto::Ext::TAG_TIME_ZONE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#19
Datadog::Tracing::Contrib::Presto::Ext::TAG_USER_NAME = T.let(T.unsafe(nil), String)

# Instrumentation for Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#11
module Datadog::Tracing::Contrib::Presto::Instrumentation; end

# Instrumentation for Presto::Client::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#13
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for Presto::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#19
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#56
  def kill(query_id); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#38
  def query(query, &blk); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#20
  def run(query); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#77
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#81
  def decorate!(span, operation); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#115
  def set_nilable_tag!(span, key, tag_name); end
end

# Description of Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#12
class Datadog::Tracing::Contrib::Presto::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#15
Datadog::Tracing::Contrib::Presto::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'presto-client' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#13
module Datadog::Tracing::Contrib::Presto::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#24
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#20
  def patched?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#30
    def patched?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#16
Datadog::Tracing::Contrib::Presto::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#10
module Datadog::Tracing::Contrib::Propagation; end

# Implements sql comment propagation related contracts.
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#11
module Datadog::Tracing::Contrib::Propagation::SqlComment
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#14
    def annotate!(span_op, mode); end

    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#40
    def datadog_configuration; end

    # Inject span_op and trace_op instead of TraceDigest to improve memory usage
    # for `disabled` and `service` mode
    #
    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#22
    def prepend_comment(sql, span_op, trace_op, mode); end
  end
end

# To be prepended to a sql statement.
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#13
class Datadog::Tracing::Contrib::Propagation::SqlComment::Comment
  # @return [Comment] a new instance of Comment
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#14
  def initialize(hash); end

  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#18
  def to_s; end
end

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#8
module Datadog::Tracing::Contrib::Propagation::SqlComment::Ext; end

# The default mode for sql comment propagation
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#12
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::DISABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#9
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::ENV_DBM_PROPAGATION_MODE = T.let(T.unsafe(nil), String)

# The `full` mode propagates service configuration + trace context
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#18
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::FULL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#23
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_DATABASE_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#24
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_ENVIRONMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#25
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_PARENT_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#27
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_TRACEPARENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#26
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_VERSION = T.let(T.unsafe(nil), String)

# The `service` mode propagates service configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#15
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::SERVICE = T.let(T.unsafe(nil), String)

# The value should be `true` when `full` mode
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#21
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::TAG_DBM_TRACE_INJECTED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
class Datadog::Tracing::Contrib::Propagation::SqlComment::Mode < ::Struct
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#12
  def enabled?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#20
  def full?; end

  # Returns the value of attribute mode
  #
  # @return [Object] the current value of mode
  def mode; end

  # Sets the attribute mode
  #
  # @param value [Object] the value to set the attribute mode to.
  # @return [Object] the newly set value
  def mode=(_); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#16
  def service?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#6
module Datadog::Tracing::Contrib::Qless; end

# source://ddtrace//lib/datadog/tracing/contrib/qless/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Qless::Configuration; end

# Custom settings for the Qless integration
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Qless::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_job_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_job_data=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_job_tags; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_job_tags=(value); end
end

# Qless integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#9
module Datadog::Tracing::Contrib::Qless::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#10
Datadog::Tracing::Contrib::Qless::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#11
Datadog::Tracing::Contrib::Qless::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#12
Datadog::Tracing::Contrib::Qless::Ext::ENV_TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#13
Datadog::Tracing::Contrib::Qless::Ext::ENV_TAG_JOB_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#14
Datadog::Tracing::Contrib::Qless::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#15
Datadog::Tracing::Contrib::Qless::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#20
Datadog::Tracing::Contrib::Qless::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#17
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#16
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#18
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#19
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#21
Datadog::Tracing::Contrib::Qless::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Qless integration
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#12
class Datadog::Tracing::Contrib::Qless::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#15
Datadog::Tracing::Contrib::Qless::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'qless' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#10
module Datadog::Tracing::Contrib::Qless::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#30
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#30
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#8
module Datadog::Tracing::Contrib::Que; end

# source://ddtrace//lib/datadog/tracing/contrib/que/configuration/settings.rb#13
module Datadog::Tracing::Contrib::Que::Configuration; end

# Default settings for the Que integration
#
# source://ddtrace//lib/datadog/tracing/contrib/que/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Que::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_args=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_data=(value); end
end

# Que integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#11
module Datadog::Tracing::Contrib::Que::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#12
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#13
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#14
Datadog::Tracing::Contrib::Que::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#15
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_ARGS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#16
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_DATA_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#17
Datadog::Tracing::Contrib::Que::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#18
Datadog::Tracing::Contrib::Que::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#28
Datadog::Tracing::Contrib::Que::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#19
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#20
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#21
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ERROR_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#22
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_EXPIRED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#23
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_FINISHED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#24
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#25
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#26
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#27
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_RUN_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#29
Datadog::Tracing::Contrib::Que::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Que integration
#
# source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#15
class Datadog::Tracing::Contrib::Que::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#35
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#39
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#31
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#27
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#23
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#18
Datadog::Tracing::Contrib::Que::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'que' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#12
module Datadog::Tracing::Contrib::Que::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#17
    def target_version; end
  end
end

# Tracer is a Que's server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#12
class Datadog::Tracing::Contrib::Que::Tracer
  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#13
  def call(job); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#56
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#47
  def set_sample_rate(request_span); end
end

# Registry is a global, declarative repository of all available integrations.
#
# Integrations should register themselves with the registry as early as
# possible as the initial tracer configuration can only activate integrations
# if they have already been registered.
#
# Despite that, integrations *can* be appended to the registry at any point
# of the program execution. Newly appended integrations can then be
# activated during tracer reconfiguration.
#
# The registry does not depend on runtime configuration and registered integrations
# must execute correctly after successive configuration changes.
# The registered integrations themselves can depend on the stateful configuration
# of the tracer.
#
# `Datadog.registry` is a helper accessor to this constant, but it's only available
# after the tracer has complete initialization. Use `Datadog::Tracing::Contrib::REGISTRY` instead
# of `Datadog.registry` when you code might be called during tracer initialization.
#
# source://ddtrace//lib/datadog/tracing/contrib.rb#28
Datadog::Tracing::Contrib::REGISTRY = T.let(T.unsafe(nil), Datadog::Tracing::Contrib::Registry)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#6
module Datadog::Tracing::Contrib::Racecar; end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Racecar::Configuration; end

# Custom settings for the Racecar integration
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Racecar::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#13
module Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#14
    def included(base); end
  end
end

# Class methods for Racecar events.
# Note, they share the same process method and before_trace method.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#21
module Datadog::Tracing::Contrib::Racecar::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#32
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#36
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#28
  def span_options; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#22
  def subscription(*args); end

  private

  # Context objects are thread-bound.
  # If Racecar re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#68
  def ensure_clean_context!; end
end

# Defines collection of instrumented Racecar events
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#10
module Datadog::Tracing::Contrib::Racecar::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#21
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#29
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#25
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#21
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#29
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#25
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#13
Datadog::Tracing::Contrib::Racecar::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for process_batch.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Batch
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#23
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#27
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#23
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#27
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Batch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for main_loop.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Consume
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#23
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#27
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#23
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#27
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Consume::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#12
module Datadog::Tracing::Contrib::Racecar::Events::Message
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#23
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#27
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#23
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#27
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#15
Datadog::Tracing::Contrib::Racecar::Events::Message::EVENT_NAME = T.let(T.unsafe(nil), String)

# Racecar integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#9
module Datadog::Tracing::Contrib::Racecar::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#13
Datadog::Tracing::Contrib::Racecar::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#11
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#12
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#10
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#15
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#14
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_CONSUME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#16
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#23
Datadog::Tracing::Contrib::Racecar::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#17
Datadog::Tracing::Contrib::Racecar::Ext::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#18
Datadog::Tracing::Contrib::Racecar::Ext::TAG_FIRST_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#19
Datadog::Tracing::Contrib::Racecar::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#20
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#25
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#24
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_CONSUME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#26
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#21
Datadog::Tracing::Contrib::Racecar::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#22
Datadog::Tracing::Contrib::Racecar::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# Description of Racecar integration
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#12
class Datadog::Tracing::Contrib::Racecar::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#15
Datadog::Tracing::Contrib::Racecar::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'racecar' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#12
module Datadog::Tracing::Contrib::Racecar::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#17
    def target_version; end
  end
end

# Rack module includes middlewares that are required to trace any framework
# and application built on top of Rack.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#6
module Datadog::Tracing::Contrib::Rack; end

# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Rack::Configuration; end

# Custom settings for the Rack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Rack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def application; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def application=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def headers; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def headers=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def request_queuing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def request_queuing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def web_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def web_service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#14
Datadog::Tracing::Contrib::Rack::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Rack integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#9
module Datadog::Tracing::Contrib::Rack::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#20
Datadog::Tracing::Contrib::Rack::Ext::DEFAULT_PEER_WEBSERVER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#11
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#12
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#10
Datadog::Tracing::Contrib::Rack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#13
Datadog::Tracing::Contrib::Rack::Ext::RACK_ENV_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#14
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_SERVER_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#15
Datadog::Tracing::Contrib::Rack::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#16
Datadog::Tracing::Contrib::Rack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#18
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_SERVER_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#17
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#19
Datadog::Tracing::Contrib::Rack::Ext::WEBSERVER_APP = T.let(T.unsafe(nil), String)

# Classes and utilities for handling headers in Rack.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#8
module Datadog::Tracing::Contrib::Rack::Header
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#28
    def to_rack_header(name); end
  end
end

# An implementation of a header collection that looks up headers from a Rack environment.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#10
class Datadog::Tracing::Contrib::Rack::Header::RequestHeaderCollection < ::Datadog::Core::HeaderCollection
  # Creates a header collection from a rack environment.
  #
  # @return [RequestHeaderCollection] a new instance of RequestHeaderCollection
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#12
  def initialize(env); end

  # Gets the value of the header with the given name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#18
  def get(header_name); end

  # Tests whether a header with the given name exists in the environment.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#23
  def key?(header_name); end
end

# Description of Rack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#13
class Datadog::Tracing::Contrib::Rack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#16
Datadog::Tracing::Contrib::Rack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for Rack middleware names
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#24
module Datadog::Tracing::Contrib::Rack::MiddlewareNamePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#64
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#33
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#37
  def patch_middleware_names; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#47
  def retain_middleware_name(middleware); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#29
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#64
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#37
    def patch_middleware_names; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#47
    def retain_middleware_name(middleware); end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#29
    def target_version; end
  end
end

# Provides instrumentation for `rack`
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#8
module Datadog::Tracing::Contrib::Rack::MiddlewarePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#17
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#13
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#13
    def target_version; end
  end
end

# Applies multiple patches
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#70
module Datadog::Tracing::Contrib::Rack::Patcher
  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#104
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#86
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#112
  def patch_error_result; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#108
  def patch_successful; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#78
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#82
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#104
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#86
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#112
    def patch_error_result; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#108
    def patch_successful; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#78
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#82
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#71
Datadog::Tracing::Contrib::Rack::Patcher::PATCHERS = T.let(T.unsafe(nil), Array)

# Retrieves the time spent in an upstream proxy
# for the current Rack request.
#
# This time captures the request delay introduced but
# such proxy before the request made it to the Ruby
# process.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#13
module Datadog::Tracing::Contrib::Rack::QueueTime
  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#20
  def get_request_start(env, now = T.unsafe(nil)); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#20
    def get_request_start(env, now = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#16
Datadog::Tracing::Contrib::Rack::QueueTime::MINIMUM_ACCEPTABLE_TIME_VALUE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#15
Datadog::Tracing::Contrib::Rack::QueueTime::QUEUE_START = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#14
Datadog::Tracing::Contrib::Rack::QueueTime::REQUEST_START = T.let(T.unsafe(nil), String)

# TraceMiddleware ensures that the Rack Request is properly traced
# from the beginning to the end. The middleware adds the request span
# in the Rack environment so that it can be retrieved by the underlying
# application. If request tags are not set by the app, they will be set using
# information available at the Rack level.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#26
class Datadog::Tracing::Contrib::Rack::TraceMiddleware
  # @return [TraceMiddleware] a new instance of TraceMiddleware
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#27
  def initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#56
  def call(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#31
  def compute_queue_time(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#128
  def set_request_tags!(trace, request_span, env, status, headers, response, original_env); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#241
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#291
  def parse_request_headers(headers); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#302
  def parse_response_headers(headers); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#245
  def parse_url(env, original_env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#287
  def parse_user_agent_header(headers); end
end

# Rails module includes middlewares that are required for Rails to be properly instrumented.
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#8
module Datadog::Tracing::Contrib::Rails; end

# source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#9
module Datadog::Tracing::Contrib::Rails::Configuration; end

# Custom settings for the Rails integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Rails::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#13
  def initialize(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def exception_controller; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def exception_controller=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def request_queuing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def request_queuing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def template_base_path; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def template_base_path=(value); end
end

# This is only here to catch errors, the Rack module does something very similar, however,
# since it's not in the same place in the stack, when the Rack middleware is called,
# error is already swallowed and handled by Rails so we miss the call stack, for instance.
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#13
class Datadog::Tracing::Contrib::Rails::ExceptionMiddleware
  # @return [ExceptionMiddleware] a new instance of ExceptionMiddleware
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#14
  def initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#18
  def call(env); end
end

# Rails integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#9
module Datadog::Tracing::Contrib::Rails::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#10
Datadog::Tracing::Contrib::Rails::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#12
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#13
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#14
Datadog::Tracing::Contrib::Rails::Ext::ENV_DISABLE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#11
Datadog::Tracing::Contrib::Rails::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Rails framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#23
module Datadog::Tracing::Contrib::Rails::Framework
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#77
    def activate_action_cable!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#83
    def activate_action_mailer!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#92
    def activate_action_pack!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#101
    def activate_action_view!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#110
    def activate_active_job!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#119
    def activate_active_record!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#71
    def activate_active_support!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#125
    def activate_lograge!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#60
    def activate_rack!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#135
    def activate_semantic_logger!(datadog_config, rails_config); end

    # After the Rails application finishes initializing, we configure the Rails
    # integration and all its sub-components with the application information
    # available.
    # We do this after the initialization because not all the information we
    # require is available before then.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#29
    def setup; end
  end
end

# Description of Rails integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#14
class Datadog::Tracing::Contrib::Rails::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#38
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#42
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#26
    def loaded?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#34
    def patchable?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#22
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#17
Datadog::Tracing::Contrib::Rails::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Rails log injection helper methods
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#9
module Datadog::Tracing::Contrib::Rails::LogInjection
  private

  # source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#12
  def add_as_tagged_logging_logger(app); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#12
    def add_as_tagged_logging_logger(app); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#16
module Datadog::Tracing::Contrib::Rails::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#10
module Datadog::Tracing::Contrib::Rails::Utils
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#11
    def app_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#21
    def railtie_supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#6
module Datadog::Tracing::Contrib::Rake; end

# source://ddtrace//lib/datadog/tracing/contrib/rake/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Rake::Configuration; end

# Custom settings for the Rake integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Rake::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tasks; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tasks=(value); end
end

# Rake integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#9
module Datadog::Tracing::Contrib::Rake::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#11
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#12
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#10
Datadog::Tracing::Contrib::Rake::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#13
Datadog::Tracing::Contrib::Rake::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#15
Datadog::Tracing::Contrib::Rake::Ext::SPAN_EXECUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#14
Datadog::Tracing::Contrib::Rake::Ext::SPAN_INVOKE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#19
Datadog::Tracing::Contrib::Rake::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#16
Datadog::Tracing::Contrib::Rake::Ext::TAG_EXECUTE_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#17
Datadog::Tracing::Contrib::Rake::Ext::TAG_INVOKE_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#20
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_EXECUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#21
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_INVOKE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#18
Datadog::Tracing::Contrib::Rake::Ext::TAG_TASK_ARG_NAMES = T.let(T.unsafe(nil), String)

# Instrumentation for Rake tasks
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#13
module Datadog::Tracing::Contrib::Rake::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#14
    def included(base); end
  end
end

# Instance methods for Rake instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#19
module Datadog::Tracing::Contrib::Rake::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#31
  def execute(args = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#20
  def invoke(*args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#72
  def annotate_execute!(span, args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#54
  def annotate_invoke!(span, args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#95
  def configuration; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#86
  def enabled?; end

  # Task names are verified dynamically, in order to be agnostic of
  # when tracing is configured in relation to Rake task declaration.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#46
  def instrumented_task?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#81
  def quantize_args(args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#50
  def shutdown_tracer!; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#91
  def span_options; end
end

# Description of Rake integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#12
class Datadog::Tracing::Contrib::Rake::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#15
Datadog::Tracing::Contrib::Rake::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rake' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#12
module Datadog::Tracing::Contrib::Rake::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#26
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#26
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#6
module Datadog::Tracing::Contrib::Redis; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Redis::Configuration; end

# Converts String URLs and Hashes to a normalized connection settings Hash.
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#13
class Datadog::Tracing::Contrib::Redis::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # @param Redis [Hash, String] connection information
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#15
  def resolve(hash); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#41
  def connection_resolver; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#27
  def normalize(hash); end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#21
  def parse_matcher(matcher); end
end

# Custom settings for the Redis integration
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Redis::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def command_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def command_args=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#10
Datadog::Tracing::Contrib::Redis::Configuration::UNIX_SCHEME = T.let(T.unsafe(nil), String)

# Redis integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#9
module Datadog::Tracing::Contrib::Redis::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#16
Datadog::Tracing::Contrib::Redis::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#12
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#13
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#14
Datadog::Tracing::Contrib::Redis::Ext::ENV_COMMAND_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#10
Datadog::Tracing::Contrib::Redis::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#11
Datadog::Tracing::Contrib::Redis::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#15
Datadog::Tracing::Contrib::Redis::Ext::METRIC_PIPELINE_LEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#17
Datadog::Tracing::Contrib::Redis::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#21
Datadog::Tracing::Contrib::Redis::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#24
Datadog::Tracing::Contrib::Redis::Ext::TAG_DATABASE_INDEX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#18
Datadog::Tracing::Contrib::Redis::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#22
Datadog::Tracing::Contrib::Redis::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#19
Datadog::Tracing::Contrib::Redis::Ext::TAG_RAW_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#23
Datadog::Tracing::Contrib::Redis::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#20
Datadog::Tracing::Contrib::Redis::Ext::TYPE = T.let(T.unsafe(nil), String)

# Description of Redis integration
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#12
class Datadog::Tracing::Contrib::Redis::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#65
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#69
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#73
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#53
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#41
    def loaded?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#61
    def redis_client_compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#49
    def redis_client_loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#37
    def redis_client_version; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#57
    def redis_compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#45
    def redis_loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#33
    def redis_version; end

    # Until Redis 4, all instrumentation happened in one gem: redis.
    # Since Redis 5, instrumentation happens in a separate gem: redis-client.
    # Because Redis 4 does not depend on redis-client, it's possible for both gems to be installed at the same time.
    # For example, if Sidekiq 7 and Redis 4 are installed: both redis and redis-client will be installed.
    # If redis-client and redis > 5 are installed, than they will be in sync, and only redis-client will be installed.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#29
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#15
Datadog::Tracing::Contrib::Redis::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Support `Config#custom`
# https://github.com/redis-rb/redis-client/blob/master/CHANGELOG.md#0110
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#19
Datadog::Tracing::Contrib::Redis::Integration::REDISCLIENT_MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#12
module Datadog::Tracing::Contrib::Redis::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#14
module Datadog::Tracing::Contrib::Redis::Vendor; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#15
class Datadog::Tracing::Contrib::Redis::Vendor::Resolver
  #
  # This method is a subset of the implementation provided in v3.0.0
  # https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb
  # https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb
  #
  # Since it has been backported from the original gem, some linting
  # cops have been disabled
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#54
  def _parse_options(options); end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#40
  def resolve(options); end
end

# Connection DEFAULTS for a Redis::Client are unchanged for
# the integration supported options.
# https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb#L6-L14
# https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb#L10-L26
# Since the integration takes in consideration only few attributes, all
# versions are compatible for :url, :scheme, :host, :port, :db
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#22
Datadog::Tracing::Contrib::Redis::Vendor::Resolver::DEFAULTS = T.let(T.unsafe(nil), Hash)

# Defines registerable behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#7
module Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#8
    def included(base); end
  end
end

# Class methods for registerable behavior
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#15
module Datadog::Tracing::Contrib::Registerable::ClassMethods
  # Registers this integration in the global tracer registry.
  # Once registered, this integration can be activated with:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :name
  # end
  # ```
  #
  # @param name [Symbol] integration name. Used during activation.
  # @param registry [Datadog::Tracing::Contrib::Registry] a custom registry.
  #   Defaults to the global tracing registry.
  # @param auto_patch [Boolean] will this integration be activated during
  #   {file:docs/AutoInstrumentation.md Auto Instrumentation}?
  # @param options [Hash] additional keyword options passed to the initializer of
  #   a custom {Registerable} instrumentation
  # @see Datadog::Tracing::Contrib::Integration
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#33
  def register_as(name, registry: T.unsafe(nil), auto_patch: T.unsafe(nil), **options); end
end

# Instance methods for registerable behavior
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#39
module Datadog::Tracing::Contrib::Registerable::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#43
  def initialize(name, **options); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#40
  def name; end
end

# Registry is a collection of tracing integrations.
#
# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#8
class Datadog::Tracing::Contrib::Registry
  include ::Enumerable

  # @return [Registry] a new instance of Registry
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#14
  def initialize; end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#35
  def [](name); end

  # @param name [Symbol] instrumentation name, to be used when activating this integration
  # @param klass [Object] instrumentation implementation
  # @param auto_patch [Boolean] is the tracer allowed to automatically patch
  #   the host application with this instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#23
  def add(name, klass, auto_patch = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#29
  def each(&block); end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#42
  def to_h; end
end

# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#11
class Datadog::Tracing::Contrib::Registry::Entry < ::Struct
  # Returns the value of attribute auto_patch
  #
  # @return [Object] the current value of auto_patch
  def auto_patch; end

  # Sets the attribute auto_patch
  #
  # @param value [Object] the value to set the attribute auto_patch to.
  # @return [Object] the newly set value
  def auto_patch=(_); end

  # Returns the value of attribute klass
  #
  # @return [Object] the current value of klass
  def klass; end

  # Sets the attribute klass
  #
  # @param value [Object] the value to set the attribute klass to.
  # @return [Object] the newly set value
  def klass=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#6
module Datadog::Tracing::Contrib::Resque; end

# source://ddtrace//lib/datadog/tracing/contrib/resque/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Resque::Configuration; end

# Custom settings for the Resque integration
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Resque::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Resque integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#9
module Datadog::Tracing::Contrib::Resque::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#11
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#12
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#10
Datadog::Tracing::Contrib::Resque::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#13
Datadog::Tracing::Contrib::Resque::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#14
Datadog::Tracing::Contrib::Resque::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#15
Datadog::Tracing::Contrib::Resque::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#16
Datadog::Tracing::Contrib::Resque::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Resque integration
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#12
class Datadog::Tracing::Contrib::Resque::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#24
    def loaded?; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#42
    def sync_writer; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#42
    def sync_writer=(_arg0); end

    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#15
Datadog::Tracing::Contrib::Resque::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'resque' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#11
module Datadog::Tracing::Contrib::Resque::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#6
module Datadog::Tracing::Contrib::RestClient; end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#10
module Datadog::Tracing::Contrib::RestClient::Configuration; end

# Custom settings for the RestClient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#13
class Datadog::Tracing::Contrib::RestClient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# RestClient integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#9
module Datadog::Tracing::Contrib::RestClient::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#14
Datadog::Tracing::Contrib::RestClient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#12
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#13
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#10
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#11
Datadog::Tracing::Contrib::RestClient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#15
Datadog::Tracing::Contrib::RestClient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#16
Datadog::Tracing::Contrib::RestClient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#17
Datadog::Tracing::Contrib::RestClient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of RestClient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#12
class Datadog::Tracing::Contrib::RestClient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#15
Datadog::Tracing::Contrib::RestClient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rest_client' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#10
module Datadog::Tracing::Contrib::RestClient::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#16
    def target_version; end
  end
end

# Datadog SemanticLogger integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#6
module Datadog::Tracing::Contrib::SemanticLogger; end

# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SemanticLogger::Configuration; end

# Custom settings for the SemanticLogger integration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SemanticLogger::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# SemanticLogger integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#9
module Datadog::Tracing::Contrib::SemanticLogger::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#10
Datadog::Tracing::Contrib::SemanticLogger::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for SemanticLogger
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#10
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#16
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#17
  def log(log, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# Description of SemanticLogger integration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#12
class Datadog::Tracing::Contrib::SemanticLogger::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # TODO: abstract out the log injection related instrumentation into it's own module so we dont
  # keep having to do these workarounds
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#37
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#41
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#45
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#31
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#27
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#23
    def version; end
  end
end

# v4 had a migration to `named_tags` instead of `payload`
# and has been out for almost 5 years at this point
# it's probably reasonable to nudge users to using modern ruby libs
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#18
Datadog::Tracing::Contrib::SemanticLogger::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'semantic_logger' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#12
module Datadog::Tracing::Contrib::SemanticLogger::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#6
module Datadog::Tracing::Contrib::Sequel; end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sequel::Configuration; end

# Custom settings for the Sequel integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sequel::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Adds instrumentation to Sequel::Database
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#13
module Datadog::Tracing::Contrib::Sequel::Database
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#14
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Database
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#19
module Datadog::Tracing::Contrib::Sequel::Database::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#20
  def run(sql, options = T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#40
  def adapter_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#44
  def parse_opts(sql, opts); end
end

# Adds instrumentation to Sequel::Dataset
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#13
module Datadog::Tracing::Contrib::Sequel::Dataset
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#14
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Dataset
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#19
module Datadog::Tracing::Contrib::Sequel::Dataset::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#20
  def execute(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#24
  def execute_ddl(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#28
  def execute_dui(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#32
  def execute_insert(sql, options = T.unsafe(nil), &block); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#56
  def adapter_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#38
  def trace_execute(super_method, sql, options, &block); end
end

# Sequel integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#9
module Datadog::Tracing::Contrib::Sequel::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#11
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#12
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#10
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#13
Datadog::Tracing::Contrib::Sequel::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#16
Datadog::Tracing::Contrib::Sequel::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#14
Datadog::Tracing::Contrib::Sequel::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#17
Datadog::Tracing::Contrib::Sequel::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#15
Datadog::Tracing::Contrib::Sequel::Ext::TAG_PREPARED_NAME = T.let(T.unsafe(nil), String)

# Description of Sequel integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#12
class Datadog::Tracing::Contrib::Sequel::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#15
Datadog::Tracing::Contrib::Sequel::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sequel' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#12
module Datadog::Tracing::Contrib::Sequel::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#26
  def patch_sequel_database; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#30
  def patch_sequel_dataset; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#26
    def patch_sequel_database; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#30
    def patch_sequel_dataset; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#17
    def target_version; end
  end
end

# General purpose functions for Sequel
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#11
module Datadog::Tracing::Contrib::Sequel::Utils
  class << self
    # Ruby database connector library
    #
    # e.g. adapter:mysql2 (database:mysql), adapter:jdbc (database:postgres)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#16
    def adapter_name(database); end

    # Database engine
    #
    # e.g. database:mysql (adapter:mysql2), database:postgres (adapter:jdbc)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#31
    def database_type(database); end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#35
    def parse_opts(sql, opts, db_opts, dataset = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#53
    def set_common_tags(span, db); end

    private

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#75
    def analytics_enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#79
    def analytics_sample_rate; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#71
    def datadog_configuration; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#6
module Datadog::Tracing::Contrib::Shoryuken; end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Shoryuken::Configuration; end

# Default settings for the Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Shoryuken::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_body; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_body=(value); end
end

# Shoryuken integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#9
module Datadog::Tracing::Contrib::Shoryuken::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#11
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#12
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#10
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#13
Datadog::Tracing::Contrib::Shoryuken::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#14
Datadog::Tracing::Contrib::Shoryuken::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#19
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#17
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#18
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#15
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#16
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#20
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#13
class Datadog::Tracing::Contrib::Shoryuken::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#16
Datadog::Tracing::Contrib::Shoryuken::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'shoryuken' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#10
module Datadog::Tracing::Contrib::Shoryuken::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
    def target_version; end
  end
end

# Tracer is a Shoryuken server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#10
class Datadog::Tracing::Contrib::Shoryuken::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#11
  def initialize(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#16
  def call(worker_instance, queue, sqs_msg, body); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#56
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#48
  def resource(worker_instance, body); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#6
module Datadog::Tracing::Contrib::Sidekiq; end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Sidekiq::Configuration; end

# Custom settings for the Sidekiq integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Sidekiq::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def client_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def client_service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_args=(value); end
end

# Sidekiq integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#9
module Datadog::Tracing::Contrib::Sidekiq::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#10
Datadog::Tracing::Contrib::Sidekiq::Ext::CLIENT_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#12
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#13
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#11
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#14
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#15
Datadog::Tracing::Contrib::Sidekiq::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#20
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#17
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#18
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#16
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#19
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#21
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#22
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#23
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_STOP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#31
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#30
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#24
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_DELAY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#25
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#26
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#27
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#28
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#29
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_WRAPPER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#36
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#33
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#34
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#32
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#35
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#37
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#38
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#39
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_STOP = T.let(T.unsafe(nil), String)

# Description of Sidekiq integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#12
class Datadog::Tracing::Contrib::Sidekiq::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#42
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#46
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#29
    def compatible?; end

    # Only patch server internals on v5.2.4+ because that's when loading of
    # `Sidekiq::Launcher` stabilized. Sidekiq 4+ technically can support our
    # patches (with minor adjustments), but in order to avoid explicitly
    # requiring `sidekiq/launcher` ourselves (which could affect gem
    # initialization order), we are limiting this tracing to v5.2.4+.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#38
    def compatible_with_server_internal_tracing?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#16
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_SERVER_INTERNAL_TRACING_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#15
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sidekiq' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#10
module Datadog::Tracing::Contrib::Sidekiq::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#69
  def patch_redis_info; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
  def patch_server_heartbeat; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
  def patch_server_internals; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#57
  def patch_server_job_fetch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#63
  def patch_server_scheduled_push; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#69
    def patch_redis_info; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
    def patch_server_heartbeat; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
    def patch_server_internals; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#57
    def patch_server_job_fetch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#63
    def patch_server_scheduled_push; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
    def target_version; end
  end
end

# Instrument Sinatra.
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#6
module Datadog::Tracing::Contrib::Sinatra; end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sinatra::Configuration; end

# Custom settings for the Sinatra integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sinatra::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def headers; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def headers=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def resource_script_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def resource_script_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#14
Datadog::Tracing::Contrib::Sinatra::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Hook into builder before the middleware list gets frozen
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#26
module Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch
  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#29
  def setup_middleware(*args, &block); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#27
Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# Sinatra integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#9
module Datadog::Tracing::Contrib::Sinatra::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#11
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#12
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#10
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#29
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_MIDDLEWARE_START_TIME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#30
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_MIDDLEWARE_TRACED = T.let(T.unsafe(nil), String)

# === Deprecated: To be removed ===
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#28
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#13
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_SINATRA_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#14
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#15
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#16
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_ROUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#17
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_APP_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#18
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#19
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#20
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#21
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_ROUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#22
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#23
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#24
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#25
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# Sinatra framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#11
module Datadog::Tracing::Contrib::Sinatra::Framework
  class << self
    # Apply relevant configuration from Sinatra to Rack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#25
    def activate_rack!(datadog_config, sinatra_config); end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#34
    def add_middleware(middleware, builder, *args, &block); end

    # Add Rack middleware after another in the the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#63
    def add_middleware_after(after, middleware, builder, *args, &block); end

    # Add Rack middleware before another in the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#52
    def add_middleware_before(before, middleware, builder, *args, &block); end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#45
    def append_middleware(middleware, builder, *args, &block); end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#20
    def config_with_defaults(datadog_config); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#96
    def include_middleware?(middleware, builder); end

    # Insert a middleware class in the builder as it expects it internally.
    # The block gets passed prepared arguments for the caller to decide
    # how to insert.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#83
    def insert_middleware(builder, middleware, args, block); end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#109
    def inspect_middlewares(builder); end

    # Introspect middlewares from a builder
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#101
    def middlewares(builder); end

    # Configure Rack from Sinatra, but only if Rack has not been configured manually beforehand
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#13
    def setup; end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#34
    def unshift_middleare(middleware, builder, *args, &block); end

    # Wrap the middleware class instantiation in a proc, like Sinatra does internally
    # The `middleware` local variable name in the proc is important for introspection
    # (see Framework#middlewares)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#76
    def wrap_middleware(middleware, *args, &block); end
  end
end

# Description of Sinatra integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#12
class Datadog::Tracing::Contrib::Sinatra::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#15
Datadog::Tracing::Contrib::Sinatra::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sinatra' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#42
module Datadog::Tracing::Contrib::Sinatra::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#52
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#69
  def patch_default_middlewares; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#60
  def register_tracer; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#65
  def setup_tracer; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#48
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#69
    def patch_default_middlewares; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#60
    def register_tracer; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#65
    def setup_tracer; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#48
    def target_version; end
  end
end

# Set tracer configuration at a late enough time
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#13
module Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch
  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#16
  def setup_middleware(*args, &block); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#14
Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#8
module Datadog::Tracing::Contrib::Sneakers; end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Sneakers::Configuration; end

# Default settings for the Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Sneakers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_body; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_body=(value); end
end

# Sneakers integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#11
module Datadog::Tracing::Contrib::Sneakers::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#13
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#14
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#12
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#15
Datadog::Tracing::Contrib::Sneakers::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#16
Datadog::Tracing::Contrib::Sneakers::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#20
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#19
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#18
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#17
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_ROUTING_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#21
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Sneakers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#15
class Datadog::Tracing::Contrib::Sneakers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#35
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#39
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#31
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#27
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#23
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#18
Datadog::Tracing::Contrib::Sneakers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sneakers' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#13
module Datadog::Tracing::Contrib::Sneakers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#18
    def target_version; end
  end
end

# Tracer is a Sneakers server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#13
class Datadog::Tracing::Contrib::Sneakers::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#14
  def initialize(app, *args); end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#19
  def call(deserialized_msg, delivery_info, metadata, handler); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#52
  def configuration; end
end

# Contains methods helpful for tracing/annotating HTTP request libraries
#
# source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#12
class Datadog::Tracing::Contrib::StatusCodeMatcher
  # @return [StatusCodeMatcher] a new instance of StatusCodeMatcher
  #
  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#15
  def initialize(range); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#20
  def include?(exception_status); end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#24
  def to_s; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#50
  def error_responses; end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#56
  def handle_statuses; end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#30
  def set_range; end
end

# source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#13
Datadog::Tracing::Contrib::StatusCodeMatcher::REGEX_PARSER = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#6
module Datadog::Tracing::Contrib::Stripe; end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Stripe::Configuration; end

# Custom settings for the Stripe integration
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Stripe::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Stripe integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#9
module Datadog::Tracing::Contrib::Stripe::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#11
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#12
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#10
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#13
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#14
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_TYPE_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#15
Datadog::Tracing::Contrib::Stripe::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#16
Datadog::Tracing::Contrib::Stripe::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#17
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_HTTP_STATUS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#18
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#19
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#20
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_NUM_RETRIES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#21
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_PATH = T.let(T.unsafe(nil), String)

# Description of Stripe integration
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#12
class Datadog::Tracing::Contrib::Stripe::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#15
Datadog::Tracing::Contrib::Stripe::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for `stripe` through the Stripe instrumentation framework
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#12
module Datadog::Tracing::Contrib::Stripe::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#17
    def target_version; end
  end
end

# Defines instrumentation for Stripe requests
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#12
module Datadog::Tracing::Contrib::Stripe::Request
  private

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#60
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#22
  def finish_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#15
  def start_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#35
  def tag_span(span, event); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#60
    def configuration; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#22
    def finish_span(event); end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#15
    def start_span(event); end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#35
    def tag_span(span, event); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#6
module Datadog::Tracing::Contrib::SuckerPunch; end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SuckerPunch::Configuration; end

# Custom settings for the SuckerPunch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SuckerPunch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# SuckerPunch integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#9
module Datadog::Tracing::Contrib::SuckerPunch::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#11
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#12
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#10
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#13
Datadog::Tracing::Contrib::SuckerPunch::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#14
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#15
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#16
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#19
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#20
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#21
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#22
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#17
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#18
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of SuckerPunch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#12
class Datadog::Tracing::Contrib::SuckerPunch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#15
Datadog::Tracing::Contrib::SuckerPunch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sucker_punch' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#11
module Datadog::Tracing::Contrib::SuckerPunch::Patcher
  include ::Kernel
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#29
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#29
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#9
module Datadog::Tracing::Contrib::Utils; end

# Common database-related utility functions.
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#8
module Datadog::Tracing::Contrib::Utils::Database
  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#15
  def normalize_vendor(vendor); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#15
    def normalize_vendor(vendor); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#9
Datadog::Tracing::Contrib::Utils::Database::VENDOR_DEFAULT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#10
Datadog::Tracing::Contrib::Utils::Database::VENDOR_POSTGRES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#11
Datadog::Tracing::Contrib::Utils::Database::VENDOR_SQLITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#10
module Datadog::Tracing::Contrib::Utils::Quantization; end

# Quantization for HTTP resources
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#12
module Datadog::Tracing::Contrib::Utils::Quantization::HTTP
  include ::Kernel

  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#33
  def base_url(url, options = T.unsafe(nil)); end

  # Iterate over each key value pair, yielding to the block given.
  # Accepts :uniq option, which keeps uniq copies of keys without values.
  # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
  #
  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#95
  def collect_query(query, options = T.unsafe(nil)); end

  # Scans over the query string and obfuscates sensitive data by
  # replacing matches with an opaque value
  #
  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#123
  def obfuscate_query(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#62
  def query(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#68
  def query!(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#25
  def url(url, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#41
  def url!(url, options = T.unsafe(nil)); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#33
    def base_url(url, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#62
    def query(query, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#68
    def query!(query, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#25
    def url(url, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#41
    def url!(url, options = T.unsafe(nil)); end

    private

    # Iterate over each key value pair, yielding to the block given.
    # Accepts :uniq option, which keeps uniq copies of keys without values.
    # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
    #
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#95
    def collect_query(query, options = T.unsafe(nil)); end

    # Scans over the query string and obfuscates sensitive data by
    # replacing matches with an opaque value
    #
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#123
    def obfuscate_query(query, options = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#136
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#133
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_WITH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#15
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::PLACEHOLDER = T.let(T.unsafe(nil), String)

# taken from Ruby https://github.com/ruby/uri/blob/ffbab83de6d8748c9454414e02db5317609166eb/lib/uri/rfc3986_parser.rb
# but adjusted to parse only <scheme>://<host>:<port>/ components
# and stop there, since we don't care about the path, query string,
# and fragment components
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#21
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::RFC3986_URL_BASE = T.let(T.unsafe(nil), Regexp)

# Quantization for Hash
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#9
module Datadog::Tracing::Contrib::Utils::Quantization::Hash
  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#103
  def convert_value(value); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#21
  def format(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#28
  def format!(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#66
  def format_array(value, options); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#34
  def format_hash(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#52
  def format_value(value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#98
  def indifferent_equals(value); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#76
  def merge_options(original, additional); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#103
    def convert_value(value); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#21
    def format(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#28
    def format!(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#66
    def format_array(value, options); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#34
    def format_hash(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#52
    def format_value(value, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#98
    def indifferent_equals(value); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#76
    def merge_options(original, additional); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#13
Datadog::Tracing::Contrib::Utils::Quantization::Hash::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#11
Datadog::Tracing::Contrib::Utils::Quantization::Hash::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#10
Datadog::Tracing::Contrib::Utils::Quantization::Hash::PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#12
Datadog::Tracing::Contrib::Utils::Quantization::Hash::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# Contains behavior for managing correlations with tracing
# e.g. Retrieve a correlation to the current trace for logging, etc.
#
# source://ddtrace//lib/datadog/tracing/correlation.rb#9
module Datadog::Tracing::Correlation
  private

  # Produces a CorrelationIdentifier from the TraceDigest provided
  #
  # DEV: can we memoize this object, give it can be common to
  # use a correlation multiple times, specially in the context of logging?
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#83
  def identifier_from_digest(digest); end

  class << self
    # Produces a CorrelationIdentifier from the TraceDigest provided
    #
    # DEV: can we memoize this object, give it can be common to
    # use a correlation multiple times, specially in the context of logging?
    #
    # source://ddtrace//lib/datadog/tracing/correlation.rb#83
    def identifier_from_digest(digest); end
  end
end

# Represents current trace state with key identifiers
#
# source://ddtrace//lib/datadog/tracing/correlation.rb#12
class Datadog::Tracing::Correlation::Identifier
  # @return [Identifier] a new instance of Identifier
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#34
  def initialize(env: T.unsafe(nil), service: T.unsafe(nil), span_id: T.unsafe(nil), span_name: T.unsafe(nil), span_resource: T.unsafe(nil), span_service: T.unsafe(nil), span_type: T.unsafe(nil), trace_id: T.unsafe(nil), trace_name: T.unsafe(nil), trace_resource: T.unsafe(nil), trace_service: T.unsafe(nil), version: T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def env; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def service; end

  # Returns the value of attribute span_id.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def span_id; end

  # Returns the value of attribute span_name.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def span_name; end

  # Returns the value of attribute span_resource.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def span_resource; end

  # Returns the value of attribute span_service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def span_service; end

  # Returns the value of attribute span_type.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def span_type; end

  # source://ddtrace//lib/datadog/tracing/correlation.rb#63
  def to_log_format; end

  # Returns the value of attribute trace_id.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def trace_id; end

  # Returns the value of attribute trace_name.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def trace_name; end

  # Returns the value of attribute trace_resource.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def trace_resource; end

  # Returns the value of attribute trace_service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def trace_service; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#19
  def version; end
end

# source://ddtrace//lib/datadog/tracing/correlation.rb#13
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#14
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#15
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#16
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_TRACE_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#17
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_VERSION = T.let(T.unsafe(nil), String)

# DefaultContextProvider is a default context provider that retrieves
# all contexts from the current fiber-local storage. It is suitable for
# synchronous programming.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#13
class Datadog::Tracing::DefaultContextProvider
  # Initializes the default context provider with a fiber-bound context.
  #
  # @return [DefaultContextProvider] a new instance of DefaultContextProvider
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#15
  def initialize; end

  # Return the local context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#25
  def context(key = T.unsafe(nil)); end

  # Sets the current context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#20
  def context=(ctx); end
end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#5
module Datadog::Tracing::Diagnostics; end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#7
module Datadog::Tracing::Diagnostics::Ext; end

# Health
#
# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#9
module Datadog::Tracing::Diagnostics::Ext::Health; end

# Metrics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#11
module Datadog::Tracing::Diagnostics::Ext::Health::Metrics; end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#12
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_ERRORS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#13
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_REQUESTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#14
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_RESPONSES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#15
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_CONTEXT_OVERFLOW = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#16
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_INSTRUMENTATION_PATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#17
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_SPAN_FINISH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#18
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_UNFINISHED_SPANS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#19
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_INSTRUMENTATION_PATCHED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#20
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#21
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED_LENGTHS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#22
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_DROPPED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#23
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#24
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_MAX_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#25
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_SPANS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#26
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_SAMPLING_SERVICE_CACHE_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#27
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRACES_FILTERED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#28
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_CHUNKED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#29
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_TRACE_TOO_LARGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#30
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_WRITER_CPU_TIME = T.let(T.unsafe(nil), String)

# Health-related diagnostics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#9
module Datadog::Tracing::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#11
module Datadog::Tracing::Diagnostics::Health::Metrics
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#12
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#9
module Datadog::Tracing::Distributed; end

# B3 multi header-style trace propagation.
#
# @see https://github.com/openzipkin/b3-propagation#multiple-headers
#
# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#12
class Datadog::Tracing::Distributed::B3Multi
  # @return [B3Multi] a new instance of B3Multi
  #
  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#17
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), span_id_key: T.unsafe(nil), sampled_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#46
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#29
  def inject!(digest, data = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#15
Datadog::Tracing::Distributed::B3Multi::B3_SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#14
Datadog::Tracing::Distributed::B3Multi::B3_SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#13
Datadog::Tracing::Distributed::B3Multi::B3_TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# B3 single header-style trace propagation.
#
# DEV: Format:
# DEV:   b3: {TraceId}-{SpanId}-{SamplingState}-{ParentSpanId}
# DEV: https://github.com/apache/incubator-zipkin-b3-propagation/tree/7c6e9f14d6627832bd80baa87ac7dabee7be23cf#single-header
# DEV: `{SamplingState}` and `{ParentSpanId}` are optional
#
# @see https://github.com/openzipkin/b3-propagation#single-header
#
# source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#18
class Datadog::Tracing::Distributed::B3Single
  # @return [B3Single] a new instance of B3Single
  #
  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#21
  def initialize(fetcher:, key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#43
  def extract(env); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#26
  def inject!(digest, env); end
end

# source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#19
Datadog::Tracing::Distributed::B3Single::B3_SINGLE_HEADER_KEY = T.let(T.unsafe(nil), String)

# Datadog-style trace propagation.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#12
class Datadog::Tracing::Distributed::Datadog
  # @return [Datadog] a new instance of Datadog
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#23
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), parent_id_key: T.unsafe(nil), sampling_priority_key: T.unsafe(nil), origin_key: T.unsafe(nil), tags_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#52
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#39
  def inject!(digest, data); end

  private

  # Import `x-datadog-tags` tags as trace distributed tags.
  # Only tags that have the `_dd.p.` prefix are processed.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#105
  def extract_tags(fetcher); end

  # Export trace distributed tags through the `x-datadog-tags` key.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#83
  def inject_tags(digest, data); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#125
  def set_tags_propagation_error(reason:); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#131
  def tags_disabled?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#135
  def tags_too_large?(size, scenario:); end
end

# We want to exclude tags that we don't want to propagate downstream.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#148
Datadog::Tracing::Distributed::Datadog::EXCLUDED_TAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#16
Datadog::Tracing::Distributed::Datadog::ORIGIN_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#14
Datadog::Tracing::Distributed::Datadog::PARENT_ID_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#15
Datadog::Tracing::Distributed::Datadog::SAMPLING_PRIORITY_KEY = T.let(T.unsafe(nil), String)

# Distributed trace-level tags
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#18
Datadog::Tracing::Distributed::Datadog::TAGS_KEY = T.let(T.unsafe(nil), String)

# Prefix used by all Datadog-specific distributed tags
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#21
Datadog::Tracing::Distributed::Datadog::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#13
Datadog::Tracing::Distributed::Datadog::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# Encodes and decodes distributed 'x-datadog-tags' tags for transport
# to and from external processes.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#9
module Datadog::Tracing::Distributed::DatadogTagsCodec
  class << self
    # Deserializes a `x-datadog-tags`-formatted String into a {Hash<String,String>}.
    #
    # @param string [String] tags as serialized by {#encode}
    # @raise [DecodingError] if string does not conform to the `x-datadog-tags` format
    # @return [Hash<String,String>] decoded input as a hash of strings
    #
    # source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#55
    def decode(string); end

    # Serializes a {Hash<String,String>} into a `x-datadog-tags`-compatible
    # String.
    #
    # @param tags [Hash<String,String>] trace tag hash
    # @raise [EncodingError] if tags cannot be serialized to the `x-datadog-tags` format
    # @return [String] serialized tags hash
    #
    # source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#34
    def encode(tags); end
  end
end

# An error occurred during distributed tags decoding.
# See {#message} for more information.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#80
class Datadog::Tracing::Distributed::DatadogTagsCodec::DecodingError < ::StandardError; end

# An error occurred during distributed tags encoding.
# See {#message} for more information.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#75
class Datadog::Tracing::Distributed::DatadogTagsCodec::EncodingError < ::StandardError; end

# Backport `Regexp::match?` because it is measurably the most performant
# way to check if a string matches a regular expression.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#12
module Datadog::Tracing::Distributed::DatadogTagsCodec::RefineRegexp; end

# ASCII characters 32-126, except `,`, `=`, and ` `. At least one character.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#24
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# ASCII characters 32-126, except `,`. At least one character.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#26
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Common fetcher that retrieves fields from a Hash data input
#
# source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#10
class Datadog::Tracing::Distributed::Fetcher
  # @param data [Hash]
  # @return [Fetcher] a new instance of Fetcher
  #
  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#12
  def initialize(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#16
  def [](key); end

  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#20
  def id(key, base: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#24
  def number(key, base: T.unsafe(nil)); end
end

# Helpers module provides common helper functions for distributed tracing data
#
# source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#11
module Datadog::Tracing::Distributed::Helpers
  class << self
    # Base provides common methods for distributed helper classes
    #
    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#13
    def clamp_sampling_priority(sampling_priority); end

    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#24
    def truncate_base16_number(value); end

    # DEV: move `base` to a keyword argument
    #
    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#44
    def value_to_id(value, base = T.unsafe(nil)); end

    # DEV: move `base` to a keyword argument
    #
    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#57
    def value_to_number(value, base = T.unsafe(nil)); end
  end
end

# Propagator that does not inject nor extract data. It performs no operation.
# Supported for feature parity with OpenTelemetry.
#
# @see https://github.com/open-telemetry/opentelemetry-specification/blob/255a6c52b8914a2ed7e26bb5585abecab276aafc/specification/sdk-environment-variables.md?plain=1#L88
#
# source://ddtrace//lib/datadog/tracing/distributed/none.rb#10
class Datadog::Tracing::Distributed::None
  # No-op
  #
  # source://ddtrace//lib/datadog/tracing/distributed/none.rb#15
  def extract(_data); end

  # No-op
  #
  # source://ddtrace//lib/datadog/tracing/distributed/none.rb#12
  def inject!(_digest, _data); end
end

# Provides extraction and injection of distributed trace data.
#
# source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#12
class Datadog::Tracing::Distributed::Propagation
  # DEV: This class should receive the value for
  # DEV: `Datadog.configuration.tracing.distributed_tracing.propagation_inject_style`
  # DEV: at initialization time, instead of constantly reading global values.
  # DEV: This means this class should be reconfigured on `Datadog.configure` calls, thus
  # DEV: singleton instances should not used as they will become stale.
  #
  # @param propagation_styles [Hash<String,Object>]
  # @return [Propagation] a new instance of Propagation
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#20
  def initialize(propagation_styles:); end

  # extract returns {TraceDigest} containing the distributed trace information.
  # sampling priority defined in data.
  #
  # This method will never raise errors, but instead log them to `Datadog.logger`.
  #
  # @param data [Hash]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#75
  def extract(data); end

  # inject! populates the env with span ID, trace ID and sampling priority
  #
  # This method will never raise errors, but instead log them to `Datadog.logger`.
  #
  # DEV-2.0: inject! should work without arguments, injecting the active_trace's digest
  # DEV-2.0: and returning a new Hash with the injected data.
  # DEV-2.0: inject! should also accept either a `trace` or a `digest`, as a `trace`
  # DEV-2.0: argument is the common use case, but also allows us to set error tags in the `trace`
  # DEV-2.0: if needed.
  # DEV-2.0: Ideally, we'd have a separate stream to report tracer errors and never
  # DEV-2.0: touch the active span.
  #
  # @param digest [TraceDigest]
  # @param data [Hash]
  # @return [Boolean] `true` if injected successfully, `false` if no propagation style is configured
  # @return [nil] in case of error, see `Datadog.logger` output for details.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#40
  def inject!(digest, data); end
end

# W3C Trace Context propagator implementation, version 00.
# The trace is propagated through two fields: `traceparent` and `tracestate`.
#
# @see https://www.w3.org/TR/trace-context/
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#10
class Datadog::Tracing::Distributed::TraceContext
  # @return [TraceContext] a new instance of TraceContext
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#15
  def initialize(fetcher:, traceparent_key: T.unsafe(nil), tracestate_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#39
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#25
  def inject!(digest, data); end

  private

  # Sets the trace flag to an existing `trace_flags`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#122
  def build_trace_flags(digest); end

  # @see https://www.w3.org/TR/trace-context/#traceparent-header
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#94
  def build_traceparent(digest); end

  # For the current version (00), the traceparent has the following format:
  #
  # `"#{version}-#{trace_id}-#{parent_id}-#{trace_flags}"`
  #
  # Where:
  #   * `version`: 2 hex-encoded digits, zero padded.
  #   * `trace_id`: 32 hex-encoded digits, zero padded.
  #   * `parent_id`: 16 hex-encoded digits, zero padded.
  #   * `trace_flags`: 2 hex-encoded digits, zero padded.
  #
  # All hex values should be lowercase.
  #
  # @param trace_id [Integer] 128-bit
  # @param parent_id [Integer] 64-bit
  # @param trace_flags [Integer] 8-bit
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#117
  def build_traceparent_string(trace_id, parent_id, trace_flags); end

  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#137
  def build_tracestate(digest); end

  # Restore `:` back to `=`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#318
  def deserialize_tag_value(value); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#286
  def extract_datadog_fields(dd_tracestate); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#227
  def extract_traceparent(traceparent); end

  # @return [Array<String,Integer,String,Hash>] returns 4 values: tracestate, sampling_priority, origin, tags.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#268
  def extract_tracestate(tracestate); end

  # Datadog only allows 64 bits for the trace id.
  # We extract the lower 64 bits from the original 128-bit id.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#259
  def parse_datadog_trace_id(trace_id); end

  # If `sampled` and `sampling_priority` disagree, `sampled` overrides the decision.
  #
  # @return [Integer] one of the {Datadog::Tracing::Sampling::Ext::Priority} values
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#325
  def parse_priority_sampling(sampled, sampling_priority); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#263
  def parse_sampled_flag(trace_flags); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#239
  def parse_traceparent_string(traceparent); end

  # If any characters in <origin_value> are invalid, replace each invalid character with 0x5F (underscore).
  # Invalid characters are: characters outside the ASCII range 0x20 to 0x7E, 0x2C (comma), and 0x3D (equals).
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#185
  def serialize_origin(value); end

  # Serialize `_dd.p.{key}` by first removing the `_dd.p.` prefix.
  # Then replacing invalid characters with `_`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#198
  def serialize_tag_key(name); end

  # Replaces invalid characters with `_`, then replaces `=` with `:`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#212
  def serialize_tag_value(value); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#337
  def split_tracestate(tracestate); end
end

# Empty 8-bit `trace-flags`.
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#348
Datadog::Tracing::Distributed::TraceContext::DEFAULT_TRACE_FLAGS = T.let(T.unsafe(nil), Integer)

# Replace all characters with `_`, except ASCII characters 0x20-0x7E.
# Additionally, `,`, ';', and `=` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#363
Datadog::Tracing::Distributed::TraceContext::INVALID_ORIGIN_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x21-0x7E.
# Additionally, `,` and `=` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#368
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x20-0x7E.
# Additionally, `,`, ':' and `;` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#373
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Version 0xFF is invalid as per spec
#
# @see https://www.w3.org/TR/trace-context/#version
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#343
Datadog::Tracing::Distributed::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)

# Refinements to ensure newer rubies do not suffer performance impact
# by needing to use older APIs.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#67
module Datadog::Tracing::Distributed::TraceContext::Refine; end

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#13
Datadog::Tracing::Distributed::TraceContext::SPEC_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#11
Datadog::Tracing::Distributed::TraceContext::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#12
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# The limit is inclusive: sizes *greater* than 256 are disallowed.
#
# @see https://www.w3.org/TR/trace-context/#value
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#358
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_VALUE_SIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# Bit-mask for `trace-flags` that represents a sampled span (sampled==true).
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#353
Datadog::Tracing::Distributed::TraceContext::TRACE_FLAGS_SAMPLED = T.let(T.unsafe(nil), Integer)

# A simple pub-sub event model for components to exchange messages through.
#
# source://ddtrace//lib/datadog/tracing/event.rb#40
class Datadog::Tracing::Event
  # @return [Event] a new instance of Event
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#45
  def initialize(name); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#41
  def name; end

  # source://ddtrace//lib/datadog/tracing/event.rb#62
  def publish(*args); end

  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#50
  def subscribe(&block); end

  # Returns the value of attribute subscriptions.
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#41
  def subscriptions; end

  # source://ddtrace//lib/datadog/tracing/event.rb#56
  def unsubscribe_all!; end
end

# Event behavior and DSL
#
# source://ddtrace//lib/datadog/tracing/event.rb#8
module Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Events::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/event.rb#9
    def included(base); end
  end
end

# Class methods
#
# source://ddtrace//lib/datadog/tracing/event.rb#15
module Datadog::Tracing::Events::ClassMethods
  # source://ddtrace//lib/datadog/tracing/event.rb#16
  def build(**event_handlers); end
end

# Instance methods
#
# source://ddtrace//lib/datadog/tracing/event.rb#24
module Datadog::Tracing::Events::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/event.rb#25
  def subscribe(**event_handlers); end
end

# FiberLocalContext can be used as a tracer global reference to create
# a different {Datadog::Tracing::Context} for each fiber. This allows for the tracer
# to create a serial execution graph regardless of any concurrent execution: each
# concurrent execution path creates a new trace graph.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#48
class Datadog::Tracing::FiberLocalContext
  # To support multiple tracers simultaneously, each {Datadog::Tracing::FiberLocalContext}
  # instance has its own fiber-local variable.
  #
  # @return [FiberLocalContext] a new instance of FiberLocalContext
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#51
  def initialize; end

  # Return the fiber-local context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#63
  def local(storage = T.unsafe(nil)); end

  # Override the fiber-local context with a new context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#58
  def local=(ctx); end

  class << self
    # source://ddtrace//lib/datadog/tracing/context_provider.rb#77
    def next_instance_id; end
  end
end

# source://ddtrace//lib/datadog/tracing/context_provider.rb#73
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_GENERATOR = T.let(T.unsafe(nil), Datadog::Core::Utils::Sequence)

# Ensure two instances of {FiberLocalContext} do not conflict.
# We previously used {FiberLocalContext#object_id} to ensure uniqueness
# but the VM is allowed to reuse `object_id`, allow for the possibility that
# a new FiberLocalContext would be able to read an old FiberLocalContext's
# value.
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#72
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://ddtrace//lib/datadog/tracing/flush.rb#5
module Datadog::Tracing::Flush; end

# Consumes and returns a {TraceSegment} to be flushed, from
# the provided {TraceSegment}.
#
# Only finished spans are consumed. Any spans consumed are
# removed from +trace_op+ as a side effect. Unfinished spans are
# unaffected.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/flush.rb#14
class Datadog::Tracing::Flush::Base
  # Consumes and returns a {TraceSegment} to be flushed, from
  # the provided {TraceSegment}.
  #
  # Only finished spans are consumed. Any spans consumed are
  # removed from +trace_op+ as a side effect. Unfinished spans are
  # unaffected.
  #
  # @param trace_op [TraceOperation]
  # @return [TraceSegment] trace to be flushed, or +nil+ if the trace is not finished
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#24
  def consume!(trace_op); end

  # Should we consume spans from the +trace_op+?
  #
  # @abstract
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#32
  def flush?(trace_op); end

  protected

  # Consumes all finished spans from trace.
  #
  # @return [TraceSegment]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#40
  def get_trace(trace_op); end

  # Single Span Sampling has chosen to keep this span
  # regardless of the trace-level sampling decision
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#50
  def single_sampled?(span); end
end

# Consumes and returns completed traces (where all spans have finished),
# if any, from the provided +trace_op+.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://ddtrace//lib/datadog/tracing/flush.rb#59
class Datadog::Tracing::Flush::Finished < ::Datadog::Tracing::Flush::Base
  # Are all spans finished?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#61
  def flush?(trace_op); end
end

# Consumes and returns completed or partially completed
# traces from the provided +trace_op+, if any.
#
# Partial trace flushing avoids large traces residing in memory for too long.
#
# Partially completed traces, where not all spans have finished,
# will only be returned if there are at least
# +@min_spans_for_partial+ finished spans.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://ddtrace//lib/datadog/tracing/flush.rb#76
class Datadog::Tracing::Flush::Partial < ::Datadog::Tracing::Flush::Base
  # @return [Partial] a new instance of Partial
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#82
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#87
  def flush?(trace_op); end

  # Returns the value of attribute min_spans_for_partial.
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#80
  def min_spans_for_partial; end
end

# Start flushing partial trace after this many active spans in one trace
#
# source://ddtrace//lib/datadog/tracing/flush.rb#78
Datadog::Tracing::Flush::Partial::DEFAULT_MIN_SPANS_FOR_PARTIAL_FLUSH = T.let(T.unsafe(nil), Integer)

# Health metrics for trace buffers.
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#12
module Datadog::Tracing::MeasuredBuffer
  include ::Kernel

  # source://ddtrace//lib/datadog/tracing/buffer.rb#15
  def initialize(*_); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#24
  def add!(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#31
  def add_all!(traces); end

  # Stored traces are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/tracing/buffer.rb#49
  def drain!; end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#55
  def measure_accept(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#66
  def measure_drop(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#76
  def measure_pop(traces); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#38
  def replace!(trace); end
end

# Adds common tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#7
module Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/metadata.rb#11
    def included(base); end
  end
end

# Defines analytics tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/analytics.rb#10
module Datadog::Tracing::Metadata::Analytics
  # source://ddtrace//lib/datadog/tracing/metadata/analytics.rb#11
  def set_tag(key, value); end
end

# Adds error tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/errors.rb#12
module Datadog::Tracing::Metadata::Errors
  # Mark the span with the given error.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/errors.rb#14
  def set_error(e); end
end

# Trace and span tags that represent meta information
# regarding the trace. These fields are normally only used
# internally, and can have special meaning to downstream
# trace processing.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#13
module Datadog::Tracing::Metadata::Ext; end

# Defines constants for trace analytics
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#30
module Datadog::Tracing::Metadata::Ext::Analytics; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#31
Datadog::Tracing::Metadata::Ext::Analytics::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#32
Datadog::Tracing::Metadata::Ext::Analytics::TAG_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#33
Datadog::Tracing::Metadata::Ext::Analytics::TAG_MEASURED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#34
Datadog::Tracing::Metadata::Ext::Analytics::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#37
module Datadog::Tracing::Metadata::Ext::AppTypes; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#40
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#42
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CUSTOM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#39
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#38
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WEB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#41
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WORKER = T.let(T.unsafe(nil), String)

# Tags related to distributed tracing
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#47
module Datadog::Tracing::Metadata::Ext::Distributed; end

# Trace tags with this prefix will propagate from a trace through distributed tracing.
# Distributed headers tags with this prefix will be injected into the active trace.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#57
Datadog::Tracing::Metadata::Ext::Distributed::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# What mechanism was used to make this trace's sampling decision.
#
# @see Datadog::Tracing::Sampling::Ext::Mechanism
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#50
Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#52
Datadog::Tracing::Metadata::Ext::Distributed::TAG_ORIGIN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#53
Datadog::Tracing::Metadata::Ext::Distributed::TAG_SAMPLING_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#61
module Datadog::Tracing::Metadata::Ext::Errors; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#62
Datadog::Tracing::Metadata::Ext::Errors::STATUS = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#63
Datadog::Tracing::Metadata::Ext::Errors::TAG_MSG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#64
Datadog::Tracing::Metadata::Ext::Errors::TAG_STACK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#65
Datadog::Tracing::Metadata::Ext::Errors::TAG_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#69
module Datadog::Tracing::Metadata::Ext::HTTP; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#70
Datadog::Tracing::Metadata::Ext::HTTP::ERROR_RANGE = T.let(T.unsafe(nil), Range)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#81
Datadog::Tracing::Metadata::Ext::HTTP::HEADER_USER_AGENT = T.let(T.unsafe(nil), String)

# General header functionality
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#84
module Datadog::Tracing::Metadata::Ext::HTTP::Headers
  private

  # Normalizes an HTTP header string into a valid tag string.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#90
  def to_tag(name); end

  class << self
    # Normalizes an HTTP header string into a valid tag string.
    #
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#90
    def to_tag(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#87
Datadog::Tracing::Metadata::Ext::HTTP::Headers::INVALID_TAG_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# Request headers
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#115
module Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders
  private

  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#120
  def to_tag(name); end

  class << self
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#120
    def to_tag(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#116
Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders::PREFIX = T.let(T.unsafe(nil), String)

# Response headers
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#126
module Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders
  private

  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#131
  def to_tag(name); end

  class << self
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#131
    def to_tag(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#127
Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders::PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#71
Datadog::Tracing::Metadata::Ext::HTTP::TAG_BASE_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#80
Datadog::Tracing::Metadata::Ext::HTTP::TAG_CLIENT_IP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#72
Datadog::Tracing::Metadata::Ext::HTTP::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#73
Datadog::Tracing::Metadata::Ext::HTTP::TAG_STATUS_CODE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#75
Datadog::Tracing::Metadata::Ext::HTTP::TAG_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#74
Datadog::Tracing::Metadata::Ext::HTTP::TAG_USER_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#76
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_INBOUND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#77
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_OUTBOUND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#78
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#79
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#138
module Datadog::Tracing::Metadata::Ext::NET; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#142
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#143
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#139
Datadog::Tracing::Metadata::Ext::NET::TAG_HOSTNAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#140
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#141
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#162
module Datadog::Tracing::Metadata::Ext::SQL; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#164
Datadog::Tracing::Metadata::Ext::SQL::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#163
Datadog::Tracing::Metadata::Ext::SQL::TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#147
module Datadog::Tracing::Metadata::Ext::Sampling; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#148
Datadog::Tracing::Metadata::Ext::Sampling::TAG_AGENT_RATE = T.let(T.unsafe(nil), String)

# If rate limiting is checked on a span, set this metric the effective rate limiting rate applied.
# This should be done regardless of rate limiting outcome.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#156
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RATE_LIMITER_RATE = T.let(T.unsafe(nil), String)

# If rule sampling is applied to a span, set this metric the sample rate configured for that rule.
# This should be done regardless of sampling outcome.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#152
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RULE_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#158
Datadog::Tracing::Metadata::Ext::Sampling::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#168
module Datadog::Tracing::Metadata::Ext::SpanKind; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#170
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#172
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#173
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_INTERNAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#171
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_PRODUCER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#169
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_SERVER = T.let(T.unsafe(nil), String)

# Name of package that was instrumented
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#15
Datadog::Tracing::Metadata::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#23
Datadog::Tracing::Metadata::Ext::TAG_KIND = T.let(T.unsafe(nil), String)

# Type of operation being performed (e.g. )
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#17
Datadog::Tracing::Metadata::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# Hostname of external service interacted with
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#19
Datadog::Tracing::Metadata::Ext::TAG_PEER_HOSTNAME = T.let(T.unsafe(nil), String)

# Name of external service that performed the work
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#21
Datadog::Tracing::Metadata::Ext::TAG_PEER_SERVICE = T.let(T.unsafe(nil), String)

# Set this tag to `1.0` if the span is a Service Entry span.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#26
Datadog::Tracing::Metadata::Ext::TAG_TOP_LEVEL = T.let(T.unsafe(nil), String)

# Adds metadata & metric tag behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#12
module Datadog::Tracing::Metadata::Tagging
  # Return the tag with the given key, nil if it doesn't exist.
  # Convenient interface for getting a single tag.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#28
  def [](key); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  # Convenient interface for setting a single tag.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#36
  def []=(key, value = T.unsafe(nil)); end

  # This method removes a metric for the given key. It acts like {#clear_tag}.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#109
  def clear_metric(key); end

  # This method removes a tag for the given key.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#78
  def clear_tag(key); end

  # Return the metric with the given key, nil if it doesn't exist.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#89
  def get_metric(key); end

  # Return the tag with the given key, nil if it doesn't exist.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#28
  def get_tag(key); end

  # Returns true if the provided `tag` was set to a non-nil value.
  # False otherwise.
  #
  # @param tag [String] the tag or metric to check for presence
  # @return [Boolean] if the tag is present and not nil
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#73
  def has_tag?(tag); end

  # This method sets a tag with a floating point value for the given key. It acts
  # like `set_tag()` and it simply add a tag without further processing.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#95
  def set_metric(key, value); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#36
  def set_tag(key, value = T.unsafe(nil)); end

  # Sets tags from given hash, for each key in hash it sets the tag with that key
  # and associated value from the hash. It is shortcut for `set_tag`. Keys and values
  # of the hash must be strings. Note that nested hashes are not supported.
  # A valid example is:
  #
  #   span.set_tags({ "http.method" => "GET", "user.id" => "234" })
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#64
  def set_tags(tags); end

  # Returns a copy of all metadata.
  # Keys for `@meta` and `@metrics` don't collide, by construction.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#115
  def tags; end

  protected

  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#121
  def meta; end

  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#125
  def metrics; end
end

# Some associated values should always be sent as Tags, never as Metrics, regardless
# if their value is numeric or not.
# The Datadog agent will look for these values only as Tags, not Metrics.
#
# @see https://github.com/DataDog/datadog-agent/blob/2ae2cdd315bcda53166dd8fa0dedcfc448087b9d/pkg/trace/stats/aggregation.go#L13-L17
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#20
Datadog::Tracing::Metadata::Tagging::ENSURE_AGENT_TAGS = T.let(T.unsafe(nil), Hash)

# This limit is for numeric tags because uint64 could end up rounded.
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#14
Datadog::Tracing::Metadata::Tagging::NUMERIC_TAG_SIZE_RANGE = T.let(T.unsafe(nil), Range)

# Modifies traces through a set of filters and processors
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#5
module Datadog::Tracing::Pipeline
  class << self
    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://ddtrace//lib/datadog/tracing/pipeline.rb#27
    def before_flush(*processors, &processor_block); end

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#35
    def process!(traces); end

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#43
    def processors=(value); end

    private

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#47
    def apply_processors!(trace); end
  end
end

# SpanFilter implements a processor that filters entire span subtrees
# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# If `operation` returns a truthy value for a span, that span is kept,
# otherwise the span is removed from the trace.
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#17
class Datadog::Tracing::Pipeline::SpanFilter < ::Datadog::Tracing::Pipeline::SpanProcessor
  # NOTE: This SpanFilter implementation only handles traces in which child spans appear
  # before parent spans in the trace array. If in the future child spans can be after
  # parent spans, then the code below will need to be updated.
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#22
  def call(trace); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#40
  def drop_it?(span); end
end

# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#10
class Datadog::Tracing::Pipeline::SpanProcessor
  # You can either provide an `operation` object or a block to this method.
  #
  # Both have the same semantics as `operation`.
  # `operation` is used if both `operation` and a block are present.
  #
  # @param operation [#call(Datadog::Tracing::Span)] a callable that can modify the span.
  # @raise [ArgumentError]
  # @return [SpanProcessor] a new instance of SpanProcessor
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#17
  def initialize(operation = T.unsafe(nil), &block); end

  # Invokes `operation#call` for each spans in the `trace` argument.
  #
  # @param trace [Datadog::Tracing::TraceSegment] a trace segment.
  # @return [Datadog::Tracing::TraceSegment] the `trace` provided as an argument.
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#29
  def call(trace); end
end

# source://ddtrace//lib/datadog/tracing/propagation/http.rb#7
module Datadog::Tracing::Propagation; end

# Propagation::HTTP helps extracting and injecting HTTP headers.
# DEV-2.0: This file has been moved to Contrib. Should be deleted in the next release.
#
# source://ddtrace//lib/datadog/tracing/propagation/http.rb#11
Datadog::Tracing::Propagation::HTTP = T.let(T.unsafe(nil), Datadog::Tracing::Contrib::HTTP::Distributed::Propagation)

# source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#7
module Datadog::Tracing::Runtime; end

# Decorates runtime metrics feature
#
# source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#9
module Datadog::Tracing::Runtime::Metrics
  class << self
    # source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#10
    def associate_trace(trace); end
  end
end

# source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#5
module Datadog::Tracing::Sampling; end

# {Datadog::Tracing::Sampling::AllSampler} samples all the traces.
#
# source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#10
class Datadog::Tracing::Sampling::AllSampler < ::Datadog::Tracing::Sampling::Sampler
  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#15
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#11
  def sample?(_trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#19
  def sample_rate(*_); end
end

# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#8
module Datadog::Tracing::Sampling::Ext; end

# List of how the decision was made for the trace-level sampling.
#
# These values used to populate the {Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER} tag.
#
# The decision has two parts, separated by a `-`:
# `part1-sampling_mechanism`. `part1` is currently not populated, thus
# this tag is currently formatted as `"-sampling_mechanism"`.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#40
module Datadog::Tracing::Sampling::Ext::Decision; end

# The sampling rate received in the agent's http response.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#44
Datadog::Tracing::Sampling::Ext::Decision::AGENT_RATE = T.let(T.unsafe(nil), String)

# Formerly AppSec.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#51
Datadog::Tracing::Sampling::Ext::Decision::ASM = T.let(T.unsafe(nil), String)

# Used before the tracer receives any rates from agent and there are no rules configured.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#42
Datadog::Tracing::Sampling::Ext::Decision::DEFAULT = T.let(T.unsafe(nil), String)

# User directly sets sampling priority via {Tracing.reject!} or {Tracing.keep!},
# or by a custom sampler implementation.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#49
Datadog::Tracing::Sampling::Ext::Decision::MANUAL = T.let(T.unsafe(nil), String)

# Single Span Sampled.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#53
Datadog::Tracing::Sampling::Ext::Decision::SPAN_SAMPLING_RATE = T.let(T.unsafe(nil), String)

# Sampling rule or sampling rate based on tracer config.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#46
Datadog::Tracing::Sampling::Ext::Decision::TRACE_SAMPLING_RULE = T.let(T.unsafe(nil), String)

# List of what mechanism was used to make the trace-level sampling decision.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#28
module Datadog::Tracing::Sampling::Ext::Mechanism; end

# Single Span Sampled.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#30
Datadog::Tracing::Sampling::Ext::Mechanism::SPAN_SAMPLING_RATE = T.let(T.unsafe(nil), Integer)

# Priority is a hint given to the backend so that it knows which traces to reject or kept.
# In a distributed context, it should be set before any context propagation (fork, RPC calls) to be effective.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#12
module Datadog::Tracing::Sampling::Ext::Priority; end

# Used by the {PrioritySampler} to inform the backend that a trace should be kept and stored.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#20
Datadog::Tracing::Sampling::Ext::Priority::AUTO_KEEP = T.let(T.unsafe(nil), Integer)

# Used by the {PrioritySampler} to inform the backend that a trace should be rejected and not stored.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#18
Datadog::Tracing::Sampling::Ext::Priority::AUTO_REJECT = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be kept and stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#24
Datadog::Tracing::Sampling::Ext::Priority::USER_KEEP = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be rejected and not stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#16
Datadog::Tracing::Sampling::Ext::Priority::USER_REJECT = T.let(T.unsafe(nil), Integer)

# Checks if a trace conforms to a matching criteria.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#9
class Datadog::Tracing::Sampling::Matcher
  # Returns `true` if the trace should conforms to this rule, `false` otherwise
  #
  # @param trace [TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#14
  def match?(trace); end
end

# {Datadog::Tracing::Sampling::PrioritySampler}
#
# source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#13
class Datadog::Tracing::Sampling::PrioritySampler
  # @return [PrioritySampler] a new instance of PrioritySampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#22
  def initialize(opts = T.unsafe(nil)); end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#20
  def pre_sampler; end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#20
  def priority_sampler; end

  # DEV-2.0:We should get rid of this complicated interaction between @pre_sampler and @priority_sampler.
  # DEV-2.0:If the user wants to configure a custom sampler, we should only allow them to provide a complete
  # DEV-2.0:sampling suite, not having this convoluted support for mixing arbitrary provided samplers in
  # DEV-2.0:the PrioritySampler. Ideally, the PrioritySampler is only used by Datadog.
  # DEV-2.0:There are too many edge cases and combinations to work around currently in this class.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#36
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#27
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#84
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#159
  def assign_priority!(trace, priority); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#101
  def pre_sample?(trace); end

  # Ensures the trace's priority sampling decision is not changed by the @pre_sampler.
  # The @pre_sampler should only change `trace.sampled`.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#124
  def preserving_priority_sampling(trace); end

  # Ensures the trace is always propagated to the writer and that
  # the sample rate metric represents the true client-side sampling.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#141
  def preserving_sampling(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#112
  def priority_assigned?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#116
  def priority_sample!(trace); end

  class << self
    # Check if the Priority Sampling decision is to keep or drop the trace.
    # Other factors can influence the sampling decision; this method is only
    # responsible for interpreting the Sampling Priority decision.
    #
    # @param priority_sampling [Integer] priority sampling number
    # @return [Boolean] true if trace is "kept" by priority sampling
    # @return [Boolean] false if trace is "dropped" by priority sampling
    #
    # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#95
    def sampled?(priority_sampling); end
  end
end

# A {Datadog::Tracing::Sampling::Matcher} that allows for arbitrary trace matching
# based on the return value of a provided block.
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#52
class Datadog::Tracing::Sampling::ProcMatcher < ::Datadog::Tracing::Sampling::Matcher
  # @return [ProcMatcher] a new instance of ProcMatcher
  # @yield [name, service] Provides trace name and service to the block
  # @yieldreturn [Boolean] Whether the trace conforms to this matcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#57
  def initialize(&block); end

  # Returns the value of attribute block.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#53
  def block; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#62
  def match?(trace); end
end

# Samples at different rates by key.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#11
class Datadog::Tracing::Sampling::RateByKeySampler < ::Datadog::Tracing::Sampling::Sampler
  # @raise [ArgumentError]
  # @return [RateByKeySampler] a new instance of RateByKeySampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#15
  def initialize(default_key, default_rate = T.unsafe(nil), decision: T.unsafe(nil), &block); end

  # Returns the value of attribute default_key.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#12
  def default_key; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#32
  def default_sampler; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#72
  def delete(key); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#78
  def delete_if(&block); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#84
  def length; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#28
  def resolve(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#44
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#36
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#52
  def sample_rate(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#60
  def update(key, rate, decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#66
  def update_all(rate_by_key, decision: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#90
  def set_rate(key, rate, decision); end
end

# {Datadog::Tracing::Sampling::RateByServiceSampler} samples different services at different rates
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#11
class Datadog::Tracing::Sampling::RateByServiceSampler < ::Datadog::Tracing::Sampling::RateByKeySampler
  # @return [RateByServiceSampler] a new instance of RateByServiceSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#14
  def initialize(default_rate = T.unsafe(nil), env: T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#25
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # DEV: Creating a string on every trace to perform a single Hash lookup is expensive.
  #
  # Using 2 nested hashes: 1 for env and 1 for service is the fastest option.
  # This approach requires large API changes to `RateByKeySampler`.
  #
  # Reducing the interpolated string size, by using a 1 character separator,
  # is also measurably faster than the current method. This approach does not
  # require changes to `RateByKeySampler`.
  #
  # Keep in mind that these changes also require changes to `#update`.
  #
  # Comparison:
  #  2 nested hashes: `service_hash.fetch(service, {}).fetch(env, default_rate)`
  #                   7730045 i/s
  # 1 char separator: `hash.fetch("#{service}\0#{env}", default_rate)`
  #                   4302801 i/s - 1.80x slower
  #          current: `hash.fetch("service:#{service},env:#{env}", default_rate)`
  #                   2720459 i/s - 2.84x slower
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#56
  def key_for(trace); end
end

# source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#12
Datadog::Tracing::Sampling::RateByServiceSampler::DEFAULT_KEY = T.let(T.unsafe(nil), String)

# Checks for rate limiting on a resource.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#10
class Datadog::Tracing::Sampling::RateLimiter
  # Checks if resource of specified size can be
  # conforms with the current limit.
  #
  # Implementations of this method are not guaranteed
  # to be side-effect free.
  #
  # @return [Boolean] whether a resource conforms with the current limit
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#18
  def allow?(size); end

  # The effective rate limiting ratio based on
  # recent calls to `allow?`.
  #
  # @return [Float] recent allowance ratio
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#24
  def effective_rate; end
end

# {Datadog::Tracing::Sampling::RateSampler} is based on a sample rate.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#13
class Datadog::Tracing::Sampling::RateSampler < ::Datadog::Tracing::Sampling::Sampler
  # Initialize a {Datadog::Tracing::Sampling::RateSampler}.
  # This sampler keeps a random subset of the traces. Its main purpose is to
  # reduce the instrumentation footprint.
  #
  # * +sample_rate+: the sample rate as a {Float} between 0.0 and 1.0. 0.0
  #   means that no trace will be sampled; 1.0 means that all traces will be
  #   sampled.
  #
  # DEV-2.0: Allow for `sample_rate` zero (drop all) to be allowed. This eases
  # DEV-2.0: usage for all internal users of the {RateSampler} class: both
  # DEV-2.0: RuleSampler and Single Span Sampling leverage the RateSampler, but want
  # DEV-2.0: `sample_rate` zero to mean "drop all". They work around this by hard-
  # DEV-2.0: setting the `sample_rate` to zero like so:
  # DEV-2.0: ```
  # DEV-2.0: sampler = RateSampler.new
  # DEV-2.0: sampler.sample_rate = sample_rate
  # DEV-2.0: ```
  #
  # @return [RateSampler] a new instance of RateSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#33
  def initialize(sample_rate = T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#59
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#55
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#46
  def sample_rate(*_); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#50
  def sample_rate=(sample_rate); end
end

# source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#14
Datadog::Tracing::Sampling::RateSampler::KNUTH_FACTOR = T.let(T.unsafe(nil), Integer)

# Sampling rule that dictates if a trace matches
# a specific criteria and what sampling strategy to
# apply in case of a positive match.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule.rb#15
class Datadog::Tracing::Sampling::Rule
  # @param matcher [Matcher] A matcher to verify trace conformity against
  # @param sampler [Sampler] A sampler to be consulted on a positive match
  # @return [Rule] a new instance of Rule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#20
  def initialize(matcher, sampler); end

  # Evaluates if the provided `trace` conforms to the `matcher`.
  #
  # @param trace [TraceOperation]
  # @return [Boolean] whether this rules applies to the trace
  # @return [NilClass] if the matcher fails errs during evaluation
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#30
  def match?(trace); end

  # Returns the value of attribute matcher.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#16
  def matcher; end

  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *must not* modify the `trace`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#40
  def sample?(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#45
  def sample_rate(trace); end

  # Returns the value of attribute sampler.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#16
  def sampler; end
end

# Span {Sampler} that applies a set of {Rule}s to decide
# on sampling outcome. Then, a rate limiter is applied.
#
# If a trace does not conform to any rules, a default
# sampling strategy is applied.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#18
class Datadog::Tracing::Sampling::RuleSampler
  # @param rules [Array<Rule>] ordered list of rules to be applied to a trace
  # @param rate_limit [Float] number of traces per second, defaults to +100+
  # @param rate_limiter [RateLimiter] limiter applied after rule matching
  # @param default_sample_rate [Float] fallback sample rate when no rules apply to a trace,
  #   between +[0,1]+, defaults to +1+
  # @param default_sampler [Sample] fallback strategy when no rules apply to a trace
  # @return [RuleSampler] a new instance of RuleSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#27
  def initialize(rules = T.unsafe(nil), rate_limit: T.unsafe(nil), rate_limiter: T.unsafe(nil), default_sample_rate: T.unsafe(nil), default_sampler: T.unsafe(nil)); end

  # Returns the value of attribute default_sampler.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#19
  def default_sampler; end

  # Returns the value of attribute rate_limiter.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#19
  def rate_limiter; end

  # Returns the value of attribute rules.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#19
  def rules; end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#65
  def sample!(trace); end

  # /RuleSampler's components (it's rate limiter, for example) are
  # not be guaranteed to be size-effect free.
  # It is not possible to guarantee that a call to {#sample?} will
  # return the same result as a successive call to {#sample!} with the same trace.
  #
  # Use {#sample!} instead
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#61
  def sample?(_trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#79
  def update(*args, **kwargs); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#87
  def sample_trace(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#126
  def set_limiter_metrics(trace, limiter_rate); end

  # Span priority should only be set when the {RuleSampler}
  # was responsible for the sampling decision.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#114
  def set_priority(trace, sampled); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#122
  def set_rule_metrics(trace, sample_rate); end
end

# Interface for client-side trace sampling.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#9
class Datadog::Tracing::Sampling::Sampler
  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *may* modify the `trace`, in case changes are necessary based on the
  # sampling decision.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#29
  def sample!(trace); end

  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *must not* modify the `trace`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#17
  def sample?(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#38
  def sample_rate(trace); end
end

# A {Datadog::Sampling::Matcher} that supports matching a trace by
# trace name and/or service name.
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#22
class Datadog::Tracing::Sampling::SimpleMatcher < ::Datadog::Tracing::Sampling::Matcher
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name,
  #   defaults to always match
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @return [SimpleMatcher] a new instance of SimpleMatcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#38
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#44
  def match?(trace); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#32
  def name; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#32
  def service; end
end

# Returns `true` for case equality (===) with any object
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#24
Datadog::Tracing::Sampling::SimpleMatcher::MATCH_ALL = T.let(T.unsafe(nil), T.untyped)

# A {Datadog::Tracing::Sampling::Rule} that matches a trace based on
# trace name and/or service name and
# applies a fixed sampling to matching spans.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule.rb#54
class Datadog::Tracing::Sampling::SimpleRule < ::Datadog::Tracing::Sampling::Rule
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name, defaults to always match
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @param sample_rate [Float] Sampling rate between +[0,1]+
  # @return [SimpleRule] a new instance of SimpleRule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#59
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil), sample_rate: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#4
module Datadog::Tracing::Sampling::Span; end

# Single Span Sampling constants.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#8
module Datadog::Tracing::Sampling::Span::Ext; end

# Unlimited.
#
# @see Datadog::Tracing::Sampling::TokenBucket
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#13
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_MAX_PER_SECOND = T.let(T.unsafe(nil), Integer)

# Accept all spans (100% retention).
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#10
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# Rate limit configured for this span, if a rule applies
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#20
Datadog::Tracing::Sampling::Span::Ext::TAG_MAX_PER_SECOND = T.let(T.unsafe(nil), String)

# Sampling decision method used to come to the sampling decision for this span
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#16
Datadog::Tracing::Sampling::Span::Ext::TAG_MECHANISM = T.let(T.unsafe(nil), String)

# Sampling rate applied to this span, if a rule applies
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#18
Datadog::Tracing::Sampling::Span::Ext::TAG_RULE_RATE = T.let(T.unsafe(nil), String)

# Checks if a span conforms to a matching criteria.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#8
class Datadog::Tracing::Sampling::Span::Matcher
  # Matches span name and service to their respective patterns provided.
  #
  # The patterns are {String}s with two special characters available:
  # 1. `?`: matches exactly one of any character.
  # 2. `*`: matches a substring of any size, including zero.
  # These patterns can occur any point of the string, any number of times.
  #
  # Both {SpanOperation#name} and {SpanOperation#service} must match the provided patterns.
  #
  # The whole String has to match the provided patterns: providing a pattern that
  # matches a portion of the provided String is not considered a match.
  #
  # @example web-*
  #   `'web-*'` will match any string starting with `web-`.
  # @example cache-?
  #   `'cache-?'` will match any string starting with `database-` followed by exactly one character.
  # @param name_pattern [String] a pattern to be matched against {SpanOperation#name}
  # @param service_pattern [String] a pattern to be matched against {SpanOperation#service}
  # @return [Matcher] a new instance of Matcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#33
  def initialize(name_pattern: T.unsafe(nil), service_pattern: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#59
  def ==(other); end

  # DEV: Remove when support for Ruby 2.3 and older is removed.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#47
  def match?(span); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#9
  def name; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#9
  def service; end

  private

  # @param pattern [String]
  # @return [Regexp]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#70
  def pattern_to_regex(pattern); end
end

# Pattern that matches any string
#
# source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#12
Datadog::Tracing::Sampling::Span::Matcher::MATCH_ALL_PATTERN = T.let(T.unsafe(nil), String)

# Span sampling rule that applies a sampling rate if the span
# matches the provided {Matcher}.
# Additionally, a rate limiter is also applied.
#
# If a span does not conform to the matcher, no changes are made.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#14
class Datadog::Tracing::Sampling::Span::Rule
  # Creates a new span sampling rule.
  #
  # @param matcher [Sampling::Span::Matcher] whether this rule applies to a specific span
  # @param sample_rate [Float] span sampling ratio, between 0.0 (0%) and 1.0 (100%).
  # @param rate_limit [Numeric] maximum number of spans sampled per second. Negative numbers mean unlimited spans.
  # @return [Rule] a new instance of Rule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#22
  def initialize(matcher, sample_rate: T.unsafe(nil), rate_limit: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#71
  def ==(other); end

  # Returns the value of attribute matcher.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def matcher; end

  # Returns the value of attribute rate_limit.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def rate_limit; end

  # This method should only be invoked for spans that are part
  # of a trace that has been dropped by trace-level sampling.
  # Invoking it for other spans will cause incorrect sampling
  # metrics to be reported by the Datadog App.
  #
  # Returns `true` if the provided span is sampled.
  # If the span is dropped due to sampling rate or rate limiting,
  # it returns `false`.
  #
  # Returns `nil` if the span did not meet the matching criteria by the
  # provided matcher.
  #
  # This method modifies the `span` if it matches the provided matcher.
  #
  # @param span_op [Datadog::Tracing::SpanOperation] span to be sampled
  # @return [:kept, :rejected] should this span be sampled?
  # @return [:not_matched] span did not satisfy the matcher, no changes are made to the span
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#58
  def sample!(span_op); end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def sample_rate; end
end

# Converts user configuration into {Datadog::Tracing::Sampling::Span::Rule} objects,
# handling any parsing errors.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#15
module Datadog::Tracing::Sampling::Span::RuleParser
  class << self
    # Parses the provided JSON string containing the Single Span
    # Sampling configuration list.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#24
    def parse_json(rules); end

    # Parses a list of Hashes containing the parsed JSON information
    # for Single Span Sampling configuration.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [Array<String] the JSON configuration rules to be parsed] ules [Array<String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#47
    def parse_list(rules); end

    private

    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#76
    def parse_rule(hash); end
  end
end

# Applies Single Span Sampling rules to spans.
# When matching the configured rules, a span is ensured to
# be processed Datadog App. In other words, a single sampled span
# will never be dropped by the tracer or Datadog agent.
#
# All spans in a trace are subject to the single sampling rules, if
# any rules are configured.
#
# Single Span Sampling is distinct from trace-level sampling:
# Single Span Sampling can ensure a span is kept, even if its
# enclosing trace is rejected by trace-level sampling.
#
# This class only applies operations to spans that are part
# of traces that was rejected by trace sampling.
# A trace is rejected if either of the following conditions is true:
# * The priority sampling for a trace is set to either {USER_REJECT} or {AUTO_REJECT}.
# * The trace was rejected by internal sampling, thus never flushed.
#
# Single-sampled spans are tagged and the tracer ensures they will
# reach the Datadog App, regardless of their enclosing trace sampling decision.
#
# Single Span Sampling does not inspect spans that are part of a trace
# that has been accepted by trace-level sampling rules: all spans from such
# trace are guaranteed to reach the Datadog App.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#29
class Datadog::Tracing::Sampling::Span::Sampler
  # Receives sampling rules to apply to individual spans.
  #
  # @param rules [Array<Datadog::Tracing::Sampling::Span::Rule>] list of rules to apply to spans
  # @return [Sampler] a new instance of Sampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#35
  def initialize(rules = T.unsafe(nil)); end

  # Returns the value of attribute rules.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#30
  def rules; end

  # Applies Single Span Sampling rules to the span if the trace has been rejected.
  #
  # The trace can be outright rejected, and never reach the transport,
  # or be set as rejected by priority sampling. In both cases, the trace
  # is considered rejected for Single Span Sampling purposes.
  #
  # If multiple rules match, only the first one is applied.
  #
  # @param trace_op [Datadog::Tracing::TraceOperation] trace for the provided span
  # @param span_op [Datadog::Tracing::SpanOperation] Span to apply sampling rules
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#50
  def sample!(trace_op, span_op); end
end

# Implementation of the Token Bucket metering algorithm
# for rate limiting.
#
# @see https://en.wikipedia.org/wiki/Token_bucket Token bucket
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#32
class Datadog::Tracing::Sampling::TokenBucket < ::Datadog::Tracing::Sampling::RateLimiter
  # @param rate [Numeric] Allowance rate, in units per second
  #   if rate is negative, always allow
  #   if rate is zero, never allow
  # @param max_tokens [Numeric] Limit of available tokens
  # @raise [ArgumentError]
  # @return [TokenBucket] a new instance of TokenBucket
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#39
  def initialize(rate, max_tokens = T.unsafe(nil)); end

  # Checks if a message of provided +size+
  # conforms with the current bucket limit.
  #
  # If it does, return +true+ and remove +size+
  # tokens from the bucket.
  # If it does not, return +false+ without affecting
  # the tokens from the bucket.
  #
  # @return [Boolean] +true+ if message conforms with current bucket limit
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#67
  def allow?(size); end

  # @return [Numeric] number of tokens currently available
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#101
  def available_tokens; end

  # Ratio of 'conformance' per 'total messages' checked
  # on this bucket
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#94
  def current_window_rate; end

  # Ratio of 'conformance' per 'total messages' checked
  # averaged for the past 2 buckets
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#79
  def effective_rate; end

  # Returns the value of attribute max_tokens.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#33
  def max_tokens; end

  # Returns the value of attribute rate.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#33
  def rate; end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#127
  def increment_conforming_count; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#123
  def increment_total_count; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#107
  def refill_since_last_message; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#118
  def refill_tokens(size); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#131
  def should_allow?(size); end

  # Sets and Updates the past two 1 second windows for which
  # the rate limiter must compute it's rate over and updates
  # the total count, and conforming message count if +allowed+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#151
  def update_rate_counts(allowed); end
end

# {Datadog::Tracing::Sampling::RateLimiter} that accepts all resources,
# with no limits.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#175
class Datadog::Tracing::Sampling::UnlimitedLimiter < ::Datadog::Tracing::Sampling::RateLimiter
  # @return [Boolean] always +true+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#177
  def allow?(_); end

  # @return [Float] always 100%
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#182
  def effective_rate; end
end

# Represents a logical unit of work in the system. Each trace consists of one or more spans.
# Each span consists of a start time and a duration. For example, a span can describe the time
# spent on a distributed call on a separate machine, or the time spent in a small component
# within a larger operation. Spans can be nested within each other, and in those instances
# will have a parent-child relationship.
#
# source://ddtrace//lib/datadog/tracing/span.rb#19
class Datadog::Tracing::Span
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  # Create a new span manually. Call the <tt>start()</tt> method to start the time
  # measurement and then <tt>stop()</tt> once the timing operation is over.
  #
  # * +service+: the service name for this span
  # * +resource+: the resource this span refers, or +name+ if it's missing.
  #     +nil+ can be used as a placeholder, when the resource value is not yet known at +#initialize+ time.
  # * +type+: the type of the span (such as +http+, +db+ and so on)
  # * +parent_id+: the identifier of the parent span
  # * +trace_id+: the identifier of the root span for this trace
  # * +service_entry+: whether it is a service entry span.
  # TODO: Remove span_type
  #
  # @return [Span] a new instance of Span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#55
  def initialize(name, duration: T.unsafe(nil), end_time: T.unsafe(nil), id: T.unsafe(nil), meta: T.unsafe(nil), metrics: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), span_type: T.unsafe(nil), start_time: T.unsafe(nil), status: T.unsafe(nil), type: T.unsafe(nil), trace_id: T.unsafe(nil), service_entry: T.unsafe(nil)); end

  # Spans with the same ID are considered the same span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#124
  def ==(other); end

  # source://ddtrace//lib/datadog/tracing/span.rb#113
  def duration; end

  # Sets the attribute duration
  #
  # @param value the value to set the attribute duration to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#36
  def duration=(_arg0); end

  # Returns the value of attribute end_time.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def end_time; end

  # Sets the attribute end_time
  #
  # @param value the value to set the attribute end_time to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def end_time=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#108
  def finished?; end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def id=(_arg0); end

  # Returns the value of attribute meta.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def meta; end

  # Sets the attribute meta
  #
  # @param value the value to set the attribute meta to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def meta=(_arg0); end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def metrics; end

  # Sets the attribute metrics
  #
  # @param value the value to set the attribute metrics to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def metrics=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def name=(_arg0); end

  # Returns the value of attribute parent_id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def parent_id; end

  # Sets the attribute parent_id
  #
  # @param value the value to set the attribute parent_id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def parent_id=(_arg0); end

  # Return a human readable version of the span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#160
  def pretty_print(q); end

  # Returns the value of attribute resource.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def resource=(_arg0); end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def service=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/span.rb#118
  def set_error(e); end

  # Returns the value of attribute id.
  # For backwards compatiblity
  # TODO: Deprecate and remove these.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def span_id; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def span_type; end

  # Returns the value of attribute start_time.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def start_time; end

  # Sets the attribute start_time
  #
  # @param value the value to set the attribute start_time to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def start_time=(_arg0); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#103
  def started?; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def status=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#108
  def stopped?; end

  # Return the hash representation of the current span.
  # TODO: Change this to reflect attributes when serialization
  # isn't handled by this method.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#137
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#130
  def to_s; end

  # Returns the value of attribute trace_id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def trace_id; end

  # Sets the attribute trace_id
  #
  # @param value the value to set the attribute trace_id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def trace_id=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#22
  def type=(_arg0); end

  private

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#201
  def duration_nano; end

  # https://docs.datadoghq.com/tracing/visualization/#service-entry-span
  # A span is a service entry span when it is the entrypoint method for a request to a service.
  # You can visualize this within Datadog APM when the color of the immediate parent on a flame graph is a different
  # color. Services are also listed on the right when viewing a flame graph.
  #
  # @return [Boolean] `true` if the span is a serivce entry span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#211
  def service_entry?; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#195
  def start_time_nano; end
end

# Represents the act of taking a span measurement.
# It gives a Span a context which can be used to
# build a Span. When completed, it yields the Span.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#23
class Datadog::Tracing::SpanOperation
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  # @return [SpanOperation] a new instance of SpanOperation
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#42
  def initialize(name, child_of: T.unsafe(nil), events: T.unsafe(nil), on_error: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), trace_id: T.unsafe(nil), type: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#266
  def duration; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def end_time; end

  # for backwards compatibility
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#241
  def end_time=(time); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#245
  def finish(end_time = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#262
  def finished?; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def id; end

  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#133
  def measure; end

  # Operation name.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def name; end

  # Operation name.
  #
  # @raise [ArgumentError]
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#106
  def name=(name); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def parent_id; end

  # Return a human readable version of the span
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#305
  def pretty_print(q); end

  # Span resource.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def resource; end

  # Span resource.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#129
  def resource=(resource); end

  # Service name.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def service; end

  # Service name.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#122
  def service=(service); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#271
  def set_error(e); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  # For backwards compatibility
  # TODO: Deprecate and remove these in 2.0.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def span_id; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def span_type; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#115
  def span_type=(type); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#187
  def start(start_time = T.unsafe(nil)); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def start_time; end

  # for backwards compatibility
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#236
  def start_time=(time); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#226
  def started?; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#39
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#39
  def status=(_arg0); end

  # Mark the span stopped at the current time
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#202
  def stop(stop_time = T.unsafe(nil)); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#231
  def stopped?; end

  # Return the hash representation of the current span.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#282
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#277
  def to_s; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def trace_id; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#28
  def type; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#115
  def type=(type); end

  private

  # Create a Span from the operation which represents
  # the finalized measurement. We #dup here to prevent
  # mutation by reference; when this span is returned,
  # we don't want this SpanOperation to modify it further.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#457
  def build_span; end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#497
  def duration_marker; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#509
  def duration_nano; end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#435
  def events; end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#435
  def parent; end

  # Set this span's parent, inheriting any properties not explicitly set.
  # If the parent is nil, set the span as the root span.
  #
  # DEV: This method creates a false expectation that
  # `self.parent.id == self.parent_id`, which is not the case
  # for distributed traces, as the parent Span object does not exist
  # in this application. `#parent_id` is the only reliable parent
  # identifier. We should remove the ability to set a parent Span
  # object in the future.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#485
  def parent=(parent); end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#435
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#503
  def start_time_nano; end
end

# Error when the span attempts to start again after being started
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#424
class Datadog::Tracing::SpanOperation::AlreadyStartedError < ::StandardError
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#425
  def message; end
end

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#337
class Datadog::Tracing::SpanOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#347
  def initialize(on_error: T.unsafe(nil)); end

  # Returns the value of attribute after_finish.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#342
  def after_finish; end

  # Returns the value of attribute after_stop.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#342
  def after_stop; end

  # Returns the value of attribute before_start.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#342
  def before_start; end

  # This event is lazily initialized as error paths
  # are normally less common that non-error paths.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#355
  def on_error; end
end

# Triggered when the span is finished, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#360
class Datadog::Tracing::SpanOperation::Events::AfterFinish < ::Datadog::Tracing::Event
  # @return [AfterFinish] a new instance of AfterFinish
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#361
  def initialize; end
end

# Triggered when the span is stopped, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#367
class Datadog::Tracing::SpanOperation::Events::AfterStop < ::Datadog::Tracing::Event
  # @return [AfterStop] a new instance of AfterStop
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#368
  def initialize; end
end

# Triggered just before the span is started.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#374
class Datadog::Tracing::SpanOperation::Events::BeforeStart < ::Datadog::Tracing::Event
  # @return [BeforeStart] a new instance of BeforeStart
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#375
  def initialize; end
end

# source://ddtrace//lib/datadog/tracing/span_operation.rb#340
Datadog::Tracing::SpanOperation::Events::DEFAULT_ON_ERROR = T.let(T.unsafe(nil), Proc)

# Triggered when the span raises an error during measurement.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#381
class Datadog::Tracing::SpanOperation::Events::OnError
  # @return [OnError] a new instance of OnError
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#382
  def initialize(default); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#409
  def publish(*args); end

  # DEV: Revisit this before full 1.0 release.
  # It seems like OnError wants to behave like a middleware stack,
  # where each "subscriber"'s executed is chained to the previous one.
  # This is different from how {Tracing::Event} works, and might be incompatible.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#392
  def wrap_default; end
end

# SyncWriter flushes both services and traces synchronously
# DEV: To be replaced by Datadog::Tracing::Workers::TraceWriter.
#
# Note: If you're wondering if this class is used at all, since there are no other references to it on the codebase,
# the separate `datadog-lambda` uses it as of February 2021:
# <https://github.com/DataDog/datadog-lambda-rb/blob/c15f0f0916c90123416dc44e7d6800ef4a7cfdbf/lib/datadog/lambda.rb#L38>
#
# source://ddtrace//lib/datadog/tracing/sync_writer.rb#20
class Datadog::Tracing::SyncWriter
  # @param transport [Datadog::Transport::Traces::Transport] a custom transport instance.
  #   If provided, overrides `transport_options` and `agent_settings`.
  # @param transport_options [Hash<Symbol,Object>] options for the default transport instance.
  # @param agent_settings [Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings] agent options for
  #   the default transport instance.
  # @return [SyncWriter] a new instance of SyncWriter
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#30
  def initialize(transport: T.unsafe(nil), transport_options: T.unsafe(nil), agent_settings: T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#21
  def events; end

  # Does nothing.
  # The {SyncWriter} does not need to be stopped as it holds no state.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#50
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#21
  def transport; end

  # Sends traces to the configured transport.
  #
  # Traces are flushed immediately.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#42
  def write(trace); end

  private

  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#57
  def flush_trace(trace); end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently on any environment.
#
# @see Datadog::Core::Buffer::ThreadSafe
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#106
class Datadog::Tracing::ThreadSafeTraceBuffer < ::Datadog::Core::Buffer::ThreadSafe
  include ::Datadog::Tracing::MeasuredBuffer
end

# Trace buffer that stores application traces. The buffer has a maximum size and when
# the buffer is full, a random trace is discarded. This class is thread-safe and is used
# automatically by the ``Tracer`` instance when a ``Span`` is finished.
#
# We choose the default TraceBuffer implementation for current platform dynamically here.
#
# TODO We should restructure this module, so that classes are not declared at top-level ::Datadog.
# TODO Making such a change is potentially breaking for users manually configuring the tracer.
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#126
Datadog::Tracing::TraceBuffer = Datadog::Tracing::CRubyTraceBuffer

# Trace digest that represents the important parts of an active trace.
# Used to propagate context and continue traces across execution boundaries.
#
# source://ddtrace//lib/datadog/tracing/trace_digest.rb#8
class Datadog::Tracing::TraceDigest
  # @return [TraceDigest] a new instance of TraceDigest
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#101
  def initialize(span_id: T.unsafe(nil), span_name: T.unsafe(nil), span_resource: T.unsafe(nil), span_service: T.unsafe(nil), span_type: T.unsafe(nil), trace_distributed_tags: T.unsafe(nil), trace_hostname: T.unsafe(nil), trace_id: T.unsafe(nil), trace_name: T.unsafe(nil), trace_origin: T.unsafe(nil), trace_process_id: T.unsafe(nil), trace_resource: T.unsafe(nil), trace_runtime_id: T.unsafe(nil), trace_sampling_priority: T.unsafe(nil), trace_service: T.unsafe(nil), trace_distributed_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil), trace_state_unknown_fields: T.unsafe(nil)); end

  # Datadog id for the currently active span.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_id; end

  # The operation name of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_name; end

  # The resource name of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_resource; end

  # The service of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_service; end

  # The type of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_type; end

  # The trace id extracted from a distributed context, if different from `trace_id`.
  #
  # The current use case is when the distributed context has a trace id integer larger than 64-bit:
  # This attribute will preserve the original id, while `trace_id` will only contain the lower 64 bits.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-id
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_distributed_id; end

  # Datadog-specific tags that support richer distributed tracing association.
  #
  # @return [Hash<String,String>]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_distributed_tags; end

  # The W3C "trace-flags" extracted from a distributed context. This field is an 8-bit unsigned integer.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-flags
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_flags; end

  # The hostname of the currently active trace. Use to attribute traces to hosts.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_hostname; end

  # Datadog id for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_id; end

  # Operation name for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_name; end

  # Datadog-specific attribution of this trace's creation.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_origin; end

  # The OS-specific process id.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_process_id; end

  # The resource name of the currently active trace.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_resource; end

  # Unique id to this Ruby process. Used to differentiate traces coming from
  # child processes forked from same parent process.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_runtime_id; end

  # Datadog-specific sampling decision for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_sampling_priority; end

  # The service of the currently active trace.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_service; end

  # The W3C "tracestate" extracted from a distributed context.
  # This field is a string representing vendor-specific distribution data.
  # The `dd=` entry is removed from `trace_state` as its value is dynamically calculated
  # on every propagation injection.
  #
  # @return [String]
  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_state; end

  # TODO: The documentation for the last attribute above won't be rendered.
  # TODO: This might be a YARD bug as adding an attribute, making it now second-last attribute, renders correctly.
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_state_unknown_fields; end
end

# Represents the act of tracing a series of operations,
# by generating and collecting span measurements.
# When completed, it yields a trace.
#
# Supports synchronous code flow *only*. Usage across
# multiple threads will result in incorrect relationships.
# For async support, a {Datadog::Tracing::TraceOperation} should be employed
# per execution context (e.g. Thread, etc.)
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#27
class Datadog::Tracing::TraceOperation
  include ::Datadog::Tracing::Metadata::Tagging

  # @return [TraceOperation] a new instance of TraceOperation
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#54
  def initialize(agent_sample_rate: T.unsafe(nil), events: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), max_length: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), parent_span_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), sample_rate: T.unsafe(nil), sampled: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil)); end

  # Returns the value of attribute active_span.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#41
  def active_span; end

  # Returns the value of attribute active_span_count.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#41
  def active_span_count; end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def agent_sample_rate; end

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def agent_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#197
  def build_span(op_name, events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#112
  def finished?; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#108
  def finished_span_count; end

  # Returns a {TraceSegment} with all finished spans that can be flushed
  # at invocation time. All other **finished** spans are discarded.
  #
  # @return [TraceSegment]
  # @yield [spans] spans that will be returned as part of the trace segment returned
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#257
  def flush!; end

  # Returns a copy of this trace suitable for forks (w/o spans.)
  # Used for continuation of traces across forks.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#299
  def fork_clone; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#104
  def full?; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def hostname=(_arg0); end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#41
  def id; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#134
  def keep!; end

  # Returns the value of attribute max_length.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#41
  def max_length; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#165
  def measure(op_name, events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#146
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#48
  def name=(_arg0); end

  # Returns the value of attribute origin.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def origin; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def origin=(_arg0); end

  # Returns the value of attribute parent_span_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#41
  def parent_span_id; end

  # Has the priority sampling chosen to keep this span?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#130
  def priority_sampled?; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def rate_limiter_rate; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def rate_limiter_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#140
  def reject!; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#150
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#48
  def resource=(_arg0); end

  # Returns true if the resource has been explicitly set
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#157
  def resource_override?; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def rule_sample_rate; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def rule_sample_rate=(_arg0); end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def sample_rate; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def sample_rate=(_arg0); end

  # Sets the attribute sampled
  #
  # @param value the value to set the attribute sampled to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#48
  def sampled=(_arg0); end

  # Will this trace be flushed by the tracer transport?
  # This includes cases where the span is kept solely due to priority sampling.
  #
  # This is not the ultimate Datadog App sampling decision. Downstream systems
  # can decide to reject this trace, especially for cases where priority
  # sampling is set to AUTO_KEEP.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#124
  def sampled?; end

  # Returns the value of attribute sampling_priority.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def sampling_priority; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#32
  def sampling_priority=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#161
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#48
  def service=(_arg0); end

  # Returns a set of trace headers used for continuing traces.
  # Used for propagation across execution contexts.
  # Data should reflect the active state of the trace.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#273
  def to_digest; end

  private

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#374
  def activate_span!(span_op); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#437
  def build_trace(spans, partial = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#384
  def deactivate_span!(span_op); end

  # Returns tracer tags that will be propagated if this span's context
  # is exported through {.to_digest}.
  #
  # @return [Hash] key value pairs of distributed tags
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#463
  def distributed_tags; end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#370
  def events; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#406
  def finish_span(span, span_op, parent); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#467
  def reset; end

  # Returns the value of attribute root_span.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#370
  def root_span; end

  # Track the root span
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#431
  def set_root_span!(span); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#392
  def start_span(span_op); end
end

# source://ddtrace//lib/datadog/tracing/trace_operation.rb#30
Datadog::Tracing::TraceOperation::DEFAULT_MAX_LENGTH = T.let(T.unsafe(nil), Integer)

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#322
class Datadog::Tracing::TraceOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#330
  def initialize; end

  # Returns the value of attribute span_before_start.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#325
  def span_before_start; end

  # Returns the value of attribute span_finished.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#325
  def span_finished; end

  # Returns the value of attribute trace_finished.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#325
  def trace_finished; end
end

# Triggered before a span starts.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#337
class Datadog::Tracing::TraceOperation::Events::SpanBeforeStart < ::Datadog::Tracing::Event
  # @return [SpanBeforeStart] a new instance of SpanBeforeStart
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#338
  def initialize; end
end

# Triggered when a span finishes, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#344
class Datadog::Tracing::TraceOperation::Events::SpanFinished < ::Datadog::Tracing::Event
  # @return [SpanFinished] a new instance of SpanFinished
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#345
  def initialize; end
end

# Triggered when the trace finishes, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#351
class Datadog::Tracing::TraceOperation::Events::TraceFinished < ::Datadog::Tracing::Event
  # @return [TraceFinished] a new instance of TraceFinished
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#352
  def initialize; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#357
  def deactivate_trace_subscribed?; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#361
  def subscribe_deactivate_trace(&block); end
end

# Serializable construct representing a trace
#
# source://ddtrace//lib/datadog/tracing/trace_segment.rb#14
class Datadog::Tracing::TraceSegment
  # @param spans [Array<Datadog::Span>]
  # @return [TraceSegment] a new instance of TraceSegment
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#40
  def initialize(spans, agent_sample_rate: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), lang: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), process_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), root_span_id: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), runtime_id: T.unsafe(nil), sample_rate: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil)); end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def agent_sample_rate; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#88
  def any?; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#92
  def count; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#96
  def empty?; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def hostname; end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def id; end

  # If an active trace is present, forces it to be retained by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#113
  def keep!; end

  # Returns the value of attribute lang.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def lang; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#100
  def length; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def name; end

  # Returns the value of attribute origin.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def origin; end

  # Returns the value of attribute process_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def process_id; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def rate_limiter_rate; end

  # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#122
  def reject!; end

  # Returns the value of attribute resource.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def resource; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def rule_sample_rate; end

  # Returns the value of attribute runtime_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def runtime_id; end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def sample_rate; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#126
  def sampled?; end

  # Returns the value of attribute sampling_decision_maker.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def sampling_decision_maker; end

  # Returns the value of attribute sampling_priority.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def sampling_priority; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def service; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#104
  def size; end

  # Returns the value of attribute spans.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#19
  def spans; end

  protected

  # Returns the value of attribute meta.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#133
  def meta; end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#133
  def metrics; end

  # Returns the value of attribute root_span_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#133
  def root_span_id; end

  private

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def agent_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#155
  def agent_sample_rate_tag; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def hostname=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#159
  def hostname_tag; end

  # Sets the attribute lang
  #
  # @param value the value to set the attribute lang to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def lang=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#163
  def lang_tag; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def name=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#167
  def name_tag; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def origin=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#171
  def origin_tag; end

  # Sets the attribute process_id
  #
  # @param value the value to set the attribute process_id to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def process_id=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#175
  def process_id_tag; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def rate_limiter_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#179
  def rate_limiter_rate_tag; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def resource=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#183
  def resource_tag; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def rule_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#187
  def rule_sample_rate_tag; end

  # Sets the attribute runtime_id
  #
  # @param value the value to set the attribute runtime_id to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def runtime_id=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#191
  def runtime_id_tag; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#195
  def sample_rate_tag; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#199
  def sampling_decision_maker_tag; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def sampling_priority=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#203
  def sampling_priority_tag; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#140
  def service=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#207
  def service_tag; end
end

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#15
Datadog::Tracing::TraceSegment::TAG_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#16
Datadog::Tracing::TraceSegment::TAG_RESOURCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#17
Datadog::Tracing::TraceSegment::TAG_SERVICE = T.let(T.unsafe(nil), String)

# A {Datadog::Tracing::Tracer} keeps track of the time spent by an application processing a single operation. For
# example, a trace can be used to track the entire time spent processing a complicated web request.
# Even though the request may require multiple resources and machines to handle the request, all
# of these function calls and sub-requests would be encapsulated within a single trace.
#
# source://ddtrace//lib/datadog/tracing/tracer.rb#26
class Datadog::Tracing::Tracer
  # Initialize a new {Datadog::Tracing::Tracer} used to create, sample and submit spans that measure the
  # time of sections of code.
  #
  # @param trace_flush [Datadog::Tracing::TraceFlush] responsible for flushing spans from the execution context
  # @param context_provider [Datadog::Tracing::DefaultContextProvider] ensures different
  #   execution contexts have distinct traces
  # @param default_service [String] A fallback value for {Datadog::Tracing::Span#service}, as spans without
  #   service are rejected
  # @param enabled [Boolean] set if the tracer submits or not spans to the local agent
  # @param sampler [Datadog::Tracing::Sampler] a tracer sampler, responsible for filtering out spans when needed
  # @param tags [Hash] default tags added to all spans
  # @param writer [Datadog::Tracing::Writer] consumes traces returned by the provided +trace_flush+
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#51
  def initialize(trace_flush: T.unsafe(nil), context_provider: T.unsafe(nil), default_service: T.unsafe(nil), enabled: T.unsafe(nil), sampler: T.unsafe(nil), span_sampler: T.unsafe(nil), tags: T.unsafe(nil), writer: T.unsafe(nil)); end

  # Information about the currently active trace.
  #
  # The most common use cases are tagging log messages and metrics.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::Correlation::Identifier] correlation object
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#232
  def active_correlation(key = T.unsafe(nil)); end

  # The active, unfinished span, representing the currently instrumented application section.
  #
  # The active span belongs to an {.active_trace}.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::SpanOperation] the active span
  # @return [nil] if no trace is active, and thus no span is active
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#221
  def active_span(key = T.unsafe(nil)); end

  # The active, unfinished trace, representing the current instrumentation context.
  #
  # The active trace is fiber-local.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::TraceSegment] the active trace
  # @return [nil] if no trace is active
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#210
  def active_trace(key = T.unsafe(nil)); end

  # Setup a new trace to continue from where another
  # trace left off.
  #
  # Used to continue distributed or async traces.
  #
  # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Object] If a block is provided, the result of the block execution.
  # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
  # @yield Optional block where this {#continue_trace!} `digest` scope is active.
  #   If no block, the `digest` remains active after {#continue_trace!} returns.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#250
  def continue_trace!(digest, key = T.unsafe(nil), &block); end

  # Returns the value of attribute default_service.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def default_service; end

  # Sets the attribute default_service
  #
  # @param value the value to set the attribute default_service to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def default_service=(_arg0); end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def enabled; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def enabled=(_arg0); end

  # Returns the value of attribute provider.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#27
  def provider; end

  # Returns the value of attribute sampler.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#27
  def sampler; end

  # Set the given key / value tag pair at the tracer level. These tags will be
  # appended to each span created by the tracer. Keys and values must be strings.
  #
  # @example
  #   tracer.set_tags('env' => 'prod', 'component' => 'core')
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#198
  def set_tags(tags); end

  # Shorthand that calls the `shutdown!` method of a registered worker.
  # It's useful to ensure that the Trace Buffer is properly flushed before
  # shutting down the application.
  #
  # @example
  #   tracer.trace('operation_name', service='rake_tasks') do |span_op|
  #   span_op.set_tag('task.name', 'script')
  #   end
  #
  #   tracer.shutdown!
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#298
  def shutdown!; end

  # Returns the value of attribute span_sampler.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#27
  def span_sampler; end

  # Returns the value of attribute tags.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#27
  def tags; end

  # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
  # that will trace an operation called `name`.
  #
  # You could trace your code using a <tt>do-block</tt> like:
  #
  # ```
  # tracer.trace('web.request') do |span_op, trace_op|
  #   span_op.service = 'my-web-site'
  #   span_op.resource = '/'
  #   span_op.set_tag('http.method', request.request_method)
  #   do_something()
  # end
  # ```
  #
  # The {#trace} method can also be used without a block in this way:
  # ```
  # span_op = tracer.trace('web.request', service: 'my-web-site')
  # do_something()
  # span_op.finish()
  # ```
  #
  # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
  #
  # When a Trace is started, {#trace} will store the created span; subsequent spans will
  # become its children and will inherit some properties:
  # ```
  # parent = tracer.trace('parent')   # has no parent span
  # child  = tracer.trace('child')    # is a child of 'parent'
  # child.finish()
  # parent.finish()
  # parent2 = tracer.trace('parent2') # has no parent span
  # parent2.finish()
  # ```
  #
  #
  # @param name [String] {Datadog::Tracing::Span} operation name.
  #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
  # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
  #   Used for linking traces that are executed asynchronously.
  # @param on_error [Proc] a block that overrides error handling behavior for this operation.
  # @param resource [String] the resource this span refers, or `name` if it's missing
  # @param service [String] the service name for this span.
  # @param start_time [Time] time which the span should have started.
  # @param tags [Hash<String,String>] extra tags which should be added to the span.
  # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
  # @return [Object] If a block is provided, returns the result of the block execution.
  # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
  #   unfinished {Datadog::Tracing::SpanOperation}.
  # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
  # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
  # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#126
  def trace(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), span_type: T.unsafe(nil), _context: T.unsafe(nil), &block); end

  # TODO: make this private
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#269
  def trace_completed; end

  # Returns the value of attribute trace_flush.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#27
  def trace_flush; end

  # Returns the value of attribute writer.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def writer; end

  # Sets the attribute writer
  #
  # @param value the value to set the attribute writer to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#34
  def writer=(_arg0); end

  private

  # source://ddtrace//lib/datadog/tracing/tracer.rb#340
  def bind_trace_events!(trace_op); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#411
  def build_span_events(events = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#318
  def build_trace(digest = T.unsafe(nil)); end

  # Return the current active {Context} for this traced execution. This method is
  # automatically called when calling Tracer.trace or Tracer.start_span,
  # but it can be used in the application code during manual instrumentation.
  #
  # This method makes use of a {ContextProvider} that is automatically set during the tracer
  # initialization, or while using a library instrumentation.
  #
  # @param key [Thread] Thread to retrieve tracer from. Defaults to current thread.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#314
  def call_context(key = T.unsafe(nil)); end

  # Flush finished spans from the trace buffer, send them to writer.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#493
  def flush_trace(trace_op); end

  # Manually activate and deactivate the trace, when the span completes.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#434
  def manual_trace_activation!(context, trace); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#422
  def resolve_tags(tags); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#479
  def sample_span(trace_op, span); end

  # Sample a span, tagging the trace as appropriate.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#466
  def sample_trace(trace_op); end

  # TODO: Make these dummy objects singletons to preserve memory.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#521
  def skip_trace(name); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#366
  def start_span(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), _trace: T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#355
  def start_trace(continue_from: T.unsafe(nil)); end

  # Reactivate the original trace when trace completes
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#447
  def subscribe_trace_deactivation!(context, trace, original_trace); end

  # Send the trace to the writer to enqueue the spans list in the agent
  # sending queue.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#509
  def write(trace); end
end

# source://ddtrace//lib/datadog/tracing/tracer.rb#504
Datadog::Tracing::Tracer::FLUSH_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/tracer.rb#489
Datadog::Tracing::Tracer::SAMPLE_SPAN_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/tracer.rb#476
Datadog::Tracing::Tracer::SAMPLE_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Triggered whenever a trace is completed
#
# source://ddtrace//lib/datadog/tracing/tracer.rb#274
class Datadog::Tracing::Tracer::TraceCompleted < ::Datadog::Tracing::Event
  # @return [TraceCompleted] a new instance of TraceCompleted
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#275
  def initialize; end

  # NOTE: Ignore Rubocop rule. This definition allows for
  #       description of and constraints on arguments.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#282
  def publish(trace); end
end

# Utils contains low-level tracing utility functions.
#
# source://ddtrace//lib/datadog/tracing/utils.rb#9
module Datadog::Tracing::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # Return a randomly generated integer, valid as a Span ID or Trace ID.
    # This method is thread-safe and fork-safe.
    #
    # source://ddtrace//lib/datadog/tracing/utils.rb#34
    def next_id; end

    private

    # source://ddtrace//lib/datadog/tracing/utils.rb#39
    def id_rng; end

    # source://ddtrace//lib/datadog/tracing/utils.rb#43
    def reset!; end
  end
end

# While we only generate 63-bit integers due to limitations in other languages, we support
# parsing 64-bit integers for distributed tracing since an upstream system may generate one
#
# source://ddtrace//lib/datadog/tracing/utils.rb#26
Datadog::Tracing::Utils::EXTERNAL_MAX_ID = T.let(T.unsafe(nil), Integer)

# Excludes zero from possible values
#
# source://ddtrace//lib/datadog/tracing/utils.rb#22
Datadog::Tracing::Utils::RUBY_ID_RANGE = T.let(T.unsafe(nil), Range)

# The max value for a {Datadog::Tracing::Span} identifier.
# Span and trace identifiers should be strictly positive and strictly inferior to this limit.
#
# Limited to +2<<62-1+ positive integers, as Ruby is able to represent such numbers "inline",
# inside a +VALUE+ scalar, thus not requiring memory allocation.
#
# The range of IDs also has to consider portability across different languages and platforms.
#
# source://ddtrace//lib/datadog/tracing/utils.rb#19
Datadog::Tracing::Utils::RUBY_MAX_ID = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#10
module Datadog::Tracing::Workers; end

# Asynchronous worker that executes a +Send()+ operation after given
# seconds. Under the hood, it uses +Concurrent::TimerTask+ so that the thread
# will perform a task at regular intervals. The thread can be stopped
# with the +stop()+ method and can start with the +start()+ method.
#
# source://ddtrace//lib/datadog/tracing/workers.rb#15
class Datadog::Tracing::Workers::AsyncTransport
  # @return [AsyncTransport] a new instance of AsyncTransport
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#26
  def initialize(options = T.unsafe(nil)); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#49
  def callback_traces; end

  # Enqueue an item in the trace internal buffer. This operation is thread-safe
  # because uses the +TraceBuffer+ data structure.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#101
  def enqueue_trace(trace); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#49
  def flush_data; end

  # Block until executor shutdown is complete or until timeout seconds have passed.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#95
  def join; end

  # Start the timer execution.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#67
  def start; end

  # Closes all available queues and waits for the trace buffer to flush
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#81
  def stop; end

  # Returns the value of attribute trace_buffer.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#23
  def trace_buffer; end

  private

  # source://ddtrace//lib/datadog/tracing/workers.rb#111
  def perform; end
end

# source://ddtrace//lib/datadog/tracing/workers.rb#20
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#19
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/tracing/workers.rb#16
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_BUFFER_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#17
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#18
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#21
Datadog::Tracing::Workers::AsyncTransport::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Processor that sends traces and metadata to the agent
# DEV: Our goal is for {Datadog::Tracing::Workers::TraceWriter} to replace this class in the future
#
# source://ddtrace//lib/datadog/tracing/writer.rb#16
class Datadog::Tracing::Writer
  # @return [Writer] a new instance of Writer
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#22
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#17
  def events; end

  # flush spans to the trace-agent, handles spans only
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#110
  def send_spans(traces, transport); end

  # Explicitly starts the {Writer}'s internal worker.
  #
  # The {Writer} is also automatically started when necessary during calls to {.write}.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#57
  def start; end

  # stats returns a dictionary of stats about the writer.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#154
  def stats; end

  # Gracefully shuts down this writer.
  #
  # Once stopped methods calls won't fail, but
  # no internal work will be performed.
  #
  # It is not possible to restart a stopped writer instance.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#91
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#17
  def transport; end

  # Returns the value of attribute worker.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#17
  def worker; end

  # enqueue the trace for submission to the API
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#128
  def write(trace); end

  private

  # source://ddtrace//lib/datadog/tracing/writer.rb#181
  def reset_stats!; end

  # spawns a worker for spans; they share the same transport which is thread-safe
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#73
  def start_worker; end

  # source://ddtrace//lib/datadog/tracing/writer.rb#95
  def stop_worker; end
end

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/writer.rb#162
class Datadog::Tracing::Writer::Events
  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#166
  def initialize; end

  # Returns the value of attribute after_send.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#163
  def after_send; end
end

# Triggered after the writer sends traces through the transport.
# Provides the Writer instance and transport response list to the callback.
#
# source://ddtrace//lib/datadog/tracing/writer.rb#172
class Datadog::Tracing::Writer::Events::AfterSend < ::Datadog::Tracing::Event
  # @return [AfterSend] a new instance of AfterSend
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#173
  def initialize; end
end

# source://ddtrace//lib/ddtrace/transport/ext.rb#4
module Datadog::Transport; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#6
module Datadog::Transport::Ext; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#8
module Datadog::Transport::Ext::HTTP; end

# DEV: Rename to simply `:http`, as Net::HTTP is an implementation detail.
#
# source://ddtrace//lib/ddtrace/transport/ext.rb#9
Datadog::Transport::Ext::HTTP::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#10
Datadog::Transport::Ext::HTTP::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#11
Datadog::Transport::Ext::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# Tells agent that `_dd.top_level` metrics have been set by the tracer.
# The agent will not calculate top-level spans but instead trust the tracer tagging.
#
# This prevents partially flushed traces being mistakenly marked as top-level.
#
# Setting this header to any non-empty value enables this feature.
#
# source://ddtrace//lib/ddtrace/transport/ext.rb#21
Datadog::Transport::Ext::HTTP::HEADER_CLIENT_COMPUTED_TOP_LEVEL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#13
Datadog::Transport::Ext::HTTP::HEADER_CONTAINER_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#14
Datadog::Transport::Ext::HTTP::HEADER_DD_API_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#22
Datadog::Transport::Ext::HTTP::HEADER_META_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#24
Datadog::Transport::Ext::HTTP::HEADER_META_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#23
Datadog::Transport::Ext::HTTP::HEADER_META_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#25
Datadog::Transport::Ext::HTTP::HEADER_META_TRACER_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#29
module Datadog::Transport::Ext::Test; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#30
Datadog::Transport::Ext::Test::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#34
module Datadog::Transport::Ext::UnixSocket; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#35
Datadog::Transport::Ext::UnixSocket::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#36
Datadog::Transport::Ext::UnixSocket::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#37
Datadog::Transport::Ext::UnixSocket::DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# Namespace for HTTP transport components
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#8
module Datadog::Transport::HTTP
  include ::Kernel

  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://ddtrace//lib/ddtrace/transport/http.rb#42
  def default(agent_settings: T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#84
  def default_adapter; end

  # source://ddtrace//lib/ddtrace/transport/http.rb#70
  def default_headers; end

  # source://ddtrace//lib/ddtrace/transport/http.rb#88
  def default_hostname(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#97
  def default_port(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#106
  def default_url(logger: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client
  #
  # source://ddtrace//lib/ddtrace/transport/http.rb#36
  def new(&block); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://ddtrace//lib/ddtrace/transport/http.rb#42
    def default(agent_settings: T.unsafe(nil), **options); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#84
    def default_adapter; end

    # source://ddtrace//lib/ddtrace/transport/http.rb#70
    def default_headers; end

    # source://ddtrace//lib/ddtrace/transport/http.rb#88
    def default_hostname(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#97
    def default_port(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#106
    def default_url(logger: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client
    #
    # source://ddtrace//lib/ddtrace/transport/http.rb#36
    def new(&block); end
  end
end

# Namespace for API components
#
# source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#6
module Datadog::Transport::HTTP::API
  private

  # source://ddtrace//lib/ddtrace/transport/http/api.rb#21
  def defaults; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/api.rb#21
    def defaults; end
  end
end

# Endpoint
#
# source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#10
class Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#15
  def initialize(verb, path); end

  # @yield [env]
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#20
  def call(env); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#11
  def path; end

  # Returns the value of attribute verb.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#11
  def verb; end
end

# Extension for Map with adds fallback versions.
#
# source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#8
module Datadog::Transport::HTTP::API::Fallbacks
  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#17
  def add_fallbacks!(fallbacks); end

  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#9
  def fallbacks; end

  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#13
  def with_fallbacks(fallbacks); end
end

# An API configured with adapter and routes
#
# source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#8
class Datadog::Transport::HTTP::API::Instance
  include ::Datadog::Transport::HTTP::Traces::API::Instance

  # @return [Instance] a new instance of Instance
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#14
  def initialize(spec, adapter, options = T.unsafe(nil)); end

  # Returns the value of attribute adapter.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def adapter; end

  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#24
  def call(env); end

  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#20
  def encoder; end

  # Returns the value of attribute headers.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def headers; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def spec; end
end

# A mapping of API version => API Routes/Instance
#
# source://ddtrace//lib/ddtrace/transport/http/api/map.rb#10
class Datadog::Transport::HTTP::API::Map < ::Hash
  include ::Datadog::Transport::HTTP::API::Fallbacks
end

# Specification for an HTTP API
# Defines behaviors without specific configuration details.
#
# source://ddtrace//lib/ddtrace/transport/http/api/spec.rb#9
class Datadog::Transport::HTTP::API::Spec
  include ::Datadog::Transport::HTTP::Traces::API::Spec

  # @return [Spec] a new instance of Spec
  # @yield [_self]
  # @yieldparam _self [Datadog::Transport::HTTP::API::Spec] the object that the method was called on
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/spec.rb#10
  def initialize; end
end

# source://ddtrace//lib/ddtrace/transport/http/api.rb#17
Datadog::Transport::HTTP::API::V3 = T.let(T.unsafe(nil), String)

# Default API versions
#
# source://ddtrace//lib/ddtrace/transport/http/api.rb#16
Datadog::Transport::HTTP::API::V4 = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#9
module Datadog::Transport::HTTP::Adapters; end

# Adapter for Net::HTTP
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#11
class Datadog::Transport::HTTP::Adapters::Net
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @return [Net] a new instance of Net
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#22
  def initialize(hostname = T.unsafe(nil), port = T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#50
  def call(env); end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#12
  def hostname; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#38
  def open(&block); end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#12
  def port; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#58
  def post(env); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#12
  def ssl; end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#12
  def timeout; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#81
  def url; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#29
    def build(agent_settings); end
  end
end

# in seconds
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#19
Datadog::Transport::HTTP::Adapters::Net::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# A wrapped Net::HTTP response that implements the Transport::Response interface
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#99
class Datadog::Transport::HTTP::Adapters::Net::Response
  include ::Datadog::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#104
  def initialize(http_response); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#138
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#114
  def code; end

  # Returns the value of attribute http_response.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#102
  def http_response; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#150
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#132
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#120
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#108
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#144
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#126
  def unsupported?; end
end

# Raised when called with an unknown HTTP method
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#86
class Datadog::Transport::HTTP::Adapters::Net::UnknownHTTPMethod < ::StandardError
  # @return [UnknownHTTPMethod] a new instance of UnknownHTTPMethod
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#89
  def initialize(verb); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#93
  def message; end

  # Returns the value of attribute verb.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#87
  def verb; end
end

# List of available adapters
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#8
class Datadog::Transport::HTTP::Adapters::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#9
  def initialize; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#13
  def get(name); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#17
  def set(klass, name = T.unsafe(nil)); end
end

# Adapter for testing
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#10
class Datadog::Transport::HTTP::Adapters::Test
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @param buffer [Array] an optional array that will capture all spans sent to this adapter, defaults to +nil+
  # @return [Test] a new instance of Test
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#17
  def initialize(buffer = T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#32
  def add_request(env); end

  # Returns the value of attribute buffer.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#11
  def buffer; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#28
  def buffer?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#23
  def call(env); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#36
  def set_status!(status); end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#11
  def status; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#40
  def url; end
end

# Response for test adapter
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#43
class Datadog::Transport::HTTP::Adapters::Test::Response
  include ::Datadog::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#50
  def initialize(code, body = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#46
  def body; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#71
  def client_error?; end

  # Returns the value of attribute code.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#46
  def code; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#79
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#67
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#59
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#55
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#75
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#63
  def unsupported?; end
end

# Adapter for Unix sockets
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#12
class Datadog::Transport::HTTP::Adapters::UnixSocket < ::Datadog::Transport::HTTP::Adapters::Net
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @return [UnixSocket] a new instance of UnixSocket
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#20
  def initialize(uds_path = T.unsafe(nil), **options); end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#13
  def filepath; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#32
  def open(&block); end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#13
  def timeout; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#13
  def uds_path; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#43
  def url; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#25
    def build(agent_settings); end
  end
end

# Re-implements Net:HTTP with underlying Unix socket
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#48
class Datadog::Transport::HTTP::Adapters::UnixSocket::HTTP < ::Net::HTTP
  # @return [HTTP] a new instance of HTTP
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#57
  def initialize(uds_path, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#65
  def connect; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#51
  def filepath; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#51
  def uds_path; end

  # Returns the value of attribute unix_socket.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#51
  def unix_socket; end
end

# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#49
Datadog::Transport::HTTP::Adapters::UnixSocket::HTTP::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Builds new instances of Transport::HTTP::Client
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#13
class Datadog::Transport::HTTP::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Transport::HTTP::Builder] the object that the method was called on
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#23
  def initialize; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#38
  def adapter(config, *args, **kwargs); end

  # Adds a new API to the client
  # Valid options:
  #  - :adapter
  #  - :default
  #  - :fallback
  #  - :headers
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#65
  def api(key, spec, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#119
  def api_instance_class; end

  # Returns the value of attribute api_options.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#16
  def api_options; end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#16
  def apis; end

  # Returns the value of attribute default_adapter.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#16
  def default_adapter; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#16
  def default_api; end

  # @raise [UnknownApiError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#78
  def default_api=(key); end

  # Returns the value of attribute default_headers.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#16
  def default_headers; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#55
  def headers(values = T.unsafe(nil)); end

  # @raise [NoApisError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#91
  def to_api_instances; end

  # @raise [NoDefaultApiError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#84
  def to_transport; end
end

# Raised when an adapter cannot be resolved for an API instance.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#150
class Datadog::Transport::HTTP::Builder::NoAdapterForApiError < ::StandardError
  # @return [NoAdapterForApiError] a new instance of NoAdapterForApiError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#153
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#151
  def key; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#157
  def message; end
end

# Raised when built without defining APIs.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#163
class Datadog::Transport::HTTP::Builder::NoApisError < ::StandardError
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#164
  def message; end
end

# Raised when client built without defining a default API.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#170
class Datadog::Transport::HTTP::Builder::NoDefaultApiError < ::StandardError
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#171
  def message; end
end

# source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
Datadog::Transport::HTTP::Builder::REGISTRY = T.let(T.unsafe(nil), Datadog::Transport::HTTP::Adapters::Registry)

# Raised when the identifier cannot be matched to an adapter.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#137
class Datadog::Transport::HTTP::Builder::UnknownAdapterError < ::StandardError
  # @return [UnknownAdapterError] a new instance of UnknownAdapterError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#140
  def initialize(type); end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#144
  def message; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#138
  def type; end
end

# Raised when the API key does not match known APIs.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#124
class Datadog::Transport::HTTP::Builder::UnknownApiError < ::StandardError
  # @return [UnknownApiError] a new instance of UnknownApiError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#127
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#125
  def key; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#131
  def message; end
end

# Routes, encodes, and sends tracer data to the trace agent via HTTP.
#
# source://ddtrace//lib/ddtrace/transport/http/client.rb#10
class Datadog::Transport::HTTP::Client
  include ::Datadog::Transport::HTTP::Statistics
  include ::Datadog::Transport::Statistics
  include ::Datadog::Transport::HTTP::Statistics::InstanceMethods
  include ::Datadog::Transport::HTTP::Traces::Client

  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/ddtrace/transport/http/client.rb#15
  def initialize(api); end

  # Returns the value of attribute api.
  #
  # source://ddtrace//lib/ddtrace/transport/http/client.rb#13
  def api; end

  # source://ddtrace//lib/ddtrace/transport/http/client.rb#48
  def build_env(request); end

  # source://ddtrace//lib/ddtrace/transport/http/client.rb#19
  def send_request(request, &block); end
end

# NOTE: Due to... legacy reasons... This class likes having a default `AgentSettings` instance to fall back to.
# Because we generate this instance with an empty instance of `Settings`, the resulting `AgentSettings` below
# represents only settings specified via environment variables + the usual defaults.
#
# DO NOT USE THIS IN NEW CODE, as it ignores any settings specified by users via `Datadog.configure`.
#
# source://ddtrace//lib/ddtrace/transport/http.rb#28
Datadog::Transport::HTTP::DO_NOT_USE_ENVIRONMENT_AGENT_SETTINGS = T.let(T.unsafe(nil), Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings)

# Data structure for an HTTP request
#
# source://ddtrace//lib/ddtrace/transport/http/env.rb#7
class Datadog::Transport::HTTP::Env < ::Hash
  # @return [Env] a new instance of Env
  #
  # source://ddtrace//lib/ddtrace/transport/http/env.rb#11
  def initialize(request, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#32
  def body; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#36
  def body=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#48
  def form; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#52
  def form=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#40
  def headers; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#44
  def headers=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#24
  def path; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#28
  def path=(value); end

  # Returns the value of attribute request.
  #
  # source://ddtrace//lib/ddtrace/transport/http/env.rb#8
  def request; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#16
  def verb; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#20
  def verb=(value); end
end

# Wraps an HTTP response from an adapter.
#
# Used by endpoints to wrap responses from adapters with
# fields or behavior that's specific to that endpoint.
#
# source://ddtrace//lib/ddtrace/transport/http/response.rb#12
module Datadog::Transport::HTTP::Response
  # source://ddtrace//lib/ddtrace/transport/http/response.rb#13
  def initialize(http_response); end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#43
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#52
  def code; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#23
  def internal_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#38
  def not_found?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#33
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#18
  def payload; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#48
  def server_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#28
  def unsupported?; end
end

# Tracks statistics for HTTP transports
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#9
module Datadog::Transport::HTTP::Statistics
  include ::Datadog::Transport::Statistics
  include ::Datadog::Transport::HTTP::Statistics::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#10
    def included(base); end
  end
end

# Instance methods for HTTP statistics
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#16
module Datadog::Transport::HTTP::Statistics::InstanceMethods
  # Decorate metrics for HTTP responses
  #
  # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#18
  def metrics_for_response(response); end

  private

  # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#34
  def metrics_tag_value(status_code); end
end

# The most common status code on a healthy tracer
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#32
Datadog::Transport::HTTP::Statistics::InstanceMethods::STATUS_CODE_200 = T.let(T.unsafe(nil), String)

# HTTP transport behavior for traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#15
module Datadog::Transport::HTTP::Traces; end

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#37
module Datadog::Transport::HTTP::Traces::API; end

# Endpoint for submitting trace data
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#95
class Datadog::Transport::HTTP::Traces::API::Endpoint < ::Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#103
  def initialize(path, encoder, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#113
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#100
  def encoder; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#109
  def service_rates?; end
end

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#96
Datadog::Transport::HTTP::Traces::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#97
Datadog::Transport::HTTP::Traces::API::Endpoint::HEADER_TRACE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#98
Datadog::Transport::HTTP::Traces::API::Endpoint::SERVICE_RATE_KEY = T.let(T.unsafe(nil), String)

# Extensions for HTTP API Instance
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#71
module Datadog::Transport::HTTP::Traces::API::Instance
  # @raise [TracesNotSupportedError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#72
  def send_traces(env); end
end

# Raised when traces sent to API that does not support traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#81
class Datadog::Transport::HTTP::Traces::API::Instance::TracesNotSupportedError < ::StandardError
  # @return [TracesNotSupportedError] a new instance of TracesNotSupportedError
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#84
  def initialize(spec); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#88
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#82
  def spec; end
end

# Extensions for HTTP API Spec
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#39
module Datadog::Transport::HTTP::Traces::API::Spec
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#52
  def encoder; end

  # @raise [NoTraceEndpointDefinedError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#46
  def send_traces(env, &block); end

  # Returns the value of attribute traces.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#40
  def traces; end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#42
  def traces=(endpoint); end
end

# Raised when traces sent but no traces endpoint is defined
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#57
class Datadog::Transport::HTTP::Traces::API::Spec::NoTraceEndpointDefinedError < ::StandardError
  # @return [NoTraceEndpointDefinedError] a new instance of NoTraceEndpointDefinedError
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#60
  def initialize(spec); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#64
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#58
  def spec; end
end

# Extensions for HTTP client
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#29
module Datadog::Transport::HTTP::Traces::Client
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#30
  def send_payload(request); end
end

# Response from HTTP transport for traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#17
class Datadog::Transport::HTTP::Traces::Response
  include ::Datadog::Transport::HTTP::Response
  include ::Datadog::Transport::Traces::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#21
  def initialize(http_response, options = T.unsafe(nil)); end
end

# A generic error response for internal errors
#
# source://ddtrace//lib/ddtrace/transport/response.rb#44
class Datadog::Transport::InternalErrorResponse
  include ::Datadog::Transport::Response

  # @return [InternalErrorResponse] a new instance of InternalErrorResponse
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#49
  def initialize(error); end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#47
  def error; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#57
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#53
  def internal_error?; end
end

# Data transfer object for generic data
#
# @abstract
#
# source://ddtrace//lib/ddtrace/transport/parcel.rb#7
module Datadog::Transport::Parcel
  include ::Kernel

  # source://ddtrace//lib/ddtrace/transport/parcel.rb#13
  def initialize(data); end

  # Returns the value of attribute data.
  #
  # source://ddtrace//lib/ddtrace/transport/parcel.rb#10
  def data; end

  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/ddtrace/transport/parcel.rb#17
  def encode_with(encoder); end
end

# Defines request for transport operations
#
# source://ddtrace//lib/ddtrace/transport/request.rb#6
class Datadog::Transport::Request
  # @return [Request] a new instance of Request
  #
  # source://ddtrace//lib/ddtrace/transport/request.rb#10
  def initialize(parcel); end

  # Returns the value of attribute parcel.
  #
  # source://ddtrace//lib/ddtrace/transport/request.rb#7
  def parcel; end
end

# Defines abstract response for transport operations
#
# source://ddtrace//lib/ddtrace/transport/response.rb#6
module Datadog::Transport::Response
  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#23
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#35
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#31
  def internal_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#19
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#11
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#7
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#27
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#15
  def unsupported?; end
end

# Adds serialization functions to a {Datadog::Span}
#
# source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#38
class Datadog::Transport::SerializableSpan
  # @return [SerializableSpan] a new instance of SerializableSpan
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#42
  def initialize(span); end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#113
  def duration_nano(duration); end

  # Returns the value of attribute span.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#39
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#107
  def time_nano(time); end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#101
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#55
  def to_msgpack(packer = T.unsafe(nil)); end
end

# Adds serialization functions to a {Datadog::TraceSegment}
#
# source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#9
class Datadog::Transport::SerializableTrace
  # @return [SerializableTrace] a new instance of SerializableTrace
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#13
  def initialize(trace); end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#32
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#25
  def to_msgpack(packer = T.unsafe(nil)); end

  # Returns the value of attribute trace.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#10
  def trace; end
end

# Tracks statistics for transports
#
# source://ddtrace//lib/ddtrace/transport/statistics.rb#9
module Datadog::Transport::Statistics
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#48
  def metrics_for_exception(_exception); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#31
  def metrics_for_response(response); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#10
  def stats; end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#38
  def update_stats_from_exception!(exception); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#14
  def update_stats_from_response!(response); end
end

# Stat counts
#
# source://ddtrace//lib/ddtrace/transport/statistics.rb#53
class Datadog::Transport::Statistics::Counts
  # @return [Counts] a new instance of Counts
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#61
  def initialize; end

  # Returns the value of attribute client_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def client_error; end

  # Sets the attribute client_error
  #
  # @param value the value to set the attribute client_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def client_error=(_arg0); end

  # Returns the value of attribute consecutive_errors.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def consecutive_errors; end

  # Sets the attribute consecutive_errors
  #
  # @param value the value to set the attribute consecutive_errors to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def consecutive_errors=(_arg0); end

  # Returns the value of attribute internal_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def internal_error; end

  # Sets the attribute internal_error
  #
  # @param value the value to set the attribute internal_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def internal_error=(_arg0); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#65
  def reset!; end

  # Returns the value of attribute server_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def server_error; end

  # Sets the attribute server_error
  #
  # @param value the value to set the attribute server_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def server_error=(_arg0); end

  # Returns the value of attribute success.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def success; end

  # Sets the attribute success
  #
  # @param value the value to set the attribute success to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def success=(_arg0); end
end

# Prepares traces for transport
#
# source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#12
class Datadog::Transport::TraceFormatter
  # @return [TraceFormatter] a new instance of TraceFormatter
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#21
  def initialize(trace); end

  # Modifies a trace so suitable for transport
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#27
  def format!; end

  # Returns the value of attribute root_span.
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#13
  def root_span; end

  # Returns the value of attribute trace.
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#13
  def trace; end

  protected

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#59
  def set_resource!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#68
  def set_trace_tags!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#78
  def tag_agent_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#87
  def tag_hostname!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#96
  def tag_lang!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#105
  def tag_origin!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#114
  def tag_process_id!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#120
  def tag_rate_limiter_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#129
  def tag_rule_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#138
  def tag_runtime_id!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#147
  def tag_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#156
  def tag_sampling_decision_maker!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#162
  def tag_sampling_priority!; end

  private

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#177
  def find_root_span(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#173
  def partial?; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#17
    def format!(trace); end
  end
end

# source://ddtrace//lib/ddtrace/transport/traces.rb#11
module Datadog::Transport::Traces; end

# Traces chunker
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#38
class Datadog::Transport::Traces::Chunker
  # Single traces larger than +max_size+ will be discarded.
  #
  # @param encoder [Datadog::Core::Encoding::Encoder]
  # @param max_size [String] maximum acceptable payload size
  # @return [Chunker] a new instance of Chunker
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#52
  def initialize(encoder, max_size: T.unsafe(nil)); end

  # Encodes a list of traces in chunks.
  # Before serializing, all traces are normalized. Trace nesting is not changed.
  #
  # @param traces [Enumerable<Trace>] list of traces
  # @return [Enumerable[Array[Bytes,Integer]]] list of encoded chunks: each containing a byte array and
  #   number of traces
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#63
  def encode_in_chunks(traces); end

  # Returns the value of attribute encoder.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#45
  def encoder; end

  # Returns the value of attribute max_size.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#45
  def max_size; end

  private

  # source://ddtrace//lib/ddtrace/transport/traces.rb#78
  def encode_one(trace); end
end

# Trace agent limit payload size of 10 MiB (since agent v5.11.0):
# https://github.com/DataDog/datadog-agent/blob/6.14.1/pkg/trace/api/api.go#L46
#
# We set the value to a conservative 5 MiB, in case network speed is slow.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#43
Datadog::Transport::Traces::Chunker::DEFAULT_MAX_PAYLOAD_SIZE = T.let(T.unsafe(nil), Integer)

# Data transfer object for encoded traces
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#13
class Datadog::Transport::Traces::EncodedParcel
  include ::Datadog::Transport::Parcel

  # @return [EncodedParcel] a new instance of EncodedParcel
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#18
  def initialize(data, trace_count); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#23
  def count; end

  # Returns the value of attribute trace_count.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#16
  def trace_count; end
end

# Encodes traces using {Datadog::Core::Encoding::Encoder} instances.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#94
module Datadog::Transport::Traces::Encoder
  private

  # source://ddtrace//lib/ddtrace/transport/traces.rb#97
  def encode_trace(encoder, trace); end

  class << self
    # source://ddtrace//lib/ddtrace/transport/traces.rb#97
    def encode_trace(encoder, trace); end
  end
end

# Traces request
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#29
class Datadog::Transport::Traces::Request < ::Datadog::Transport::Request; end

# Traces response
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#33
module Datadog::Transport::Traces::Response
  # Returns the value of attribute service_rates.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#34
  def service_rates; end

  # Returns the value of attribute trace_count.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#34
  def trace_count; end
end

# Sends traces based on transport API configuration.
#
# This class initializes the HTTP client, breaks down large
# batches of traces into smaller chunks and handles
# API version downgrade handshake.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#116
class Datadog::Transport::Traces::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#119
  def initialize(apis, default_api); end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#117
  def apis; end

  # Returns the value of attribute client.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#117
  def client; end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#164
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#117
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#117
  def default_api; end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#126
  def send_traces(traces); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#160
  def stats; end

  private

  # @raise [UnknownApiVersionError]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#183
  def change_api!(api_id); end

  # @raise [NoDowngradeAvailableError]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#176
  def downgrade!; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#170
  def downgrade?(response); end
end

# Raised when configured with an unknown API version
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#204
class Datadog::Transport::Traces::Transport::NoDowngradeAvailableError < ::StandardError
  # @return [NoDowngradeAvailableError] a new instance of NoDowngradeAvailableError
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#207
  def initialize(version); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#211
  def message; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#205
  def version; end
end

# Raised when configured with an unknown API version
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#191
class Datadog::Transport::Traces::Transport::UnknownApiVersionError < ::StandardError
  # @return [UnknownApiVersionError] a new instance of UnknownApiVersionError
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#194
  def initialize(version); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#198
  def message; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#192
  def version; end
end
