# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httpclient` gem.
# Please instead update this file by running `bin/tapioca gem httpclient`.


# A namespace module for HTTP Message definitions used by HTTPClient.
#
# source://httpclient//lib/httpclient/http.rb#19
module HTTP
  class << self
    # source://http/5.1.1/lib/http/chainable.rb#182
    def [](headers); end
  end
end

# Represents a HTTP message.  A message is for a request or a response.
#
# Request message is generated from given parameters internally so users
# don't need to care about it.  Response message is the instance that
# methods of HTTPClient returns so users need to know how to extract
# HTTP response data from Message.
#
# Some attributes are only for a request or a response, not both.
#
# == How to use HTTP response message
#
# 1. Gets response message body.
#
#     res = clnt.get(url)
#     p res.content #=> String
#
# 2. Gets response status code.
#
#     res = clnt.get(url)
#     p res.status #=> 200, 501, etc. (Integer)
#
# 3. Gets response header.
#
#     res = clnt.get(url)
#     res.header['set-cookie'].each do |value|
#       p value
#     end
#     assert_equal(1, res.header['last-modified'].size)
#     p res.header['last-modified'].first
#
# source://httpclient//lib/httpclient/http.rb#98
class HTTP::Message
  include ::HTTPClient::Util

  # Creates a Message.  This method should be used internally.
  # Use Message.new_connect_request, Message.new_request or
  # Message.new_response instead.
  #
  # @return [Message] a new instance of Message
  #
  # source://httpclient//lib/httpclient/http.rb#949
  def initialize; end

  # Returns a content of message body.  A String or an IO.
  #
  # source://httpclient//lib/httpclient/http.rb#1039
  def body; end

  # Sets a new body.  header.body_size is updated with new body.size.
  #
  # source://httpclient//lib/httpclient/http.rb#970
  def body=(body); end

  # Returns content encoding
  #
  # source://httpclient//lib/httpclient/http.rb#1034
  def body_encoding; end

  # Returns HTTP status code in response.  Integer.
  #
  # source://httpclient//lib/httpclient/http.rb#998
  def code; end

  # Returns a content of message body.  A String or an IO.
  #
  # source://httpclient//lib/httpclient/http.rb#1039
  def content; end

  # Returns 'Content-Type' header value.
  #
  # source://httpclient//lib/httpclient/http.rb#1022
  def content_type; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  #
  # source://httpclient//lib/httpclient/http.rb#1027
  def content_type=(content_type); end

  # Returns 'Content-Type' header value.
  #
  # source://httpclient//lib/httpclient/http.rb#1022
  def contenttype; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  #
  # source://httpclient//lib/httpclient/http.rb#1027
  def contenttype=(content_type); end

  # Extracts cookies from 'Set-Cookie' header.
  # Supports 'Set-Cookie' in response header only.
  # Do we need 'Cookie' support in request header?
  #
  # source://httpclient//lib/httpclient/http.rb#1057
  def cookies; end

  # Dumps message (header and body) to given dev.
  # dev needs to respond to <<.
  #
  # source://httpclient//lib/httpclient/http.rb#957
  def dump(dev = T.unsafe(nil)); end

  # HTTP::Message::Headers:: message header.
  #
  # source://httpclient//lib/httpclient/http.rb#933
  def header; end

  # Returns Hash of header. key and value are both String. Each key has a
  # single value so you can't extract exact value when a message has multiple
  # headers like 'Set-Cookie'. Use header['Set-Cookie'] for that purpose.
  # (It returns an Array always)
  #
  # source://httpclient//lib/httpclient/http.rb#1050
  def headers; end

  # HTTP::Message::Body:: message body.
  #
  # source://httpclient//lib/httpclient/http.rb#936
  def http_body; end

  # Sets a new body.  header.body_size is updated with new body.size.
  #
  # source://httpclient//lib/httpclient/http.rb#970
  def http_body=(body); end

  # HTTP::Message::Headers:: message header.
  #
  # source://httpclient//lib/httpclient/http.rb#933
  def http_header; end

  # HTTP::Message::Headers:: message header.
  #
  # source://httpclient//lib/httpclient/http.rb#933
  def http_header=(_arg0); end

  # Returns HTTP version in a HTTP header.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#977
  def http_version; end

  # Sets HTTP version in a HTTP header.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#982
  def http_version=(http_version); end

  # Convenience method to return boolean of whether we had a successful request
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/http.rb#1068
  def ok?; end

  # OpenSSL::X509::Certificate:: response only.  server certificate which is
  #                              used for retrieving the response.
  #
  # source://httpclient//lib/httpclient/http.rb#940
  def peer_cert; end

  # OpenSSL::X509::Certificate:: response only.  server certificate which is
  #                              used for retrieving the response.
  #
  # source://httpclient//lib/httpclient/http.rb#940
  def peer_cert=(_arg0); end

  # The other Message object when this Message is generated instead of
  # the Message because of redirection, negotiation, or format conversion.
  #
  # source://httpclient//lib/httpclient/http.rb#944
  def previous; end

  # The other Message object when this Message is generated instead of
  # the Message because of redirection, negotiation, or format conversion.
  #
  # source://httpclient//lib/httpclient/http.rb#944
  def previous=(_arg0); end

  # Returns  HTTP status reason phrase in response.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#1012
  def reason; end

  # Sets  HTTP status reason phrase of response.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#1017
  def reason=(reason); end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/http.rb#1072
  def redirect?; end

  # SEE_OTHER is a redirect, but it should sent as GET
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/http.rb#1077
  def see_other?; end

  # Returns HTTP status code in response.  Integer.
  #
  # source://httpclient//lib/httpclient/http.rb#998
  def status; end

  # Sets HTTP status code of response.  Integer.
  # Reason phrase is updated, too.
  #
  # source://httpclient//lib/httpclient/http.rb#1007
  def status=(status); end

  # Returns HTTP status code in response.  Integer.
  #
  # source://httpclient//lib/httpclient/http.rb#998
  def status_code; end

  # source://httpclient//lib/httpclient/http.rb#987
  def version; end

  # source://httpclient//lib/httpclient/http.rb#992
  def version=(version); end

  class << self
    # source://httpclient//lib/httpclient/http.rb#852
    def create_query_part_str(query); end

    # source://httpclient//lib/httpclient/http.rb#896
    def escape(str); end

    # source://httpclient//lib/httpclient/http.rb#873
    def escape_query(query); end

    # Returns true if the given object is a File.  In HTTPClient, a file is;
    # * must respond to :read for retrieving String chunks.
    # * must respond to :pos and :pos= to rewind for reading.
    #   Rewinding is only needed for following HTTP redirect.  Some IO impl
    #   defines :pos= but raises an Exception for pos= such as StringIO
    #   but there's no problem as far as using it for non-following methods
    #   (get/post/etc.)
    #
    # @return [Boolean]
    #
    # source://httpclient//lib/httpclient/http.rb#847
    def file?(obj); end

    # Returns MIME type handler.
    #
    # source://httpclient//lib/httpclient/http.rb#785
    def get_mime_type_func; end

    # Default MIME type handler.
    # See mime_type_handler=.
    #
    # source://httpclient//lib/httpclient/http.rb#808
    def internal_mime_type(path); end

    # Returns true if the given HTTP version allows keep alive connection.
    # version:: String
    #
    # @return [Boolean]
    #
    # source://httpclient//lib/httpclient/http.rb#831
    def keep_alive_enabled?(version); end

    # source://httpclient//lib/httpclient/http.rb#793
    def mime_type(path); end

    # Returns MIME type handler.
    #
    # source://httpclient//lib/httpclient/http.rb#785
    def mime_type_handler; end

    # Sets MIME type handler.
    #
    # handler must respond to :call with a single argument :path and returns
    # a MIME type String e.g. 'text/html'.
    # When the handler returns nil or an empty String,
    # 'application/octet-stream' is used.
    #
    # When you set nil to the handler, internal_mime_type is used instead.
    # The handler is nil by default.
    #
    # source://httpclient//lib/httpclient/http.rb#780
    def mime_type_handler=(handler); end

    # Returns true if the given query (or body) has a multiple parameter.
    #
    # @return [Boolean]
    #
    # source://httpclient//lib/httpclient/http.rb#836
    def multiparam_query?(query); end

    # Creates a Message instance of 'CONNECT' request.
    # 'CONNECT' request does not have Body.
    # uri:: an URI that need to connect.  Only uri.host and uri.port are used.
    #
    # source://httpclient//lib/httpclient/http.rb#724
    def new_connect_request(uri); end

    # Creates a Message instance of general request.
    # method:: HTTP method String.
    # uri:: an URI object which represents an URL of web resource.
    # query:: a Hash or an Array of query part of URL.
    #         e.g. { "a" => "b" } => 'http://host/part?a=b'
    #         Give an array to pass multiple value like
    #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'
    # body:: a Hash or an Array of body part.
    #        e.g. { "a" => "b" } => 'a=b'.
    #        Give an array to pass multiple value like
    #        [["a", "b"], ["a", "c"]] => 'a=b&a=c'.
    # boundary:: When the boundary given, it is sent as
    #            a multipart/form-data using this boundary String.
    #
    # source://httpclient//lib/httpclient/http.rb#744
    def new_request(method, uri, query = T.unsafe(nil), body = T.unsafe(nil), boundary = T.unsafe(nil)); end

    # Creates a Message instance of response.
    # body:: a String or an IO of response message body.
    #
    # source://httpclient//lib/httpclient/http.rb#760
    def new_response(body, req = T.unsafe(nil)); end

    # from CGI.parse
    #
    # source://httpclient//lib/httpclient/http.rb#910
    def parse(query); end

    # Sets MIME type handler.
    #
    # handler must respond to :call with a single argument :path and returns
    # a MIME type String e.g. 'text/html'.
    # When the handler returns nil or an empty String,
    # 'application/octet-stream' is used.
    #
    # When you set nil to the handler, internal_mime_type is used instead.
    # The handler is nil by default.
    # For backward compatibility.
    #
    # source://httpclient//lib/httpclient/http.rb#780
    def set_mime_type_func(handler); end

    # from CGI.unescape
    #
    # source://httpclient//lib/httpclient/http.rb#924
    def unescape(string); end

    private

    def new(*_arg0); end
  end
end

# Represents HTTP message body.
#
# source://httpclient//lib/httpclient/http.rb#443
class HTTP::Message::Body
  # Creates a Message::Body.  Use init_request or init_response
  # for acutual initialize.
  #
  # @return [Body] a new instance of Body
  #
  # source://httpclient//lib/httpclient/http.rb#456
  def initialize; end

  # maxbytes of IO#read for streaming request.  See DEFAULT_CHUNK_SIZE.
  #
  # source://httpclient//lib/httpclient/http.rb#447
  def chunk_size; end

  # maxbytes of IO#read for streaming request.  See DEFAULT_CHUNK_SIZE.
  #
  # source://httpclient//lib/httpclient/http.rb#447
  def chunk_size=(_arg0); end

  # Returns a message body itself.
  #
  # source://httpclient//lib/httpclient/http.rb#545
  def content; end

  # Dumps message body to given dev.
  # dev needs to respond to <<.
  #
  # Message header must be given as the first argument for performance
  # reason. (header is dumped to dev, too)
  # If no dev (the second argument) given, this method returns a dumped
  # String.
  #
  # assert: @size is not nil
  #
  # source://httpclient//lib/httpclient/http.rb#494
  def dump(header = T.unsafe(nil), dev = T.unsafe(nil)); end

  # Dumps message body with chunked encoding to given dev.
  # dev needs to respond to <<.
  #
  # Message header must be given as the first argument for performance
  # reason. (header is dumped to dev, too)
  # If no dev (the second argument) given, this method returns a dumped
  # String.
  #
  # source://httpclient//lib/httpclient/http.rb#524
  def dump_chunked(header = T.unsafe(nil), dev = T.unsafe(nil)); end

  # Initialize this instance as a request.
  #
  # source://httpclient//lib/httpclient/http.rb#464
  def init_request(body = T.unsafe(nil), boundary = T.unsafe(nil)); end

  # Initialize this instance as a response.
  #
  # source://httpclient//lib/httpclient/http.rb#473
  def init_response(body = T.unsafe(nil)); end

  # Hash that keeps IO positions
  #
  # source://httpclient//lib/httpclient/http.rb#449
  def positions; end

  # Hash that keeps IO positions
  #
  # source://httpclient//lib/httpclient/http.rb#449
  def positions=(_arg0); end

  # Size of body.  nil when size is unknown (e.g. chunked response).
  #
  # source://httpclient//lib/httpclient/http.rb#445
  def size; end

  private

  # source://httpclient//lib/httpclient/http.rb#663
  def build_query_multipart_str(query, boundary); end

  # source://httpclient//lib/httpclient/http.rb#594
  def dump_chunk(str); end

  # source://httpclient//lib/httpclient/http.rb#602
  def dump_chunk_size(size); end

  # source://httpclient//lib/httpclient/http.rb#587
  def dump_chunks(io, dev); end

  # source://httpclient//lib/httpclient/http.rb#576
  def dump_file(io, dev, sz); end

  # source://httpclient//lib/httpclient/http.rb#598
  def dump_last_chunk; end

  # source://httpclient//lib/httpclient/http.rb#701
  def params_from_file(value); end

  # source://httpclient//lib/httpclient/http.rb#567
  def remember_pos(io); end

  # source://httpclient//lib/httpclient/http.rb#572
  def reset_pos(io); end

  # source://httpclient//lib/httpclient/http.rb#551
  def set_content(body, boundary = T.unsafe(nil)); end
end

# Default value for chunk_size
#
# source://httpclient//lib/httpclient/http.rb#452
HTTP::Message::Body::DEFAULT_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#606
class HTTP::Message::Body::Parts
  # @return [Parts] a new instance of Parts
  #
  # source://httpclient//lib/httpclient/http.rb#610
  def initialize; end

  # source://httpclient//lib/httpclient/http.rb#617
  def add(part); end

  # source://httpclient//lib/httpclient/http.rb#645
  def parts; end

  # Returns the value of attribute size.
  #
  # source://httpclient//lib/httpclient/http.rb#607
  def size; end

  # Returns the value of attribute sizes.
  #
  # source://httpclient//lib/httpclient/http.rb#608
  def sizes; end

  private

  # source://httpclient//lib/httpclient/http.rb#655
  def add_size(part, sz); end
end

# source://httpclient//lib/httpclient/http.rb#101
HTTP::Message::CRLF = T.let(T.unsafe(nil), String)

# Represents HTTP message header.
#
# source://httpclient//lib/httpclient/http.rb#104
class HTTP::Message::Headers
  # Creates a Message::Headers.  Use init_request, init_response, or
  # init_connect_request for acutual initialize.
  #
  # @return [Headers] a new instance of Headers
  #
  # source://httpclient//lib/httpclient/http.rb#162
  def initialize; end

  # Returns an Array of header values for the given key.
  #
  # source://httpclient//lib/httpclient/http.rb#323
  def [](key); end

  # Adds a header.  See set.
  #
  # source://httpclient//lib/httpclient/http.rb#318
  def []=(key, value); end

  # Adds a header.  Addition order is preserved.
  #
  # source://httpclient//lib/httpclient/http.rb#278
  def add(key, value); end

  # Returns an Array of all headers.
  #
  # source://httpclient//lib/httpclient/http.rb#307
  def all; end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#129
  def body_charset; end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#129
  def body_charset=(_arg0); end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#131
  def body_date; end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#131
  def body_date=(_arg0); end

  # Used for keeping content encoding.
  #
  # source://httpclient//lib/httpclient/http.rb#133
  def body_encoding; end

  # Size of body.  nil when size is unknown (e.g. chunked response).
  #
  # source://httpclient//lib/httpclient/http.rb#108
  def body_size; end

  # Sets byte size of message body.
  # body_size == nil means that the body is_a? IO
  #
  # source://httpclient//lib/httpclient/http.rb#254
  def body_size=(body_size); end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#127
  def body_type; end

  # Used for dumping response.
  #
  # source://httpclient//lib/httpclient/http.rb#127
  def body_type=(_arg0); end

  # Request/Response is chunked or not.
  #
  # source://httpclient//lib/httpclient/http.rb#110
  def chunked; end

  # Request/Response is chunked or not.
  #
  # source://httpclient//lib/httpclient/http.rb#110
  def chunked=(_arg0); end

  # Returns 'Content-Type' header value.
  #
  # source://httpclient//lib/httpclient/http.rb#225
  def content_type; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  #
  # source://httpclient//lib/httpclient/http.rb#230
  def content_type=(content_type); end

  # Returns 'Content-Type' header value.
  #
  # source://httpclient//lib/httpclient/http.rb#225
  def contenttype; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  #
  # source://httpclient//lib/httpclient/http.rb#230
  def contenttype=(content_type); end

  # source://httpclient//lib/httpclient/http.rb#346
  def create_query_part; end

  # source://httpclient//lib/httpclient/http.rb#334
  def create_query_uri; end

  # Deletes headers of the given key.
  #
  # source://httpclient//lib/httpclient/http.rb#312
  def delete(key); end

  # Dumps message header part and returns a dumped String.
  #
  # source://httpclient//lib/httpclient/http.rb#259
  def dump; end

  # Returns an Array of headers for the given key.  Each element is a pair
  # of key and value.  It returns an single element Array even if the only
  # one header exists.  If nil key given, it returns all headers.
  #
  # source://httpclient//lib/httpclient/http.rb#297
  def get(key = T.unsafe(nil)); end

  # HTTP version in a HTTP header.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#106
  def http_version; end

  # HTTP version in a HTTP header.  String.
  #
  # source://httpclient//lib/httpclient/http.rb#106
  def http_version=(_arg0); end

  # Initialize this instance as a CONNECT request.
  #
  # source://httpclient//lib/httpclient/http.rb#186
  def init_connect_request(uri); end

  # Initialize this instance as a general request.
  #
  # source://httpclient//lib/httpclient/http.rb#197
  def init_request(method, uri, query = T.unsafe(nil)); end

  # Initialize this instance as a response.
  #
  # source://httpclient//lib/httpclient/http.rb#207
  def init_response(status_code, req = T.unsafe(nil)); end

  # Response only.  HTTP status reason phrase.
  #
  # source://httpclient//lib/httpclient/http.rb#124
  def reason_phrase; end

  # Response only.  HTTP status reason phrase.
  #
  # source://httpclient//lib/httpclient/http.rb#124
  def reason_phrase=(_arg0); end

  # Request only.  Requested via proxy or not.
  #
  # source://httpclient//lib/httpclient/http.rb#119
  def request_absolute_uri; end

  # Request only.  Requested via proxy or not.
  #
  # source://httpclient//lib/httpclient/http.rb#119
  def request_absolute_uri=(_arg0); end

  # Request only.  Requested method.
  #
  # source://httpclient//lib/httpclient/http.rb#113
  def request_method; end

  # Request only.  Requested query.
  #
  # source://httpclient//lib/httpclient/http.rb#117
  def request_query; end

  # Request only.  Requested query.
  #
  # source://httpclient//lib/httpclient/http.rb#117
  def request_query=(_arg0); end

  # Request only.  Requested URI.
  #
  # source://httpclient//lib/httpclient/http.rb#115
  def request_uri; end

  # Request only.  Requested URI.
  #
  # source://httpclient//lib/httpclient/http.rb#115
  def request_uri=(_arg0); end

  # Sets a header.
  #
  # source://httpclient//lib/httpclient/http.rb#289
  def set(key, value); end

  # source://httpclient//lib/httpclient/http.rb#239
  def set_body_encoding; end

  # Set Date header
  #
  # source://httpclient//lib/httpclient/http.rb#273
  def set_date_header; end

  # source://httpclient//lib/httpclient/http.rb#327
  def set_headers(headers); end

  # Response only.  HTTP status
  #
  # source://httpclient//lib/httpclient/http.rb#122
  def status_code; end

  # Sets status code and reason phrase.
  #
  # source://httpclient//lib/httpclient/http.rb#219
  def status_code=(status_code); end

  private

  # source://httpclient//lib/httpclient/http.rb#431
  def charset_label; end

  # source://httpclient//lib/httpclient/http.rb#363
  def request_line; end

  # source://httpclient//lib/httpclient/http.rb#371
  def response_status_line; end

  # source://httpclient//lib/httpclient/http.rb#379
  def set_header; end

  # source://httpclient//lib/httpclient/http.rb#387
  def set_request_header; end

  # source://httpclient//lib/httpclient/http.rb#409
  def set_response_header; end
end

# $KCODE to charset mapping definition.
#
# source://httpclient//lib/httpclient/http.rb#153
HTTP::Message::Headers::CHARSET_MAP = T.let(T.unsafe(nil), Hash)

# Placeholder URI object for nil uri.
#
# source://httpclient//lib/httpclient/http.rb#195
HTTP::Message::Headers::NIL_URI = T.let(T.unsafe(nil), HTTPClient::Util::AddressableURI)

# HTTP response status code to reason phrase mapping definition.
#
# source://httpclient//lib/httpclient/http.rb#136
HTTP::Message::Headers::STATUS_CODE_MAP = T.let(T.unsafe(nil), Hash)

# source://httpclient//lib/httpclient/http.rb#986
HTTP::Message::VERSION_WARNING = T.let(T.unsafe(nil), String)

# Represents HTTP response status code.  Defines constants for HTTP response
# and some conditional methods.
#
# source://httpclient//lib/httpclient/http.rb#24
module HTTP::Status
  class << self
    # Returns true if the given status is thought to be redirect.
    # See also REDIRECT_STATUS.
    #
    # @return [Boolean]
    #
    # source://httpclient//lib/httpclient/http.rb#62
    def redirect?(status); end

    # Returns true if the given status represents successful HTTP response.
    # See also SUCCESSFUL_STATUS.
    #
    # @return [Boolean]
    #
    # source://httpclient//lib/httpclient/http.rb#56
    def successful?(status); end
  end
end

# source://httpclient//lib/httpclient/http.rb#27
HTTP::Status::ACCEPTED = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#36
HTTP::Status::BAD_REQUEST = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#26
HTTP::Status::CREATED = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#33
HTTP::Status::FOUND = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#39
HTTP::Status::INTERNAL = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#32
HTTP::Status::MOVED_PERMANENTLY = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#35
HTTP::Status::MOVED_TEMPORARILY = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#28
HTTP::Status::NON_AUTHORITATIVE_INFORMATION = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#29
HTTP::Status::NO_CONTENT = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#25
HTTP::Status::OK = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#31
HTTP::Status::PARTIAL_CONTENT = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#38
HTTP::Status::PROXY_AUTHENTICATE_REQUIRED = T.let(T.unsafe(nil), Integer)

# Status codes which is a redirect.
#
# source://httpclient//lib/httpclient/http.rb#49
HTTP::Status::REDIRECT_STATUS = T.let(T.unsafe(nil), Array)

# source://httpclient//lib/httpclient/http.rb#30
HTTP::Status::RESET_CONTENT = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#34
HTTP::Status::SEE_OTHER = T.let(T.unsafe(nil), Integer)

# Status codes for successful HTTP response.
#
# source://httpclient//lib/httpclient/http.rb#42
HTTP::Status::SUCCESSFUL_STATUS = T.let(T.unsafe(nil), Array)

# source://httpclient//lib/httpclient/http.rb#35
HTTP::Status::TEMPORARY_REDIRECT = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/http.rb#37
HTTP::Status::UNAUTHORIZED = T.let(T.unsafe(nil), Integer)

# :main:HTTPClient
# The HTTPClient class provides several methods for accessing Web resources
# via HTTP.
#
# HTTPClient instance is designed to be MT-safe.  You can call a HTTPClient
# instance from several threads without synchronization after setting up an
# instance.
#
#   clnt = HTTPClient.new
#   clnt.set_cookie_store('/home/nahi/cookie.dat')
#   urls.each do |url|
#     Thread.new(url) do |u|
#       p clnt.head(u).status
#     end
#   end
#
# == How to use
#
# At first, how to create your client.  See initialize for more detail.
#
# 1. Create simple client.
#
#     clnt = HTTPClient.new
#
# 2. Accessing resources through HTTP proxy.  You can use environment
#    variable 'http_proxy' or 'HTTP_PROXY' instead.
#
#     clnt = HTTPClient.new('http://myproxy:8080')
#
# === How to retrieve web resources
#
# See get and get_content.
#
# 1. Get content of specified URL.  It returns HTTP::Message object and
#    calling 'body' method of it returns a content String.
#
#     puts clnt.get('http://dev.ctor.org/').body
#
# 2. For getting content directly, use get_content.  It follows redirect
#    response and returns a String of whole result.
#
#     puts clnt.get_content('http://dev.ctor.org/')
#
# 3. You can pass :follow_redirect option to follow redirect response in get.
#
#     puts clnt.get('http://dev.ctor.org/', :follow_redirect => true)
#
# 4. Get content as chunks of String.  It yields chunks of String.
#
#     clnt.get_content('http://dev.ctor.org/') do |chunk|
#       puts chunk
#     end
#
# === Invoking other HTTP methods
#
# See head, get, post, put, delete, options, propfind, proppatch and trace.
# It returns a HTTP::Message instance as a response.
#
# 1. Do HEAD request.
#
#     res = clnt.head(uri)
#     p res.header['Last-Modified'][0]
#
# 2. Do GET request with query.
#
#     query = { 'keyword' => 'ruby', 'lang' => 'en' }
#     res = clnt.get(uri, query)
#     p res.status
#     p res.contenttype
#     p res.header['X-Custom']
#     puts res.body
#
#    You can also use keyword argument style.
#
#     res = clnt.get(uri, :query => { :keyword => 'ruby', :lang => 'en' })
#
# === How to POST
#
# See post.
#
# 1. Do POST a form data.
#
#     body = { 'keyword' => 'ruby', 'lang' => 'en' }
#     res = clnt.post(uri, body)
#
#    Keyword argument style.
#
#     res = clnt.post(uri, :body => ...)
#
# 2. Do multipart file upload with POST.  No need to set extra header by
#    yourself from httpclient/2.1.4.
#
#     File.open('/tmp/post_data') do |file|
#       body = { 'upload' => file, 'user' => 'nahi' }
#       res = clnt.post(uri, body)
#     end
#
# 3. Do multipart with custom body.
#
#     File.open('/tmp/post_data') do |file|
#       body = [{ 'Content-Type' => 'application/atom+xml; charset=UTF-8',
#                 :content => '<entry>...</entry>' },
#               { 'Content-Type' => 'video/mp4',
#                 'Content-Transfer-Encoding' => 'binary',
#                 :content => file }]
#       res = clnt.post(uri, body)
#     end
#
# === Accessing via SSL
#
# Ruby needs to be compiled with OpenSSL.
#
# 1. Get content of specified URL via SSL.
#    Just pass an URL which starts with 'https://'.
#
#     https_url = 'https://www.rsa.com'
#     clnt.get(https_url)
#
# 2. Getting peer certificate from response.
#
#     res = clnt.get(https_url)
#     p res.peer_cert #=> returns OpenSSL::X509::Certificate
#
# 3. Configuring OpenSSL options.  See HTTPClient::SSLConfig for more details.
#
#     user_cert_file = 'cert.pem'
#     user_key_file = 'privkey.pem'
#     clnt.ssl_config.set_client_cert_file(user_cert_file, user_key_file)
#     clnt.get(https_url)
#
# 4. Revocation check. On JRuby you can set following options to let
#    HTTPClient to perform revocation check with CRL and OCSP:
#
#     -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
#     ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
#     Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
#
#    On other platform you can download CRL by yourself and set it via
#    SSLConfig#add_crl.
#
# === Handling Cookies
#
# 1. Using volatile Cookies.  Nothing to do.  HTTPClient handles Cookies.
#
#     clnt = HTTPClient.new
#     res = clnt.get(url1) # receives Cookies.
#     res = clnt.get(url2) # sends Cookies if needed.
#     p res.cookies
#
# 2. Saving non volatile Cookies to a specified file.  Need to set a file at
#    first and invoke save method at last.
#
#     clnt = HTTPClient.new
#     clnt.set_cookie_store('/home/nahi/cookie.dat')
#     clnt.get(url)
#     ...
#     clnt.save_cookie_store
#
# 3. Disabling Cookies.
#
#     clnt = HTTPClient.new
#     clnt.cookie_manager = nil
#
# === Configuring authentication credentials
#
# 1. Authentication with Web server.  Supports BasicAuth, DigestAuth, and
#    Negotiate/NTLM (requires ruby/ntlm module).
#
#     clnt = HTTPClient.new
#     domain = 'http://dev.ctor.org/http-access2/'
#     user = 'user'
#     password = 'user'
#     clnt.set_auth(domain, user, password)
#     p clnt.get('http://dev.ctor.org/http-access2/login').status
#
# 2. Authentication with Proxy server.  Supports BasicAuth and NTLM
#    (requires win32/sspi)
#
#     clnt = HTTPClient.new(proxy)
#     user = 'proxy'
#     password = 'proxy'
#     clnt.set_proxy_auth(user, password)
#     p clnt.get(url)
#
# === Invoking HTTP methods with custom header
#
# Pass a Hash or an Array for header argument.
#
#     header = { 'Accept' => 'text/html' }
#     clnt.get(uri, query, header)
#
#     header = [['Accept', 'image/jpeg'], ['Accept', 'image/png']]
#     clnt.get_content(uri, query, header)
#
# === Invoking HTTP methods asynchronously
#
# See head_async, get_async, post_async, put_async, delete_async,
# options_async, propfind_async, proppatch_async, and trace_async.
# It immediately returns a HTTPClient::Connection instance as a returning value.
#
#     connection = clnt.post_async(url, body)
#     print 'posting.'
#     while true
#       break if connection.finished?
#       print '.'
#       sleep 1
#     end
#     puts '.'
#     res = connection.pop
#     p res.status
#     p res.body.read # res.body is an IO for the res of async method.
#
# === Shortcut methods
#
# You can invoke get_content, get, etc. without creating HTTPClient instance.
#
#   ruby -rhttpclient -e 'puts HTTPClient.get_content(ARGV.shift)' http://dev.ctor.org/
#   ruby -rhttpclient -e 'p HTTPClient.head(ARGV.shift).header["last-modified"]' http://dev.ctor.org/
#
# source://httpclient//lib/httpclient/version.rb#1
class HTTPClient
  include ::HTTPClient::Util

  # Creates a HTTPClient instance which manages sessions, cookies, etc.
  #
  # HTTPClient.new takes optional arguments as a Hash.
  #  * :proxy - proxy url string
  #  * :agent_name - User-Agent String
  #  * :from - from header String
  #  * :base_url - base URL of resources
  #  * :default_header - header Hash all HTTP requests should have
  #  * :force_basic_auth - flag for sending Authorization header w/o gettin 401 first
  # User-Agent and From are embedded in HTTP request Header if given.
  # From header is not set without setting it explicitly.
  #
  #   proxy = 'http://myproxy:8080'
  #   agent_name = 'MyAgent/0.1'
  #   from = 'from@example.com'
  #   HTTPClient.new(proxy, agent_name, from)
  #
  # After you set :base_url, all resources you pass to get, post and other
  # methods are recognized to be prefixed with base_url. Say base_url is
  # 'https://api.example.com/v1/, get('users') is the same as
  # get('https://api.example.com/v1/users') internally. You can also pass
  # full URL from 'http://' even after setting base_url.
  #
  # The expected base_url and path behavior is the following. Please take
  # care of '/' in base_url and path.
  #
  # The last '/' is important for base_url:
  #   1. http://foo/bar/baz/ + path -> http://foo/bar/baz/path
  #   2. http://foo/bar/baz + path -> http://foo/bar/path
  # Relative path handling:
  #   3. http://foo/bar/baz/ + ../path -> http://foo/bar/path
  #   4. http://foo/bar/baz + ../path -> http://foo/path
  #   5. http://foo/bar/baz/ + ./path -> http://foo/bar/baz/path
  #   6. http://foo/bar/baz + ./path -> http://foo/bar/path
  # The leading '/' of path means absolute path:
  #   7. http://foo/bar/baz/ + /path -> http://foo/path
  #   8. http://foo/bar/baz + /path -> http://foo/path
  #
  # :default_header is for providing default headers Hash that all HTTP
  # requests should have, such as custom 'Authorization' header in API.
  # You can override :default_header with :header Hash parameter in HTTP
  # request methods.
  #
  # :force_basic_auth turns on/off the BasicAuth force flag. Generally
  # HTTP client must send Authorization header after it gets 401 error
  # from server from security reason. But in some situation (e.g. API
  # client) you might want to send Authorization from the beginning.
  #
  # @return [HTTPClient] a new instance of HTTPClient
  #
  # source://httpclient//lib/httpclient.rb#428
  def initialize(*args, &block); end

  # source://httpclient//lib/httpclient.rb#306
  def agent_name; end

  # source://httpclient//lib/httpclient.rb#311
  def agent_name=(rhs); end

  # Base url of resources.
  #
  # source://httpclient//lib/httpclient.rb#337
  def base_url; end

  # Base url of resources.
  #
  # source://httpclient//lib/httpclient.rb#337
  def base_url=(_arg0); end

  # source://httpclient//lib/httpclient.rb#306
  def connect_timeout; end

  # source://httpclient//lib/httpclient.rb#311
  def connect_timeout=(rhs); end

  # HTTPClient::CookieManager:: Cookies configurator.
  #
  # source://httpclient//lib/httpclient.rb#321
  def cookie_manager; end

  # HTTPClient::CookieManager:: Cookies configurator.
  #
  # source://httpclient//lib/httpclient.rb#321
  def cookie_manager=(_arg0); end

  # Returns stored cookies.
  #
  # source://httpclient//lib/httpclient.rb#614
  def cookies; end

  # Returns debug device if exists.  See debug_dev=.
  #
  # source://httpclient//lib/httpclient.rb#471
  def debug_dev; end

  # Sets debug device.  Once debug device is set, all HTTP requests and
  # responses are dumped to given device.  dev must respond to << for dump.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#479
  def debug_dev=(dev); end

  # Default request header.
  #
  # source://httpclient//lib/httpclient.rb#339
  def default_header; end

  # Default request header.
  #
  # source://httpclient//lib/httpclient.rb#339
  def default_header=(_arg0); end

  # A default method for redirect uri callback.  This method is used by
  # HTTPClient instance by default.
  # This callback allows relative redirect such as
  #   Location: ../foo/
  # in HTTP header.
  #
  # source://httpclient//lib/httpclient.rb#722
  def default_redirect_uri_callback(uri, res); end

  # Sends DELETE request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#779
  def delete(uri, *args, &block); end

  # Sends DELETE request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#907
  def delete_async(uri, *args); end

  # How many times get_content and post_content follows HTTP redirect.
  # 10 by default.
  #
  # source://httpclient//lib/httpclient.rb#335
  def follow_redirect_count; end

  # How many times get_content and post_content follows HTTP redirect.
  # 10 by default.
  #
  # source://httpclient//lib/httpclient.rb#335
  def follow_redirect_count=(_arg0); end

  # Turn on/off the BasicAuth force flag. Generally HTTP client must
  # send Authorization header after it gets 401 error from server from
  # security reason. But in some situation (e.g. API client) you might
  # want to send Authorization from the beginning.
  #
  # source://httpclient//lib/httpclient.rb#592
  def force_basic_auth=(force_basic_auth); end

  # source://httpclient//lib/httpclient.rb#306
  def from; end

  # source://httpclient//lib/httpclient.rb#311
  def from=(rhs); end

  # Sends GET request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#742
  def get(uri, *args, &block); end

  # Sends GET request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#868
  def get_async(uri, *args); end

  # Retrieves a web resource.
  #
  # uri:: a String or an URI object which represents an URL of web resource.
  # query:: a Hash or an Array of query part of URL.
  #         e.g. { "a" => "b" } => 'http://host/part?a=b'.
  #         Give an array to pass multiple value like
  #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'.
  # header:: a Hash or an Array of extra headers.  e.g.
  #          { 'Accept' => 'text/html' } or
  #          [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #          get_content(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # get_content follows HTTP redirect status (see HTTP::Status.redirect?)
  # internally and try to retrieve content from redirected URL.  See
  # redirect_uri_callback= how HTTP redirection is handled.
  #
  # If you need to get full HTTP response including HTTP status and headers,
  # use get method.  get returns HTTP::Message as a response and you need to
  # follow HTTP redirect by yourself if you need.
  #
  # source://httpclient//lib/httpclient.rb#653
  def get_content(uri, *args, &block); end

  # Sends HEAD request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#737
  def head(uri, *args); end

  # Sends HEAD request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#862
  def head_async(uri, *args); end

  # source://httpclient//lib/httpclient.rb#306
  def keep_alive_timeout; end

  # source://httpclient//lib/httpclient.rb#311
  def keep_alive_timeout=(rhs); end

  # webmock 1.6.2 depends on HTTP::Message#body.content to work.
  # let's keep it work iif webmock is loaded for a while.
  #
  # source://httpclient//lib/httpclient.rb#457
  def keep_webmock_compat; end

  # Returns NO_PROXY setting String if given.
  #
  # source://httpclient//lib/httpclient.rb#521
  def no_proxy; end

  # Sets NO_PROXY setting String.  no_proxy must be a comma separated String.
  # Each entry must be 'host' or 'host:port' such as;
  # HTTPClient#no_proxy = 'example.com,example.co.jp:443'
  #
  # 'localhost' is treated as a no_proxy site regardless of explicitly listed.
  # HTTPClient checks given URI objects before accessing it.
  # 'host' is tail string match.  No IP-addr conversion.
  #
  # You can use environment variable 'no_proxy' or 'NO_PROXY' for it.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#536
  def no_proxy=(no_proxy); end

  # Sends OPTIONS request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#784
  def options(uri, *args, &block); end

  # Sends OPTIONS request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#913
  def options_async(uri, *args); end

  # Sends PATCH request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#747
  def patch(uri, *args, &block); end

  # Sends PATCH request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#874
  def patch_async(uri, *args); end

  # Sends POST request to the specified URL.  See request for arguments.
  # You should not depend on :follow_redirect => true for POST method.  It
  # sends the same POST method to the new location which is prohibited in HTTP spec.
  #
  # source://httpclient//lib/httpclient.rb#759
  def post(uri, *args, &block); end

  # Sends POST request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#885
  def post_async(uri, *args); end

  # Posts a content.
  #
  # uri:: a String or an URI object which represents an URL of web resource.
  # body:: a Hash or an Array of body part. e.g.
  #          { "a" => "b" } => 'a=b'
  #        Give an array to pass multiple value like
  #          [["a", "b"], ["a", "c"]] => 'a=b&a=c'
  #        When you pass a File as a value, it will be posted as a
  #        multipart/form-data.  e.g.
  #          { 'upload' => file }
  #        You can also send custom multipart by passing an array of hashes.
  #        Each part must have a :content attribute which can be a file, all
  #        other keys will become headers.
  #          [{ 'Content-Type' => 'text/plain', :content => "some text" },
  #           { 'Content-Type' => 'video/mp4', :content => File.new('video.mp4') }]
  #          => <Two parts with custom Content-Type header>
  # header:: a Hash or an Array of extra headers. e.g.
  #            { 'Accept' => 'text/html' }
  #          or
  #            [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #            post_content(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # post_content follows HTTP redirect status (see HTTP::Status.redirect?)
  # internally and try to post the content to redirected URL.  See
  # redirect_uri_callback= how HTTP redirection is handled.
  # Bear in mind that you should not depend on post_content because it sends
  # the same POST method to the new location which is prohibited in HTTP spec.
  #
  # If you need to get full HTTP response including HTTP status and headers,
  # use post method.
  #
  # source://httpclient//lib/httpclient.rb#690
  def post_content(uri, *args, &block); end

  # Sends PROPFIND request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#790
  def propfind(uri, *args, &block); end

  # Sends PROPFIND request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#919
  def propfind_async(uri, *args); end

  # Sends PROPPATCH request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#795
  def proppatch(uri, *args, &block); end

  # Sends PROPPATCH request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#925
  def proppatch_async(uri, *args); end

  # source://httpclient//lib/httpclient.rb#306
  def protocol_retry_count; end

  # source://httpclient//lib/httpclient.rb#311
  def protocol_retry_count=(rhs); end

  # source://httpclient//lib/httpclient.rb#306
  def protocol_version; end

  # source://httpclient//lib/httpclient.rb#311
  def protocol_version=(rhs); end

  # Returns URI object of HTTP proxy if exists.
  #
  # source://httpclient//lib/httpclient.rb#486
  def proxy; end

  # Sets HTTP proxy used for HTTP connection.  Given proxy can be an URI,
  # a String or nil.  You can set user/password for proxy authentication like
  # HTTPClient#proxy = 'http://user:passwd@myproxy:8080'
  #
  # You can use environment variable 'http_proxy' or 'HTTP_PROXY' for it.
  # You need to use 'cgi_http_proxy' or 'CGI_HTTP_PROXY' instead if you run
  # HTTPClient from CGI environment from security reason. (HTTPClient checks
  # 'REQUEST_METHOD' environment variable whether it's CGI or not)
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#500
  def proxy=(proxy); end

  # HTTPClient::ProxyAuth:: Proxy authentication handler.
  #
  # source://httpclient//lib/httpclient.rb#330
  def proxy_auth; end

  # Sends PUT request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#769
  def put(uri, *args, &block); end

  # Sends PUT request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#896
  def put_async(uri, *args); end

  # source://httpclient//lib/httpclient.rb#306
  def read_block_size; end

  # source://httpclient//lib/httpclient.rb#311
  def read_block_size=(rhs); end

  # source://httpclient//lib/httpclient.rb#306
  def receive_timeout; end

  # source://httpclient//lib/httpclient.rb#311
  def receive_timeout=(rhs); end

  # Sets callback proc when HTTP redirect status is returned for get_content
  # and post_content.  default_redirect_uri_callback is used by default.
  #
  # If you need strict implementation which does not allow relative URI
  # redirection, set strict_redirect_uri_callback instead.
  #
  #   clnt.redirect_uri_callback = clnt.method(:strict_redirect_uri_callback)
  #
  # source://httpclient//lib/httpclient.rb#628
  def redirect_uri_callback=(redirect_uri_callback); end

  # Sends a request to the specified URL.
  #
  # method:: HTTP method to be sent.  method.to_s.upcase is used.
  # uri:: a String or an URI object which represents an URL of web resource.
  # query:: a Hash or an Array of query part of URL.
  #         e.g. { "a" => "b" } => 'http://host/part?a=b'
  #         Give an array to pass multiple value like
  #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'
  # body:: a Hash or an Array of body part. e.g.
  #          { "a" => "b" }
  #          => 'a=b'
  #        Give an array to pass multiple value like
  #          [["a", "b"], ["a", "c"]]
  #          => 'a=b&a=c'.
  #        When the given method is 'POST' and the given body contains a file
  #        as a value, it will be posted as a multipart/form-data. e.g.
  #          { 'upload' => file }
  #        You can also send custom multipart by passing an array of hashes.
  #        Each part must have a :content attribute which can be a file, all
  #        other keys will become headers.
  #          [{ 'Content-Type' => 'text/plain', :content => "some text" },
  #           { 'Content-Type' => 'video/mp4', :content => File.new('video.mp4') }]
  #          => <Two parts with custom Content-Type header>
  #        See HTTP::Message.file? for actual condition of 'a file'.
  # header:: a Hash or an Array of extra headers.  e.g.
  #          { 'Accept' => 'text/html' } or
  #          [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #          get(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # You can also pass a String as a body.  HTTPClient just sends a String as
  # a HTTP request message body.
  #
  # When you pass an IO as a body, HTTPClient sends it as a HTTP request with
  # chunked encoding (Transfer-Encoding: chunked in HTTP header) if IO does not
  # respond to :size. Bear in mind that some server application does not support
  # chunked request.  At least cgi.rb does not support it.
  #
  # source://httpclient//lib/httpclient.rb#842
  def request(method, uri, *args, &block); end

  # Sends a request in async style.  request method creates new Thread for
  # HTTP connection and returns a HTTPClient::Connection instance immediately.
  #
  # Arguments definition is the same as request.
  #
  # source://httpclient//lib/httpclient.rb#939
  def request_async(method, uri, query = T.unsafe(nil), body = T.unsafe(nil), header = T.unsafe(nil)); end

  # new method that has same signature as 'request'
  #
  # source://httpclient//lib/httpclient.rb#945
  def request_async2(method, uri, *args); end

  # An array of request filter which can trap HTTP request/response.
  # See HTTPClient::WWWAuth to see how to use it.
  #
  # source://httpclient//lib/httpclient.rb#328
  def request_filter; end

  # Resets internal session for the given URL.  Keep-alive connection for the
  # site (host-port pair) is disconnected if exists.
  #
  # source://httpclient//lib/httpclient.rb#961
  def reset(uri); end

  # Resets all of internal sessions.  Keep-alive connections are disconnected.
  #
  # source://httpclient//lib/httpclient.rb#967
  def reset_all; end

  # Try to save Cookies to the file specified in set_cookie_store.  Unexpected
  # error will be raised if you don't call set_cookie_store first.
  #
  # source://httpclient//lib/httpclient.rb#609
  def save_cookie_store; end

  # source://httpclient//lib/httpclient.rb#306
  def send_timeout; end

  # source://httpclient//lib/httpclient.rb#311
  def send_timeout=(rhs); end

  # Sets credential for Web server authentication.
  # domain:: a String or an URI to specify where HTTPClient should use this
  #       credential.  If you set uri to nil, HTTPClient uses this credential
  #       wherever a server requires it.
  # user:: username String.
  # passwd:: password String.
  #
  # You can set multiple credentials for each uri.
  #
  #   clnt.set_auth('http://www.example.com/foo/', 'foo_user', 'passwd')
  #   clnt.set_auth('http://www.example.com/bar/', 'bar_user', 'passwd')
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#565
  def set_auth(domain, user, passwd); end

  # Deprecated.  Use set_auth instead.
  #
  # source://httpclient//lib/httpclient.rb#572
  def set_basic_auth(domain, user, passwd); end

  # Sets the filename where non-volatile Cookies be saved by calling
  # save_cookie_store.
  # This method tries to load and managing Cookies from the specified file.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#601
  def set_cookie_store(filename); end

  # Sets credential for Proxy authentication.
  # user:: username String.
  # passwd:: password String.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient.rb#583
  def set_proxy_auth(user, passwd); end

  # source://httpclient//lib/httpclient.rb#306
  def socket_local; end

  # source://httpclient//lib/httpclient.rb#311
  def socket_local=(rhs); end

  # source://httpclient//lib/httpclient.rb#306
  def socket_sync; end

  # source://httpclient//lib/httpclient.rb#311
  def socket_sync=(rhs); end

  # HTTPClient::SSLConfig:: SSL configurator.
  #
  # source://httpclient//lib/httpclient.rb#319
  def ssl_config; end

  # A method for redirect uri callback.  How to use:
  #   clnt.redirect_uri_callback = clnt.method(:strict_redirect_uri_callback)
  # This callback does not allow relative redirect such as
  #   Location: ../foo/
  # in HTTP header. (raises BadResponseError instead)
  #
  # source://httpclient//lib/httpclient.rb#705
  def strict_redirect_uri_callback(uri, res); end

  # source://httpclient//lib/httpclient.rb#306
  def strict_response_size_check; end

  # source://httpclient//lib/httpclient.rb#311
  def strict_response_size_check=(rhs); end

  # source://httpclient//lib/httpclient.rb#306
  def tcp_keepalive; end

  # source://httpclient//lib/httpclient.rb#311
  def tcp_keepalive=(rhs); end

  # source://httpclient//lib/httpclient.rb#306
  def test_loopback_http_response; end

  # An array of response HTTP message body String which is used for loop-back
  # test.  See test/* to see how to use it.  If you want to do loop-back test
  # of HTTP header, use test_loopback_http_response instead.
  #
  # source://httpclient//lib/httpclient.rb#325
  def test_loopback_response; end

  # Sends TRACE request to the specified URL.  See request for arguments.
  #
  # source://httpclient//lib/httpclient.rb#800
  def trace(uri, *args, &block); end

  # Sends TRACE request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  #
  # source://httpclient//lib/httpclient.rb#931
  def trace_async(uri, *args); end

  # source://httpclient//lib/httpclient.rb#306
  def transparent_gzip_decompression; end

  # source://httpclient//lib/httpclient.rb#311
  def transparent_gzip_decompression=(rhs); end

  # HTTPClient::WWWAuth:: WWW authentication handler.
  #
  # source://httpclient//lib/httpclient.rb#332
  def www_auth; end

  private

  # source://httpclient//lib/httpclient.rb#1083
  def adapt_block(&block); end

  # source://httpclient//lib/httpclient.rb#1190
  def create_boundary; end

  # source://httpclient//lib/httpclient.rb#1145
  def create_request(method, uri, query, body, header); end

  # !! CAUTION !!
  #   Method 'do_get*' runs under MT conditon. Be careful to change.
  #
  # source://httpclient//lib/httpclient.rb#1229
  def do_get_block(req, proxy, conn, &block); end

  # source://httpclient//lib/httpclient.rb#1298
  def do_get_header(req, res, sess); end

  # source://httpclient//lib/httpclient.rb#1267
  def do_get_stream(req, proxy, conn); end

  # source://httpclient//lib/httpclient.rb#998
  def do_request(method, uri, query, body, header, &block); end

  # source://httpclient//lib/httpclient.rb#1036
  def do_request_async(method, uri, query, body, header); end

  # source://httpclient//lib/httpclient.rb#1308
  def dump_dummy_request_response(req, res); end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient.rb#1194
  def file_in_form_data?(body); end

  # @raise [BadResponseError]
  #
  # source://httpclient//lib/httpclient.rb#1088
  def follow_redirect(method, uri, query, body, header, &block); end

  # source://httpclient//lib/httpclient.rb#1079
  def getenv(name); end

  # source://httpclient//lib/httpclient.rb#991
  def hashy_argument_has_keys(args, *key); end

  # source://httpclient//lib/httpclient.rb#1065
  def load_environment; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient.rb#1213
  def no_proxy?(uri); end

  # source://httpclient//lib/httpclient.rb#1199
  def override_header(header, key, value); end

  # source://httpclient//lib/httpclient.rb#1131
  def protect_keep_alive_disconnected; end

  # source://httpclient//lib/httpclient.rb#1315
  def set_encoding(str, encoding); end

  # source://httpclient//lib/httpclient.rb#1123
  def success_content(res); end

  # source://httpclient//lib/httpclient.rb#1319
  def to_resource_url(uri); end

  class << self
    def delete(*arg, &block); end
    def get(*arg, &block); end
    def get_content(*arg, &block); end
    def head(*arg, &block); end
    def options(*arg, &block); end
    def post(*arg, &block); end
    def post_content(*arg, &block); end
    def propfind(*arg, &block); end
    def proppatch(*arg, &block); end
    def put(*arg, &block); end
    def trace(*arg, &block); end

    private

    # source://httpclient//lib/httpclient.rb#304
    def attr_proxy(symbol, assignable = T.unsafe(nil)); end
  end
end

# Authentication filter base class.
#
# source://httpclient//lib/httpclient/auth.rb#226
class HTTPClient::AuthBase
  include ::HTTPClient::Util

  # @return [AuthBase] a new instance of AuthBase
  #
  # source://httpclient//lib/httpclient/auth.rb#232
  def initialize(scheme); end

  # Resets challenge state.  Do not send '*Authorization' header until the
  # server sends '*Authentication' again.
  #
  # source://httpclient//lib/httpclient/auth.rb#239
  def reset_challenge; end

  # Authentication scheme.
  #
  # source://httpclient//lib/httpclient/auth.rb#230
  def scheme; end
end

# Common abstract class for authentication filter.
#
# There are 2 authentication filters.
# WWWAuth:: Authentication filter for handling authentication negotiation
#           between Web server.  Parses 'WWW-Authentication' header in
#           response and generates 'Authorization' header in request.
# ProxyAuth:: Authentication filter for handling authentication negotiation
#             between Proxy server.  Parses 'Proxy-Authentication' header in
#             response and generates 'Proxy-Authorization' header in request.
#
# source://httpclient//lib/httpclient/auth.rb#29
class HTTPClient::AuthFilterBase
  private

  # source://httpclient//lib/httpclient/auth.rb#32
  def parse_authentication_header(res, tag); end

  # source://httpclient//lib/httpclient/auth.rb#38
  def parse_challenge_header(challenge); end
end

# Raised for indicating HTTP response error.
#
# source://httpclient//lib/httpclient.rb#253
class HTTPClient::BadResponseError < ::RuntimeError
  # @return [BadResponseError] a new instance of BadResponseError
  #
  # source://httpclient//lib/httpclient.rb#257
  def initialize(msg, res = T.unsafe(nil)); end

  # HTTP::Message:: a response
  #
  # source://httpclient//lib/httpclient.rb#255
  def res; end
end

# Authentication filter for handling BasicAuth negotiation.
# Used in WWWAuth and ProxyAuth.
#
# source://httpclient//lib/httpclient/auth.rb#248
class HTTPClient::BasicAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new BasicAuth filter.
  #
  # @return [BasicAuth] a new instance of BasicAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#255
  def initialize; end

  # Challenge handler: remember URL for response.
  #
  # source://httpclient//lib/httpclient/auth.rb#298
  def challenge(uri, param_str = T.unsafe(nil)); end

  # Send Authorization Header without receiving 401
  #
  # source://httpclient//lib/httpclient/auth.rb#252
  def force_auth; end

  # Send Authorization Header without receiving 401
  #
  # source://httpclient//lib/httpclient/auth.rb#252
  def force_auth=(_arg0); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  #
  # source://httpclient//lib/httpclient/auth.rb#284
  def get(req); end

  # source://mutex_m/0.1.2/mutex_m.rb#93
  def lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#83
  def locked?; end

  # Set authentication credential.
  # uri == nil for generic purpose (allow to use user/password for any URL).
  #
  # source://httpclient//lib/httpclient/auth.rb#264
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/auth.rb#276
  def set?; end

  # source://mutex_m/0.1.2/mutex_m.rb#78
  def synchronize(&block); end

  # source://mutex_m/0.1.2/mutex_m.rb#88
  def try_lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#98
  def unlock; end
end

# Raised for indicating running environment configuration error for example
# accessing via SSL under the ruby which is not compiled with OpenSSL.
#
# source://httpclient//lib/httpclient.rb#249
class HTTPClient::ConfigurationError < ::StandardError; end

# Raised for indicating a connection timeout error.
# You can configure connection timeout via HTTPClient#connect_timeout=.
#
# source://httpclient//lib/httpclient.rb#269
class HTTPClient::ConnectTimeoutError < ::HTTPClient::TimeoutError; end

# Represents a HTTP response to an asynchronous request.  Async methods of
# HTTPClient such as get_async, post_async, etc. returns an instance of
# Connection.
#
# == How to use
#
# 1. Invoke HTTP method asynchronously and check if it's been finished
#    periodically.
#
#     connection = clnt.post_async(url, body)
#     print 'posting.'
#     while true
#       break if connection.finished?
#       print '.'
#       sleep 1
#     end
#     puts '.'
#     res = connection.pop
#     p res.status
#
# 2. Read the response as an IO.
#
#     connection = clnt.get_async('http://dev.ctor.org/')
#     io = connection.pop.content
#     while str = io.read(40)
#       p str
#     end
#
# source://httpclient//lib/httpclient/connection.rb#39
class HTTPClient::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://httpclient//lib/httpclient/connection.rb#42
  def initialize(header_queue = T.unsafe(nil), body_queue = T.unsafe(nil)); end

  # Returns the value of attribute async_thread.
  #
  # source://httpclient//lib/httpclient/connection.rb#40
  def async_thread; end

  # Sets the attribute async_thread
  #
  # @param value the value to set the attribute async_thread to.
  #
  # source://httpclient//lib/httpclient/connection.rb#40
  def async_thread=(_arg0); end

  # Checks if the asynchronous invocation has been finished or not.
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/connection.rb#50
  def finished?; end

  # Waits the completion of the asynchronous invocation.
  #
  # source://httpclient//lib/httpclient/connection.rb#79
  def join; end

  # Retrieves a HTTP::Message instance of HTTP response.  Do not invoke this
  # method twice for now.  The second invocation will be blocked.
  #
  # source://httpclient//lib/httpclient/connection.rb#66
  def pop; end

  # source://httpclient//lib/httpclient/connection.rb#74
  def push(result); end
end

# source://httpclient//lib/httpclient/cookie.rb#9
class HTTPClient::CookieManager
  include ::HTTPClient::Util

  # source://httpclient//lib/httpclient/cookie.rb#15
  def initialize(cookies_file = T.unsafe(nil), format = T.unsafe(nil), jar = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/cookie.rb#69
  def add(cookie); end

  # source://httpclient//lib/httpclient/cookie.rb#51
  def cookie_value(uri); end

  # source://httpclient//lib/httpclient/cookie.rb#33
  def cookies(uri = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/cookie.rb#62
  def cookies=(cookies); end

  # source://httpclient//lib/httpclient/cookie.rb#13
  def cookies_file; end

  # source://httpclient//lib/httpclient/cookie.rb#13
  def cookies_file=(_arg0); end

  # source://httpclient//lib/httpclient/cookie.rb#73
  def find(uri); end

  # source://httpclient//lib/httpclient/cookie.rb#12
  def format; end

  # source://httpclient//lib/httpclient/cookie.rb#12
  def jar; end

  # source://httpclient//lib/httpclient/cookie.rb#22
  def load_cookies; end

  # source://httpclient//lib/httpclient/cookie.rb#58
  def parse(value, uri); end

  # source://httpclient//lib/httpclient/cookie.rb#28
  def save_cookies(session = T.unsafe(nil)); end

  private

  # source://httpclient//lib/httpclient/cookie.rb#82
  def check_cookies_file; end
end

# Default User-Agent header
#
# source://httpclient//lib/httpclient.rb#379
HTTPClient::DEFAULT_AGENT_NAME = T.let(T.unsafe(nil), String)

# Module for intercepting Socket methods and dumps in/out to given debugging
# device.  debug_dev must respond to <<.
#
# source://httpclient//lib/httpclient/session.rb#362
module HTTPClient::DebugSocket
  extend ::HTTPClient::SocketWrap

  # source://httpclient//lib/httpclient/session.rb#392
  def <<(str); end

  # source://httpclient//lib/httpclient/session.rb#369
  def close; end

  # source://httpclient//lib/httpclient/session.rb#365
  def debug_dev=(debug_dev); end

  # source://httpclient//lib/httpclient/session.rb#374
  def gets(rs); end

  # source://httpclient//lib/httpclient/session.rb#380
  def read(size, buf = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/session.rb#386
  def readpartial(size, buf = T.unsafe(nil)); end

  private

  # source://httpclient//lib/httpclient/session.rb#399
  def debug(str); end
end

# Authentication filter for handling DigestAuth negotiation.
# Used in WWWAuth.
#
# source://httpclient//lib/httpclient/auth.rb#331
class HTTPClient::DigestAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new DigestAuth filter.
  #
  # @return [DigestAuth] a new instance of DigestAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#335
  def initialize; end

  # Challenge handler: remember URL and challenge token for response.
  #
  # source://httpclient//lib/httpclient/auth.rb#377
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  #
  # source://httpclient//lib/httpclient/auth.rb#361
  def get(req); end

  # source://mutex_m/0.1.2/mutex_m.rb#93
  def lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#83
  def locked?; end

  # Set authentication credential.
  # uri == nil is ignored.
  #
  # source://httpclient//lib/httpclient/auth.rb#343
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/auth.rb#353
  def set?; end

  # source://mutex_m/0.1.2/mutex_m.rb#78
  def synchronize(&block); end

  # source://mutex_m/0.1.2/mutex_m.rb#88
  def try_lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#98
  def unlock; end

  private

  # this method is implemented by sromano and posted to
  # http://tools.assembla.com/breakout/wiki/DigestForSoap
  # Thanks!
  # supported algorithms: MD5, MD5-sess
  #
  # source://httpclient//lib/httpclient/auth.rb#390
  def calc_cred(req, user, passwd, param); end

  # cf. WEBrick::HTTPAuth::DigestAuth#generate_next_nonce(aTime)
  #
  # source://httpclient//lib/httpclient/auth.rb#437
  def generate_cnonce; end

  # source://httpclient//lib/httpclient/auth.rb#443
  def parse_challenge_param(param_str); end
end

# source://httpclient//lib/httpclient/auth.rb#18
HTTPClient::GSSAPIEnabled = T.let(T.unsafe(nil), FalseClass)

# source://httpclient//lib/httpclient.rb#981
class HTTPClient::KeepAliveDisconnected < ::StandardError
  # @return [KeepAliveDisconnected] a new instance of KeepAliveDisconnected
  #
  # source://httpclient//lib/httpclient.rb#984
  def initialize(sess = T.unsafe(nil), cause = T.unsafe(nil)); end

  # Returns the value of attribute cause.
  #
  # source://httpclient//lib/httpclient.rb#983
  def cause; end

  # Returns the value of attribute sess.
  #
  # source://httpclient//lib/httpclient.rb#982
  def sess; end
end

# source://httpclient//lib/httpclient.rb#243
HTTPClient::LIB_NAME = T.let(T.unsafe(nil), String)

# Dummy Socket for emulating loopback test.
#
# source://httpclient//lib/httpclient/session.rb#414
class HTTPClient::LoopBackSocket
  include ::HTTPClient::SocketWrap

  # @return [LoopBackSocket] a new instance of LoopBackSocket
  #
  # source://httpclient//lib/httpclient/session.rb#417
  def initialize(host, port, response); end

  # source://httpclient//lib/httpclient/session.rb#423
  def <<(str); end

  # source://httpclient//lib/httpclient/session.rb#427
  def peer_cert; end
end

# source://httpclient//lib/httpclient.rb#1211
HTTPClient::NO_PROXY_HOSTS = T.let(T.unsafe(nil), Array)

# source://httpclient//lib/httpclient/auth.rb#16
HTTPClient::NTLMEnabled = T.let(T.unsafe(nil), FalseClass)

# Authentication filter for handling Negotiate/NTLM negotiation.
# Used in WWWAuth and ProxyAuth.
#
# NegotiateAuth depends on 'ruby/ntlm' module.
#
# source://httpclient//lib/httpclient/auth.rb#499
class HTTPClient::NegotiateAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new NegotiateAuth filter.
  #
  # @return [NegotiateAuth] a new instance of NegotiateAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#506
  def initialize(scheme = T.unsafe(nil)); end

  # Challenge handler: remember URL and challenge token for response.
  #
  # source://httpclient//lib/httpclient/auth.rb#575
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # See ruby/ntlm for negotiation state transition.
  #
  # source://httpclient//lib/httpclient/auth.rb#535
  def get(req); end

  # source://mutex_m/0.1.2/mutex_m.rb#93
  def lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#83
  def locked?; end

  # NTLM opt for ruby/ntlm.  {:ntlmv2 => true} by default.
  #
  # source://httpclient//lib/httpclient/auth.rb#503
  def ntlm_opt; end

  # Set authentication credential.
  # uri == nil for generic purpose (allow to use user/password for any URL).
  #
  # source://httpclient//lib/httpclient/auth.rb#517
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/auth.rb#529
  def set?; end

  # source://mutex_m/0.1.2/mutex_m.rb#78
  def synchronize(&block); end

  # source://mutex_m/0.1.2/mutex_m.rb#88
  def try_lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#98
  def unlock; end
end

# Authentication filter for handling OAuth negotiation.
# Used in WWWAuth.
#
# CAUTION: This impl only support '#7 Accessing Protected Resources' in OAuth
# Core 1.0 spec for now. You need to obtain Access token and Access secret by
# yourself.
#
# CAUTION: This impl does NOT support OAuth Request Body Hash spec for now.
# http://oauth.googlecode.com/svn/spec/ext/body_hash/1.0/oauth-bodyhash.html
#
# source://httpclient//lib/httpclient/auth.rb#682
class HTTPClient::OAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new DigestAuth filter.
  #
  # @return [OAuth] a new instance of OAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#753
  def initialize; end

  # Challenge handler: remember URL for response.
  #
  # challenge() in OAuth handler always returns false to avoid connection
  # retry which should not work in OAuth authentication context.  This
  # method just remember URL (nil means 'any') for the next connection.
  # Normally OAuthClient handles this correctly but see how it uses when
  # you need to use this class directly.
  #
  # source://httpclient//lib/httpclient/auth.rb#816
  def challenge(uri, param_str = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/auth.rb#748
  def escape(str); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  #
  # source://httpclient//lib/httpclient/auth.rb#797
  def get(req); end

  # Get authentication credential.
  #
  # source://httpclient//lib/httpclient/auth.rb#787
  def get_config(uri = T.unsafe(nil)); end

  # source://mutex_m/0.1.2/mutex_m.rb#93
  def lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#83
  def locked?; end

  # Set authentication credential.
  # You cannot set OAuth config via WWWAuth#set_auth. Use OAuth#config=
  #
  # source://httpclient//lib/httpclient/auth.rb#765
  def set(*args); end

  # Check always (not effective but it works)
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/auth.rb#770
  def set?; end

  # Set authentication credential.
  #
  # source://httpclient//lib/httpclient/auth.rb#775
  def set_config(uri, config); end

  # source://mutex_m/0.1.2/mutex_m.rb#78
  def synchronize(&block); end

  # source://mutex_m/0.1.2/mutex_m.rb#88
  def try_lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#98
  def unlock; end

  private

  # source://httpclient//lib/httpclient/auth.rb#840
  def calc_cred(req, config); end

  # source://httpclient//lib/httpclient/auth.rb#889
  def create_base_string(config, header, req); end

  # source://httpclient//lib/httpclient/auth.rb#829
  def do_get_config(uri = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/auth.rb#868
  def encode_header(k, v); end

  # source://httpclient//lib/httpclient/auth.rb#872
  def encode_param(params); end

  # source://httpclient//lib/httpclient/auth.rb#861
  def generate_nonce; end

  # source://httpclient//lib/httpclient/auth.rb#880
  def sign(config, header, req); end

  # source://httpclient//lib/httpclient/auth.rb#913
  def sign_hmac_sha1(config, base_string); end

  class << self
    # source://httpclient//lib/httpclient/auth.rb#736
    def escape(str); end
  end
end

# source://httpclient//lib/httpclient/auth.rb#685
class HTTPClient::OAuth::Config
  include ::HTTPClient::Util

  # @return [Config] a new instance of Config
  #
  # source://httpclient//lib/httpclient/auth.rb#707
  def initialize(*args); end

  # Returns the value of attribute callback.
  #
  # source://httpclient//lib/httpclient/auth.rb#696
  def callback; end

  # Sets the attribute callback
  #
  # @param value the value to set the attribute callback to.
  #
  # source://httpclient//lib/httpclient/auth.rb#696
  def callback=(_arg0); end

  # Returns the value of attribute consumer_key.
  #
  # source://httpclient//lib/httpclient/auth.rb#690
  def consumer_key; end

  # Sets the attribute consumer_key
  #
  # @param value the value to set the attribute consumer_key to.
  #
  # source://httpclient//lib/httpclient/auth.rb#690
  def consumer_key=(_arg0); end

  # Returns the value of attribute consumer_secret.
  #
  # source://httpclient//lib/httpclient/auth.rb#691
  def consumer_secret; end

  # Sets the attribute consumer_secret
  #
  # @param value the value to set the attribute consumer_secret to.
  #
  # source://httpclient//lib/httpclient/auth.rb#691
  def consumer_secret=(_arg0); end

  # Returns the value of attribute debug_nonce.
  #
  # source://httpclient//lib/httpclient/auth.rb#705
  def debug_nonce; end

  # Sets the attribute debug_nonce
  #
  # @param value the value to set the attribute debug_nonce to.
  #
  # source://httpclient//lib/httpclient/auth.rb#705
  def debug_nonce=(_arg0); end

  # Returns the value of attribute debug_timestamp.
  #
  # source://httpclient//lib/httpclient/auth.rb#704
  def debug_timestamp; end

  # Sets the attribute debug_timestamp
  #
  # @param value the value to set the attribute debug_timestamp to.
  #
  # source://httpclient//lib/httpclient/auth.rb#704
  def debug_timestamp=(_arg0); end

  # Returns the value of attribute http_method.
  #
  # source://httpclient//lib/httpclient/auth.rb#688
  def http_method; end

  # Sets the attribute http_method
  #
  # @param value the value to set the attribute http_method to.
  #
  # source://httpclient//lib/httpclient/auth.rb#688
  def http_method=(_arg0); end

  # Returns the value of attribute realm.
  #
  # source://httpclient//lib/httpclient/auth.rb#689
  def realm; end

  # Sets the attribute realm
  #
  # @param value the value to set the attribute realm to.
  #
  # source://httpclient//lib/httpclient/auth.rb#689
  def realm=(_arg0); end

  # Returns the value of attribute secret.
  #
  # source://httpclient//lib/httpclient/auth.rb#693
  def secret; end

  # Sets the attribute secret
  #
  # @param value the value to set the attribute secret to.
  #
  # source://httpclient//lib/httpclient/auth.rb#693
  def secret=(_arg0); end

  # for OAuth Session 1.0 (draft)
  #
  # source://httpclient//lib/httpclient/auth.rb#700
  def session_handle; end

  # for OAuth Session 1.0 (draft)
  #
  # source://httpclient//lib/httpclient/auth.rb#700
  def session_handle=(_arg0); end

  # Returns the value of attribute signature_handler.
  #
  # source://httpclient//lib/httpclient/auth.rb#702
  def signature_handler; end

  # Returns the value of attribute signature_method.
  #
  # source://httpclient//lib/httpclient/auth.rb#694
  def signature_method; end

  # Sets the attribute signature_method
  #
  # @param value the value to set the attribute signature_method to.
  #
  # source://httpclient//lib/httpclient/auth.rb#694
  def signature_method=(_arg0); end

  # Returns the value of attribute token.
  #
  # source://httpclient//lib/httpclient/auth.rb#692
  def token; end

  # Sets the attribute token
  #
  # @param value the value to set the attribute token to.
  #
  # source://httpclient//lib/httpclient/auth.rb#692
  def token=(_arg0); end

  # Returns the value of attribute verifier.
  #
  # source://httpclient//lib/httpclient/auth.rb#697
  def verifier; end

  # Sets the attribute verifier
  #
  # @param value the value to set the attribute verifier to.
  #
  # source://httpclient//lib/httpclient/auth.rb#697
  def verifier=(_arg0); end

  # Returns the value of attribute version.
  #
  # source://httpclient//lib/httpclient/auth.rb#695
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://httpclient//lib/httpclient/auth.rb#695
  def version=(_arg0); end
end

# Default header for PROPFIND request.
#
# source://httpclient//lib/httpclient.rb#376
HTTPClient::PROPFIND_DEFAULT_EXTHEADER = T.let(T.unsafe(nil), Hash)

# Authentication filter for handling authentication negotiation between
# Proxy server.  Parses 'Proxy-Authentication' header in response and
# generates 'Proxy-Authorization' header in request.
#
# Authentication filter is implemented using request filter of HTTPClient.
# It traps HTTP response header and maintains authentication state, and
# traps HTTP request header for inserting necessary authentication header.
#
# ProxyAuth has sub filters (BasicAuth, NegotiateAuth, and SSPINegotiateAuth)
# and delegates some operations to it.
# NegotiateAuth requires 'ruby/ntlm' module.
# SSPINegotiateAuth requires 'win32/sspi' module.
#
# source://httpclient//lib/httpclient/auth.rb#151
class HTTPClient::ProxyAuth < ::HTTPClient::AuthFilterBase
  # Creates new ProxyAuth.
  #
  # @return [ProxyAuth] a new instance of ProxyAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#158
  def initialize; end

  # Returns the value of attribute basic_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#152
  def basic_auth; end

  # Returns the value of attribute digest_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#153
  def digest_auth; end

  # Filter API implementation.  Traps HTTP request and insert
  # 'Proxy-Authorization' header if needed.
  #
  # source://httpclient//lib/httpclient/auth.rb#185
  def filter_request(req); end

  # Filter API implementation.  Traps HTTP response and parses
  # 'Proxy-Authenticate' header.
  #
  # source://httpclient//lib/httpclient/auth.rb#204
  def filter_response(req, res); end

  # Returns the value of attribute negotiate_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#154
  def negotiate_auth; end

  # Resets challenge state.  See sub filters for more details.
  #
  # source://httpclient//lib/httpclient/auth.rb#169
  def reset_challenge; end

  # Set authentication credential.  See sub filters for more details.
  #
  # source://httpclient//lib/httpclient/auth.rb#176
  def set_auth(user, passwd); end

  # Returns the value of attribute sspi_negotiate_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#155
  def sspi_negotiate_auth; end
end

# source://httpclient//lib/httpclient/auth.rb#306
class HTTPClient::ProxyBasicAuth < ::HTTPClient::BasicAuth
  # Challenge handler: remember URL for response.
  #
  # source://httpclient//lib/httpclient/auth.rb#321
  def challenge(uri, param_str = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/auth.rb#313
  def get(req); end

  # source://httpclient//lib/httpclient/auth.rb#307
  def set(uri, user, passwd); end
end

# Authentication filter for handling DigestAuth negotiation.
# Ignores uri argument. Used in ProxyAuth.
#
# source://httpclient//lib/httpclient/auth.rb#459
class HTTPClient::ProxyDigestAuth < ::HTTPClient::DigestAuth
  # source://httpclient//lib/httpclient/auth.rb#487
  def challenge(uri, param_str); end

  # overrides DigestAuth#get. Uses default user name and password
  # regardless of target uri if the proxy has required authentication
  # before
  #
  # source://httpclient//lib/httpclient/auth.rb#471
  def get(req); end

  # source://httpclient//lib/httpclient/auth.rb#481
  def reset_challenge; end

  # overrides DigestAuth#set. sets default user name and password. uri is not used.
  #
  # source://httpclient//lib/httpclient/auth.rb#462
  def set(uri, user, passwd); end
end

# source://httpclient//lib/httpclient.rb#242
HTTPClient::RUBY_VERSION_STRING = T.let(T.unsafe(nil), String)

# Raised for indicating a response receiving timeout error.
# You can configure response receiving timeout via
# HTTPClient#receive_timeout=.
#
# source://httpclient//lib/httpclient.rb#280
class HTTPClient::ReceiveTimeoutError < ::HTTPClient::TimeoutError; end

# source://httpclient//lib/httpclient.rb#973
class HTTPClient::RetryableResponse < ::StandardError
  # @return [RetryableResponse] a new instance of RetryableResponse
  #
  # source://httpclient//lib/httpclient.rb#976
  def initialize(res = T.unsafe(nil)); end

  # Returns the value of attribute res.
  #
  # source://httpclient//lib/httpclient.rb#974
  def res; end
end

# Represents SSL configuration for HTTPClient instance.
# The implementation depends on OpenSSL.
#
# == Trust Anchor Control
#
# SSLConfig loads 'httpclient/cacert.pem' as a trust anchor
# (trusted certificate(s)) with add_trust_ca in initialization time.
# This means that HTTPClient instance trusts some CA certificates by default,
# like Web browsers.  'httpclient/cacert.pem' is downloaded from curl web
# site by the author and included in released package.
#
# On JRuby, HTTPClient uses Java runtime's trusted CA certificates, not
# cacert.pem by default. You can load cacert.pem by calling
# SSLConfig#load_trust_ca manually like:
#
#   HTTPClient.new { self.ssl_config.load_trust_ca }.get("https://...")
#
# You may want to change trust anchor by yourself.  Call clear_cert_store
# then add_trust_ca for that purpose.
#
# source://httpclient//lib/httpclient/ssl_config.rb#37
class HTTPClient::SSLConfig
  include ::HTTPClient::Util
  include ::OpenSSL

  # Creates a SSLConfig.
  #
  # @return [SSLConfig] a new instance of SSLConfig
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#145
  def initialize(client); end

  # Adds CRL for verification.
  # crl:: a OpenSSL::X509::CRL or a filename of a PEM/DER formatted
  #       OpenSSL::X509::CRL.
  #
  # On JRuby, instead of setting CRL by yourself you can set following
  # options to let HTTPClient to perform revocation check with CRL and OCSP:
  # -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
  # ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
  #
  # Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#268
  def add_crl(crl); end

  # Sets trust anchor certificate(s) for verification.
  # trust_ca_file_or_hashed_dir:: a filename of a PEM/DER formatted
  #                               OpenSSL::X509::Certificate or
  #                               a 'c-rehash'eddirectory name which stores
  #                               trusted certificate files.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#231
  def add_trust_ca(trust_ca_file_or_hashed_dir); end

  # source://httpclient//lib/httpclient/ssl_config.rb#241
  def add_trust_ca_to_store(cert_store, trust_ca_file_or_hashed_dir); end

  # OpenSSL::X509::X509::Store used for verification.  You can reset the
  # store with clear_cert_store and set the new store with cert_store=.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#135
  def cert_store; end

  # Sets new certificate store (OpenSSL::X509::Store).
  # don't use if you don't know what it is.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#215
  def cert_store=(cert_store); end

  # Returns the value of attribute cert_store_crl_items.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#142
  def cert_store_crl_items; end

  # These array keeps original files/dirs that was added to @cert_store
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#141
  def cert_store_items; end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def ciphers; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def ciphers=(rhs); end

  # Drops current certificate store (OpenSSL::X509::Store) for SSL and create
  # new one for the next session.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#204
  def clear_cert_store; end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def client_ca; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def client_ca=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def client_cert; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def client_cert=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def client_key; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def client_key=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def client_key_pass; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def client_key_pass=(rhs); end

  # Default callback for verification: only dumps error.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#338
  def default_verify_callback(is_ok, ctx); end

  # Loads default trust anchors.
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#251
  def load_trust_ca; end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def options; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def options=(rhs); end

  # post connection check proc for ruby < 1.8.5.
  # this definition must match with the one in ext/openssl/lib/openssl/ssl.rb
  #
  # @raise [SSL::SSLError]
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#310
  def post_connection_check(peer_cert, hostname); end

  # Sample callback method:  CAUTION: does not check CRL/ARL.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#358
  def sample_verify_callback(is_ok, ctx); end

  # Sets certificate and private key for SSL client authentication.
  # cert_file:: must be a filename of PEM/DER formatted file.
  # key_file:: must be a filename of PEM/DER formatted file.  Key must be an
  #            RSA key.  If you want to use other PKey algorithm,
  #            use client_key=.
  #
  # Calling this method resets all existing sessions if value is changed.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#175
  def set_client_cert_file(cert_file, key_file, pass = T.unsafe(nil)); end

  # interfaces for SSLSocket.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#284
  def set_context(ctx); end

  # Adds CRL for verification.
  # crl:: a OpenSSL::X509::CRL or a filename of a PEM/DER formatted
  #       OpenSSL::X509::CRL.
  #
  # On JRuby, instead of setting CRL by yourself you can set following
  # options to let HTTPClient to perform revocation check with CRL and OCSP:
  # -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
  # ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
  #
  # Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#268
  def set_crl(crl); end

  # Sets OpenSSL's default trusted CA certificates.  Generally, OpenSSL is
  # configured to use OS's trusted CA certificates located at
  # /etc/pki/certs or /etc/ssl/certs.  Unfortunately OpenSSL's Windows build
  # does not work with Windows Certificate Storage.
  #
  # On Windows or when you build OpenSSL manually, you can set the
  # CA certificates directory by SSL_CERT_DIR env variable at runtime.
  #
  #   SSL_CERT_DIR=/etc/ssl/certs ruby -rhttpclient -e "..."
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#193
  def set_default_paths; end

  # Sets trust anchor certificate(s) for verification.
  # trust_ca_file_or_hashed_dir:: a filename of a PEM/DER formatted
  #                               OpenSSL::X509::Certificate or
  #                               a 'c-rehash'eddirectory name which stores
  #                               trusted certificate files.
  #
  # Calling this method resets all existing sessions.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#231
  def set_trust_ca(trust_ca_file_or_hashed_dir); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def ssl_version; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def ssl_version=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def timeout; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def timeout=(rhs); end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#279
  def verify?; end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def verify_callback; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def verify_callback=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def verify_depth; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def verify_depth=(rhs); end

  # source://httpclient//lib/httpclient/ssl_config.rb#74
  def verify_mode; end

  # source://httpclient//lib/httpclient/ssl_config.rb#77
  def verify_mode=(rhs); end

  private

  # source://httpclient//lib/httpclient/ssl_config.rb#411
  def change_notify; end

  # Use 2048 bit certs trust anchor
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#417
  def load_cacerts(cert_store); end

  class << self
    private

    # source://httpclient//lib/httpclient/ssl_config.rb#71
    def attr_config(symbol); end
  end
end

# OpenSSL >1.0.0 default
#
# source://httpclient//lib/httpclient/ssl_config.rb#88
HTTPClient::SSLConfig::CIPHERS_DEFAULT = T.let(T.unsafe(nil), String)

# source://httpclient//lib/httpclient/ssl_config.rb#13
HTTPClient::SSLEnabled = T.let(T.unsafe(nil), TrueClass)

# Wraps up OpenSSL::SSL::SSLSocket and offers debugging features.
#
# source://httpclient//lib/httpclient/ssl_socket.rb#15
class HTTPClient::SSLSocket
  # @return [SSLSocket] a new instance of SSLSocket
  #
  # source://httpclient//lib/httpclient/ssl_socket.rb#33
  def initialize(socket, dest, config, opts = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#79
  def <<(str); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#48
  def close; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/ssl_socket.rb#53
  def closed?; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/ssl_socket.rb#57
  def eof?; end

  # source://httpclient//lib/httpclient/ssl_socket.rb#85
  def flush; end

  # source://httpclient//lib/httpclient/ssl_socket.rb#61
  def gets(rs); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#44
  def peer_cert; end

  # source://httpclient//lib/httpclient/ssl_socket.rb#67
  def read(size, buf = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#73
  def readpartial(size, buf = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#89
  def sync; end

  # source://httpclient//lib/httpclient/ssl_socket.rb#93
  def sync=(sync); end

  private

  # source://httpclient//lib/httpclient/ssl_socket.rb#128
  def check_mask(value, mask); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#132
  def create_openssl_socket(socket); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#145
  def debug(str); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#113
  def post_connection_check(hostname); end

  # source://httpclient//lib/httpclient/ssl_socket.rb#99
  def ssl_connect(hostname = T.unsafe(nil)); end

  class << self
    # source://httpclient//lib/httpclient/ssl_socket.rb#16
    def create_socket(session); end
  end
end

# source://httpclient//lib/httpclient/auth.rb#17
HTTPClient::SSPIEnabled = T.let(T.unsafe(nil), FalseClass)

# Authentication filter for handling Negotiate/NTLM negotiation.
# Used in ProxyAuth.
#
# SSPINegotiateAuth depends on 'win32/sspi' module.
#
# source://httpclient//lib/httpclient/auth.rb#596
class HTTPClient::SSPINegotiateAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new SSPINegotiateAuth filter.
  #
  # @return [SSPINegotiateAuth] a new instance of SSPINegotiateAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#600
  def initialize; end

  # Challenge handler: remember URL and challenge token for response.
  #
  # source://httpclient//lib/httpclient/auth.rb#655
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # See win32/sspi for negotiation state transition.
  #
  # source://httpclient//lib/httpclient/auth.rb#618
  def get(req); end

  # source://mutex_m/0.1.2/mutex_m.rb#93
  def lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#83
  def locked?; end

  # Set authentication credential.
  # NOT SUPPORTED: username and necessary data is retrieved by win32/sspi.
  # See win32/sspi for more details.
  #
  # source://httpclient//lib/httpclient/auth.rb#607
  def set(*args); end

  # Check always (not effective but it works)
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/auth.rb#612
  def set?; end

  # source://mutex_m/0.1.2/mutex_m.rb#78
  def synchronize(&block); end

  # source://mutex_m/0.1.2/mutex_m.rb#88
  def try_lock; end

  # source://mutex_m/0.1.2/mutex_m.rb#98
  def unlock; end
end

# Raised for indicating a request sending timeout error.
# You can configure request sending timeout via HTTPClient#send_timeout=.
#
# source://httpclient//lib/httpclient.rb#274
class HTTPClient::SendTimeoutError < ::HTTPClient::TimeoutError; end

# Deprecated.  just for backward compatibility
#
# source://httpclient//lib/httpclient/session.rb#434
class HTTPClient::Session
  include ::HTTPClient::Timeout
  include ::HTTPClient::Util

  # @return [Session] a new instance of Session
  #
  # source://httpclient//lib/httpclient/session.rb#468
  def initialize(client, dest, agent_name, from); end

  # source://httpclient//lib/httpclient/session.rb#543
  def close; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#552
  def closed?; end

  # Returns the value of attribute connect_retry.
  #
  # source://httpclient//lib/httpclient/session.rb#452
  def connect_retry; end

  # Sets the attribute connect_retry
  #
  # @param value the value to set the attribute connect_retry to.
  #
  # source://httpclient//lib/httpclient/session.rb#452
  def connect_retry=(_arg0); end

  # source://httpclient//lib/httpclient/session.rb#644
  def connect_ssl_proxy(socket, uri); end

  # Returns the value of attribute connect_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#451
  def connect_timeout; end

  # Sets the attribute connect_timeout
  #
  # @param value the value to set the attribute connect_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#451
  def connect_timeout=(_arg0); end

  # source://httpclient//lib/httpclient/session.rb#630
  def create_loopback_socket(host, port, str); end

  # source://httpclient//lib/httpclient/session.rb#605
  def create_socket(host, port); end

  # Device for dumping log for debugging
  #
  # source://httpclient//lib/httpclient/session.rb#449
  def debug_dev; end

  # Device for dumping log for debugging
  #
  # source://httpclient//lib/httpclient/session.rb#449
  def debug_dev=(_arg0); end

  # Destination site
  #
  # source://httpclient//lib/httpclient/session.rb#439
  def dest; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#569
  def eof?; end

  # source://httpclient//lib/httpclient/session.rb#577
  def get_body(&block); end

  # source://httpclient//lib/httpclient/session.rb#556
  def get_header; end

  # Returns the value of attribute last_used.
  #
  # source://httpclient//lib/httpclient/session.rb#466
  def last_used; end

  # Returns the value of attribute protocol_retry_count.
  #
  # source://httpclient//lib/httpclient/session.rb#456
  def protocol_retry_count; end

  # Sets the attribute protocol_retry_count
  #
  # @param value the value to set the attribute protocol_retry_count to.
  #
  # source://httpclient//lib/httpclient/session.rb#456
  def protocol_retry_count=(_arg0); end

  # Proxy site
  #
  # source://httpclient//lib/httpclient/session.rb#441
  def proxy; end

  # Proxy site
  #
  # source://httpclient//lib/httpclient/session.rb#441
  def proxy=(_arg0); end

  # Send a request to the server
  #
  # source://httpclient//lib/httpclient/session.rb#510
  def query(req); end

  # Returns the value of attribute read_block_size.
  #
  # source://httpclient//lib/httpclient/session.rb#455
  def read_block_size; end

  # Sets the attribute read_block_size
  #
  # @param value the value to set the attribute read_block_size to.
  #
  # source://httpclient//lib/httpclient/session.rb#455
  def read_block_size=(_arg0); end

  # Returns the value of attribute receive_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#454
  def receive_timeout; end

  # Sets the attribute receive_timeout
  #
  # @param value the value to set the attribute receive_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#454
  def receive_timeout=(_arg0); end

  # Requested protocol version
  #
  # source://httpclient//lib/httpclient/session.rb#447
  def requested_version; end

  # Requested protocol version
  #
  # source://httpclient//lib/httpclient/session.rb#447
  def requested_version=(_arg0); end

  # Returns the value of attribute send_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#453
  def send_timeout; end

  # Sets the attribute send_timeout
  #
  # @param value the value to set the attribute send_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#453
  def send_timeout=(_arg0); end

  # Returns the value of attribute socket_local.
  #
  # source://httpclient//lib/httpclient/session.rb#459
  def socket_local; end

  # Sets the attribute socket_local
  #
  # @param value the value to set the attribute socket_local to.
  #
  # source://httpclient//lib/httpclient/session.rb#459
  def socket_local=(_arg0); end

  # Boolean value for Socket#sync
  #
  # source://httpclient//lib/httpclient/session.rb#443
  def socket_sync; end

  # Boolean value for Socket#sync
  #
  # source://httpclient//lib/httpclient/session.rb#443
  def socket_sync=(_arg0); end

  # Returns the value of attribute ssl_config.
  #
  # source://httpclient//lib/httpclient/session.rb#461
  def ssl_config; end

  # Sets the attribute ssl_config
  #
  # @param value the value to set the attribute ssl_config to.
  #
  # source://httpclient//lib/httpclient/session.rb#461
  def ssl_config=(_arg0); end

  # Returns the value of attribute ssl_peer_cert.
  #
  # source://httpclient//lib/httpclient/session.rb#462
  def ssl_peer_cert; end

  # Returns the value of attribute strict_response_size_check.
  #
  # source://httpclient//lib/httpclient/session.rb#458
  def strict_response_size_check; end

  # Sets the attribute strict_response_size_check
  #
  # @param value the value to set the attribute strict_response_size_check to.
  #
  # source://httpclient//lib/httpclient/session.rb#458
  def strict_response_size_check=(_arg0); end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  #
  # source://httpclient//lib/httpclient/session.rb#445
  def tcp_keepalive; end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  #
  # source://httpclient//lib/httpclient/session.rb#445
  def tcp_keepalive=(_arg0); end

  # Returns the value of attribute test_loopback_http_response.
  #
  # source://httpclient//lib/httpclient/session.rb#463
  def test_loopback_http_response; end

  # Sets the attribute test_loopback_http_response
  #
  # @param value the value to set the attribute test_loopback_http_response to.
  #
  # source://httpclient//lib/httpclient/session.rb#463
  def test_loopback_http_response=(_arg0); end

  # Returns the value of attribute transparent_gzip_decompression.
  #
  # source://httpclient//lib/httpclient/session.rb#465
  def transparent_gzip_decompression; end

  # Sets the attribute transparent_gzip_decompression
  #
  # @param value the value to set the attribute transparent_gzip_decompression to.
  #
  # source://httpclient//lib/httpclient/session.rb#465
  def transparent_gzip_decompression=(_arg0); end

  private

  # Connect to the server
  #
  # source://httpclient//lib/httpclient/session.rb#744
  def connect; end

  # source://httpclient//lib/httpclient/session.rb#700
  def content_inflater_block(content_encoding, block); end

  # source://httpclient//lib/httpclient/session.rb#952
  def empty_bin_str; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#848
  def no_message_body?(status); end

  # source://httpclient//lib/httpclient/session.rb#853
  def parse_content_header(key, value); end

  # source://httpclient//lib/httpclient/session.rb#800
  def parse_header(socket); end

  # source://httpclient//lib/httpclient/session.rb#903
  def read_body_chunked(&block); end

  # source://httpclient//lib/httpclient/session.rb#875
  def read_body_length(&block); end

  # source://httpclient//lib/httpclient/session.rb#927
  def read_body_rest; end

  # Read status block.
  #
  # source://httpclient//lib/httpclient/session.rb#779
  def read_header; end

  # source://httpclient//lib/httpclient/session.rb#720
  def set_header(req); end
end

# source://httpclient//lib/httpclient.rb#285
HTTPClient::Session::BadResponse = HTTPClient::BadResponseError

# This inflater allows deflate compression with/without zlib header
#
# source://httpclient//lib/httpclient/session.rb#672
class HTTPClient::Session::LenientInflater
  # @return [LenientInflater] a new instance of LenientInflater
  #
  # source://httpclient//lib/httpclient/session.rb#673
  def initialize; end

  # source://httpclient//lib/httpclient/session.rb#678
  def inflate(body); end

  private

  # source://httpclient//lib/httpclient/session.rb#688
  def first_inflate(body); end
end

# source://httpclient//lib/httpclient/session.rb#902
HTTPClient::Session::RS = T.let(T.unsafe(nil), String)

# source://httpclient//lib/httpclient/session.rb#799
HTTPClient::Session::StatusParseRegexp = T.let(T.unsafe(nil), Regexp)

# Manages sessions for a HTTPClient instance.
#
# source://httpclient//lib/httpclient/session.rb#94
class HTTPClient::SessionManager
  # @return [SessionManager] a new instance of SessionManager
  #
  # source://httpclient//lib/httpclient/session.rb#132
  def initialize(client); end

  # Name of this client.  Used for 'User-Agent' header in HTTP request.
  #
  # source://httpclient//lib/httpclient/session.rb#96
  def agent_name; end

  # Name of this client.  Used for 'User-Agent' header in HTTP request.
  #
  # source://httpclient//lib/httpclient/session.rb#96
  def agent_name=(_arg0); end

  # Chunk size for chunked request
  #
  # source://httpclient//lib/httpclient/session.rb#103
  def chunk_size; end

  # Chunk size for chunked request
  #
  # source://httpclient//lib/httpclient/session.rb#103
  def chunk_size=(_arg0); end

  # Maximum retry count.  0 for infinite.
  #
  # source://httpclient//lib/httpclient/session.rb#113
  def connect_retry; end

  # Maximum retry count.  0 for infinite.
  #
  # source://httpclient//lib/httpclient/session.rb#113
  def connect_retry=(_arg0); end

  # Returns the value of attribute connect_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#111
  def connect_timeout; end

  # Sets the attribute connect_timeout
  #
  # @param value the value to set the attribute connect_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#111
  def connect_timeout=(_arg0); end

  # Device for dumping log for debugging
  #
  # source://httpclient//lib/httpclient/session.rb#105
  def debug_dev; end

  # Device for dumping log for debugging
  #
  # source://httpclient//lib/httpclient/session.rb#105
  def debug_dev=(_arg0); end

  # Owner of this client.  Used for 'From' header in HTTP request.
  #
  # source://httpclient//lib/httpclient/session.rb#98
  def from; end

  # Owner of this client.  Used for 'From' header in HTTP request.
  #
  # source://httpclient//lib/httpclient/session.rb#98
  def from=(_arg0); end

  # assert: sess.last_used must not be nil
  #
  # source://httpclient//lib/httpclient/session.rb#195
  def keep(sess); end

  # Returns the value of attribute keep_alive_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#116
  def keep_alive_timeout; end

  # Sets the attribute keep_alive_timeout
  #
  # @param value the value to set the attribute keep_alive_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#116
  def keep_alive_timeout=(_arg0); end

  # Returns the value of attribute protocol_retry_count.
  #
  # source://httpclient//lib/httpclient/session.rb#118
  def protocol_retry_count; end

  # Sets the attribute protocol_retry_count
  #
  # @param value the value to set the attribute protocol_retry_count to.
  #
  # source://httpclient//lib/httpclient/session.rb#118
  def protocol_retry_count=(_arg0); end

  # Requested protocol version
  #
  # source://httpclient//lib/httpclient/session.rb#101
  def protocol_version; end

  # Requested protocol version
  #
  # source://httpclient//lib/httpclient/session.rb#101
  def protocol_version=(_arg0); end

  # source://httpclient//lib/httpclient/session.rb#165
  def proxy=(proxy); end

  # source://httpclient//lib/httpclient/session.rb#173
  def query(req, via_proxy); end

  # Returns the value of attribute read_block_size.
  #
  # source://httpclient//lib/httpclient/session.rb#117
  def read_block_size; end

  # Sets the attribute read_block_size
  #
  # @param value the value to set the attribute read_block_size to.
  #
  # source://httpclient//lib/httpclient/session.rb#117
  def read_block_size=(_arg0); end

  # Returns the value of attribute receive_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#115
  def receive_timeout; end

  # Sets the attribute receive_timeout
  #
  # @param value the value to set the attribute receive_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#115
  def receive_timeout=(_arg0); end

  # source://httpclient//lib/httpclient/session.rb#185
  def reset(uri); end

  # source://httpclient//lib/httpclient/session.rb#190
  def reset_all; end

  # Returns the value of attribute send_timeout.
  #
  # source://httpclient//lib/httpclient/session.rb#114
  def send_timeout; end

  # Sets the attribute send_timeout
  #
  # @param value the value to set the attribute send_timeout to.
  #
  # source://httpclient//lib/httpclient/session.rb#114
  def send_timeout=(_arg0); end

  # Local address to bind local side of the socket to
  #
  # source://httpclient//lib/httpclient/session.rb#124
  def socket_local; end

  # Local address to bind local side of the socket to
  #
  # source://httpclient//lib/httpclient/session.rb#124
  def socket_local=(_arg0); end

  # Boolean value for Socket#sync
  #
  # source://httpclient//lib/httpclient/session.rb#107
  def socket_sync; end

  # Boolean value for Socket#sync
  #
  # source://httpclient//lib/httpclient/session.rb#107
  def socket_sync=(_arg0); end

  # Returns the value of attribute ssl_config.
  #
  # source://httpclient//lib/httpclient/session.rb#126
  def ssl_config; end

  # Sets the attribute ssl_config
  #
  # @param value the value to set the attribute ssl_config to.
  #
  # source://httpclient//lib/httpclient/session.rb#126
  def ssl_config=(_arg0); end

  # Raise BadResponseError if response size does not match with Content-Length header in response.
  #
  # source://httpclient//lib/httpclient/session.rb#121
  def strict_response_size_check; end

  # Raise BadResponseError if response size does not match with Content-Length header in response.
  #
  # source://httpclient//lib/httpclient/session.rb#121
  def strict_response_size_check=(_arg0); end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  #
  # source://httpclient//lib/httpclient/session.rb#109
  def tcp_keepalive; end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  #
  # source://httpclient//lib/httpclient/session.rb#109
  def tcp_keepalive=(_arg0); end

  # Returns the value of attribute test_loopback_http_response.
  #
  # source://httpclient//lib/httpclient/session.rb#128
  def test_loopback_http_response; end

  # Returns the value of attribute transparent_gzip_decompression.
  #
  # source://httpclient//lib/httpclient/session.rb#130
  def transparent_gzip_decompression; end

  # Sets the attribute transparent_gzip_decompression
  #
  # @param value the value to set the attribute transparent_gzip_decompression to.
  #
  # source://httpclient//lib/httpclient/session.rb#130
  def transparent_gzip_decompression=(_arg0); end

  private

  # source://httpclient//lib/httpclient/session.rb#298
  def add_cached_session(sess); end

  # This method might not work as you expected...
  #
  # source://httpclient//lib/httpclient/session.rb#251
  def close(dest); end

  # source://httpclient//lib/httpclient/session.rb#239
  def close_all; end

  # source://httpclient//lib/httpclient/session.rb#260
  def get_cached_session(site); end

  # TODO: create PR for webmock's httpclient adapter to use get_session
  # instead of open so that we can remove duplicated Site creation for
  # each session.
  #
  # source://httpclient//lib/httpclient/session.rb#204
  def get_session(req, via_proxy = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/session.rb#217
  def open(uri, via_proxy = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/session.rb#281
  def scrub_cached_session(now); end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#294
  def valid_session?(sess, now); end
end

# Represents a Site: protocol scheme, host String and port Number.
#
# source://httpclient//lib/httpclient/session.rb#35
class HTTPClient::Site
  # Creates a new Site based on the given URI.
  #
  # @return [Site] a new instance of Site
  #
  # source://httpclient//lib/httpclient/session.rb#45
  def initialize(uri = T.unsafe(nil)); end

  # Returns true is scheme, host and port are '=='
  #
  # source://httpclient//lib/httpclient/session.rb#63
  def ==(rhs); end

  # Returns address String.
  #
  # source://httpclient//lib/httpclient/session.rb#58
  def addr; end

  # Same as ==.
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#68
  def eql?(rhs); end

  # source://httpclient//lib/httpclient/session.rb#72
  def hash; end

  # Host String.
  #
  # source://httpclient//lib/httpclient/session.rb#39
  def host; end

  # Host String.
  #
  # source://httpclient//lib/httpclient/session.rb#39
  def host=(_arg0); end

  # Host String.
  #
  # source://httpclient//lib/httpclient/session.rb#39
  def hostname; end

  # source://httpclient//lib/httpclient/session.rb#85
  def inspect; end

  # Returns true if scheme, host and port of the given URI matches with this.
  #
  # source://httpclient//lib/httpclient/session.rb#81
  def match(uri); end

  # Port number.
  #
  # source://httpclient//lib/httpclient/session.rb#42
  def port; end

  # Port number.
  #
  # source://httpclient//lib/httpclient/session.rb#42
  def port=(_arg0); end

  # Protocol scheme.
  #
  # source://httpclient//lib/httpclient/session.rb#37
  def scheme; end

  # Protocol scheme.
  #
  # source://httpclient//lib/httpclient/session.rb#37
  def scheme=(_arg0); end

  # source://httpclient//lib/httpclient/session.rb#76
  def to_s; end
end

# source://httpclient//lib/httpclient/session.rb#89
HTTPClient::Site::EMPTY = T.let(T.unsafe(nil), HTTPClient::Site)

# Wraps up a Socket for method interception.
#
# source://httpclient//lib/httpclient/session.rb#307
module HTTPClient::SocketWrap
  # source://httpclient//lib/httpclient/session.rb#308
  def initialize(socket, *args); end

  # source://httpclient//lib/httpclient/session.rb#342
  def <<(str); end

  # source://httpclient//lib/httpclient/session.rb#313
  def close; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#317
  def closed?; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/session.rb#321
  def eof?; end

  # source://httpclient//lib/httpclient/session.rb#346
  def flush; end

  # source://httpclient//lib/httpclient/session.rb#325
  def gets(rs); end

  # source://httpclient//lib/httpclient/session.rb#329
  def read(size, buf = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/session.rb#333
  def readpartial(size, buf = T.unsafe(nil)); end

  # source://httpclient//lib/httpclient/session.rb#350
  def sync; end

  # source://httpclient//lib/httpclient/session.rb#354
  def sync=(sync); end
end

# source://httpclient//lib/httpclient/timeout.rb#123
module HTTPClient::Timeout; end

# Raised for indicating a timeout error.
#
# source://httpclient//lib/httpclient.rb#264
class HTTPClient::TimeoutError < ::RuntimeError; end

# A module for common function.
#
# source://httpclient//lib/httpclient/util.rb#53
module HTTPClient::Util
  # Keyword argument to hash helper.
  # args:: given arguments.
  # *field:: a list of arguments to be extracted.
  #
  # Returns hash which has defined keys. When a Hash given, returns it
  # including undefined keys. When an Array given, returns a Hash which only
  # includes defined keys.
  #
  # source://httpclient//lib/httpclient/util.rb#132
  def argument_to_hash(args, *field); end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/util.rb#216
  def http?(uri); end

  # Checks if the given URI is https.
  #
  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/util.rb#212
  def https?(uri); end

  # Keyword argument helper.
  # args:: given arguments.
  # *field:: a list of arguments to be extracted.
  #
  # You can extract 3 arguments (a, b, c) with:
  #
  #   include Util
  #   def my_method(*args)
  #     a, b, c = keyword_argument(args, :a, :b, :c)
  #     ...
  #   end
  #   my_method(1, 2, 3)
  #   my_method(:b => 2, :a = 1)
  #
  # instead of;
  #
  #   def my_method(a, b, c)
  #     ...
  #   end
  #
  # source://httpclient//lib/httpclient/util.rb#115
  def keyword_argument(args, *field); end

  # source://httpclient//lib/httpclient/util.rb#205
  def warning(message); end

  private

  # Finds a value of a Hash.
  #
  # source://httpclient//lib/httpclient/util.rb#183
  def hash_find_value(hash, &block); end

  # Try to require a feature and returns true/false if loaded
  #
  # It returns 'true' for the second require in contrast of the standard
  # require returns false if the feature is already loaded.
  #
  # source://httpclient//lib/httpclient/util.rb#193
  def try_require(feature); end

  # Returns parent directory URI of the given URI.
  #
  # source://httpclient//lib/httpclient/util.rb#175
  def uri_dirname(uri); end

  # Returns true if the given 2 URIs have a part_of relationship.
  # * the same scheme
  # * the same host String (no host resolution or IP-addr conversion)
  # * the same port number
  # * target URI's path starts with base URI's path.
  #
  # source://httpclient//lib/httpclient/util.rb#166
  def uri_part_of(uri, part); end

  # Gets an URI instance.
  #
  # source://httpclient//lib/httpclient/util.rb#148
  def urify(uri); end

  class << self
    # Finds a value of a Hash.
    #
    # source://httpclient//lib/httpclient/util.rb#183
    def hash_find_value(hash, &block); end

    # Try to require a feature and returns true/false if loaded
    #
    # It returns 'true' for the second require in contrast of the standard
    # require returns false if the feature is already loaded.
    #
    # source://httpclient//lib/httpclient/util.rb#193
    def try_require(feature); end

    # Returns parent directory URI of the given URI.
    #
    # source://httpclient//lib/httpclient/util.rb#175
    def uri_dirname(uri); end

    # Returns true if the given 2 URIs have a part_of relationship.
    # * the same scheme
    # * the same host String (no host resolution or IP-addr conversion)
    # * the same port number
    # * target URI's path starts with base URI's path.
    #
    # source://httpclient//lib/httpclient/util.rb#166
    def uri_part_of(uri, part); end

    # Gets an URI instance.
    #
    # source://httpclient//lib/httpclient/util.rb#148
    def urify(uri); end
  end
end

# source://httpclient//lib/httpclient/util.rb#90
HTTPClient::Util::AddressableEnabled = T.let(T.unsafe(nil), TrueClass)

# source://httpclient//lib/httpclient/util.rb#63
class HTTPClient::Util::AddressableURI < ::Addressable::URI
  # source://httpclient//lib/httpclient/util.rb#65
  def authority; end

  # source://httpclient//lib/httpclient/util.rb#85
  def hostname; end

  # source://httpclient//lib/httpclient/util.rb#80
  def port; end
end

# source://httpclient//lib/httpclient/version.rb#2
HTTPClient::VERSION = T.let(T.unsafe(nil), String)

# Authentication filter for handling authentication negotiation between
# Web server.  Parses 'WWW-Authentication' header in response and
# generates 'Authorization' header in request.
#
# Authentication filter is implemented using request filter of HTTPClient.
# It traps HTTP response header and maintains authentication state, and
# traps HTTP request header for inserting necessary authentication header.
#
# WWWAuth has sub filters (BasicAuth, DigestAuth, NegotiateAuth and
# SSPINegotiateAuth) and delegates some operations to it.
# NegotiateAuth requires 'ruby/ntlm' module (rubyntlm gem).
# SSPINegotiateAuth requires 'win32/sspi' module (rubysspi gem).
#
# source://httpclient//lib/httpclient/auth.rb#58
class HTTPClient::WWWAuth < ::HTTPClient::AuthFilterBase
  # Creates new WWWAuth.
  #
  # @return [WWWAuth] a new instance of WWWAuth
  #
  # source://httpclient//lib/httpclient/auth.rb#66
  def initialize; end

  # Returns the value of attribute basic_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#59
  def basic_auth; end

  # Returns the value of attribute digest_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#60
  def digest_auth; end

  # Filter API implementation.  Traps HTTP request and insert
  # 'Authorization' header if needed.
  #
  # source://httpclient//lib/httpclient/auth.rb#94
  def filter_request(req); end

  # Filter API implementation.  Traps HTTP response and parses
  # 'WWW-Authenticate' header.
  #
  # This remembers the challenges for all authentication methods
  # available to the client. On the subsequent retry of the request,
  # filter_request will select the strongest method.
  #
  # source://httpclient//lib/httpclient/auth.rb#117
  def filter_response(req, res); end

  # Returns the value of attribute negotiate_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#61
  def negotiate_auth; end

  # Returns the value of attribute oauth.
  #
  # source://httpclient//lib/httpclient/auth.rb#63
  def oauth; end

  # Resets challenge state.  See sub filters for more details.
  #
  # source://httpclient//lib/httpclient/auth.rb#78
  def reset_challenge; end

  # Set authentication credential.  See sub filters for more details.
  #
  # source://httpclient//lib/httpclient/auth.rb#85
  def set_auth(uri, user, passwd); end

  # Returns the value of attribute sspi_negotiate_auth.
  #
  # source://httpclient//lib/httpclient/auth.rb#62
  def sspi_negotiate_auth; end
end

# source://httpclient//lib/httpclient/cookie.rb#89
class HTTPClient::WebAgentSaver < ::HTTP::CookieJar::AbstractSaver
  # source://httpclient//lib/httpclient/cookie.rb#91
  def default_options; end

  # source://httpclient//lib/httpclient/cookie.rb#104
  def load(io, jar); end

  # source://httpclient//lib/httpclient/cookie.rb#96
  def save(io, jar); end

  private

  # source://httpclient//lib/httpclient/cookie.rb#112
  def cookie_to_record(cookie); end

  # source://httpclient//lib/httpclient/cookie.rb#124
  def parse_record(line); end

  class << self
    # source://httpclient//lib/httpclient/cookie.rb#157
    def flag(cookie); end

    # source://httpclient//lib/httpclient/cookie.rb#167
    def set_flag(cookie, flag); end
  end
end

# source://httpclient//lib/httpclient/cookie.rb#153
HTTPClient::WebAgentSaver::DOMAIN = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/cookie.rb#155
HTTPClient::WebAgentSaver::HTTP_ONLY = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/cookie.rb#154
HTTPClient::WebAgentSaver::PATH = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/cookie.rb#152
HTTPClient::WebAgentSaver::SECURE = T.let(T.unsafe(nil), Integer)

# source://httpclient//lib/httpclient/cookie.rb#151
HTTPClient::WebAgentSaver::USE = T.let(T.unsafe(nil), Integer)

# JSONClient auto-converts Hash <-> JSON in request and response.
# * For POST or PUT request, convert Hash body to JSON String with 'application/json; charset=utf-8' header.
# * For response, convert JSON String to Hash when content-type is '(application|text)/(x-)?json'
#
# source://httpclient//lib/jsonclient.rb#7
class JSONClient < ::HTTPClient
  # @return [JSONClient] a new instance of JSONClient
  #
  # source://httpclient//lib/jsonclient.rb#14
  def initialize(*args); end

  # Returns the value of attribute content_type_json_request.
  #
  # source://httpclient//lib/jsonclient.rb#11
  def content_type_json_request; end

  # Returns the value of attribute content_type_json_response_regex.
  #
  # source://httpclient//lib/jsonclient.rb#12
  def content_type_json_response_regex; end

  # source://httpclient//lib/jsonclient.rb#20
  def post(uri, *args, &block); end

  # source://httpclient//lib/jsonclient.rb#24
  def put(uri, *args, &block); end

  # source://httpclient//lib/jsonclient.rb#28
  def request(method, uri, *args, &block); end

  private

  # source://httpclient//lib/jsonclient.rb#38
  def argument_to_hash_for_json(args); end

  # source://httpclient//lib/jsonclient.rb#47
  def json_header(header); end

  # source://httpclient//lib/jsonclient.rb#57
  def wrap_json_response(original); end
end

# source://httpclient//lib/jsonclient.rb#9
JSONClient::CONTENT_TYPE_JSON = T.let(T.unsafe(nil), String)

# source://httpclient//lib/jsonclient.rb#8
JSONClient::CONTENT_TYPE_JSON_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpclient//lib/httpclient/ssl_config.rb#44
class OpenSSL::X509::Store
  # source://httpclient//lib/httpclient/ssl_config.rb#51
  def initialize(*args); end

  # Returns the value of attribute _httpclient_cert_store_items.
  #
  # source://httpclient//lib/httpclient/ssl_config.rb#45
  def _httpclient_cert_store_items; end

  # source://httpclient//lib/httpclient/ssl_config.rb#58
  def add_cert(cert); end

  # source://httpclient//lib/httpclient/ssl_config.rb#58
  def add_file(cert); end

  # source://httpclient//lib/httpclient/ssl_config.rb#58
  def add_path(cert); end
end

# source://httpclient//lib/httpclient/cookie.rb#176
class WebAgent; end

# source://httpclient//lib/httpclient/cookie.rb#179
class WebAgent::Cookie < ::HTTP::Cookie
  include ::HTTPClient::Util

  # Returns the value of attribute domain.
  #
  # source://httpclient//lib/httpclient/cookie.rb#199
  def domain; end

  # source://httpclient//lib/httpclient/cookie.rb#204
  def flag; end

  # @return [Boolean]
  #
  # source://httpclient//lib/httpclient/cookie.rb#192
  def http_only?; end

  # source://http-cookie/1.0.5/lib/http/cookie.rb#383
  def original_domain; end

  # Returns the value of attribute url.
  #
  # source://httpclient//lib/httpclient/cookie.rb#182
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://httpclient//lib/httpclient/cookie.rb#187
  def url=(url); end

  private

  # source://httpclient//lib/httpclient/cookie.rb#211
  def deprecated(old, new); end
end

# source://httpclient//lib/httpclient/cookie.rb#177
WebAgent::CookieManager = HTTPClient::CookieManager
