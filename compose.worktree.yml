# This override file makes the worktree use the same postgres and redis
# containers from the main tramline repository instead of creating new ones.
#
# Make sure the main tramline repository's postgres and redis containers are running
# before starting services in this worktree.

services:
  # Point all services to the main repo's postgres (port 5442) and redis (port 6389)
  web:
    environment:
      DATABASE_URL: postgres://postgres:postgres@host.docker.internal:5442
      REDIS_URL: redis://host.docker.internal:6389
      SIDEKIQ_REDIS_URL: redis://host.docker.internal:6389
      DEFAULT_REDIS_URL: redis://host.docker.internal:6389
      SESSION_REDIS_URL: redis://host.docker.internal:6389/0/session
      # Ngrok URLs - will use ngrok if running, otherwise localhost
      # To use ngrok, add NGROK_AUTHTOKEN to .env.development and start ngrok manually
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      setup:
        condition: service_completed_successfully
      ngrok:
        condition: service_started
        required: false  # Make ngrok optional - won't block if it fails
    healthcheck:
      test: ["CMD", "curl", "-k", "-f", "-H", "X-Monitor-Allowed: 1", "https://localhost:3000/up"]
      interval: 60s
      timeout: 1s
      retries: 2
      start_period: 3s

  worker:
    environment:
      DATABASE_URL: postgres://postgres:postgres@host.docker.internal:5442
      REDIS_URL: redis://host.docker.internal:6389/
      SIDEKIQ_REDIS_URL: redis://host.docker.internal:6389
      DEFAULT_REDIS_URL: redis://host.docker.internal:6389
      SESSION_REDIS_URL: redis://host.docker.internal:6389/0/session
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      setup:
        condition: service_completed_successfully
      ngrok:
        condition: service_started
        required: false

  setup:
    environment:
      DATABASE_URL: postgres://postgres:postgres@host.docker.internal:5442
      REDIS_URL: redis://host.docker.internal:6389/
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on: {}

  spec:
    environment:
      DATABASE_URL: postgres://postgres:postgres@host.docker.internal:5442/tramline_site_test
      REDIS_URL: redis://host.docker.internal:6389/
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      setup:
        condition: service_completed_successfully
      redis:
        condition: service_healthy
      postgres:
        condition: service_healthy
      ngrok:
        condition: service_started
        required: false

  css:
    environment:
      DATABASE_URL: postgres://postgres:postgres@host.docker.internal:5442
      REDIS_URL: redis://host.docker.internal:6389/
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      web:
        condition: service_healthy
      ngrok:
        condition: service_started
        required: false

  # Configure ngrok for worktree on different port
  # Ngrok will start automatically if NGROK_AUTHTOKEN is set in .env.development
  # Otherwise it will fail but won't block other services (restart: "no")
  ngrok:
    command: ["http", "https://web:3000", "--log=stdout", "--host-header=rewrite"]
    ports: !reset
      - '4041:4040'  # Use different port to avoid conflict with main repo
    restart: "no"  # Don't restart on failure (e.g., missing authtoken)
    healthcheck:
      test: bash -c "</dev/tcp/ngrok/4040"
      interval: 60s
      timeout: 1s
      retries: 2
      start_period: 3s

  # Override postgres and redis to do nothing - just use the main repo's containers
  postgres:
    image: alpine:latest
    command: ["sh", "-c", "while true; do sleep 3600; done"]
    restart: "no"
    ports: !reset []
    volumes: !reset []
    environment: {}
    healthcheck:
      test: ["CMD", "true"]
      interval: 1s
      retries: 1
      start_period: 1s

  redis:
    image: alpine:latest
    command: ["sh", "-c", "while true; do sleep 3600; done"]
    restart: "no"
    ports: !reset []
    volumes: !reset []
    healthcheck:
      test: ["CMD", "true"]
      interval: 1s
      retries: 1
      start_period: 1s
